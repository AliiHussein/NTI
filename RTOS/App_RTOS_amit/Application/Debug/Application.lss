
Application.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000014e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001c  00800060  000014e6  0000157a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000481  0080007c  0080007c  00001596  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001596  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000015c8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003d8  00000000  00000000  00001604  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003909  00000000  00000000  000019dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000114e  00000000  00000000  000052e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023fb  00000000  00000000  00006433  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000af0  00000000  00000000  00008830  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001441  00000000  00000000  00009320  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000335f  00000000  00000000  0000a761  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000368  00000000  00000000  0000dac0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 77 03 	jmp	0x6ee	; 0x6ee <__vector_1>
       8:	0c 94 9e 03 	jmp	0x73c	; 0x73c <__vector_2>
       c:	0c 94 c5 03 	jmp	0x78a	; 0x78a <__vector_3>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 99 06 	jmp	0xd32	; 0xd32 <__vector_7>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	d8 01       	movw	r26, r16
      56:	e5 01       	movw	r28, r10
      58:	f2 01       	movw	r30, r4
      5a:	ff 01       	movw	r30, r30
      5c:	0c 02       	muls	r16, r28
      5e:	19 02       	muls	r17, r25
      60:	26 02       	muls	r18, r22
      62:	33 02       	muls	r19, r19
      64:	40 02       	muls	r20, r16
      66:	4d 02       	muls	r20, r29

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf e5       	ldi	r28, 0x5F	; 95
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	10 e0       	ldi	r17, 0x00	; 0
      76:	a0 e6       	ldi	r26, 0x60	; 96
      78:	b0 e0       	ldi	r27, 0x00	; 0
      7a:	e6 ee       	ldi	r30, 0xE6	; 230
      7c:	f4 e1       	ldi	r31, 0x14	; 20
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ac 37       	cpi	r26, 0x7C	; 124
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	24 e0       	ldi	r18, 0x04	; 4
      8c:	ac e7       	ldi	r26, 0x7C	; 124
      8e:	b0 e0       	ldi	r27, 0x00	; 0
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ad 3f       	cpi	r26, 0xFD	; 253
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 bb 02 	call	0x576	; 0x576 <main>
      9e:	0c 94 71 0a 	jmp	0x14e2	; 0x14e2 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <LCD_write_char>:
	}
	while (i >= 0){
		LCD_write_char(num_arr[i]);
		i--;
	}
}
      a6:	cf 93       	push	r28
      a8:	c8 2f       	mov	r28, r24
      aa:	88 b3       	in	r24, 0x18	; 24
      ac:	82 60       	ori	r24, 0x02	; 2
      ae:	88 bb       	out	0x18, r24	; 24
      b0:	c4 ff       	sbrs	r28, 4
      b2:	04 c0       	rjmp	.+8      	; 0xbc <LCD_write_char+0x16>
      b4:	8b b3       	in	r24, 0x1b	; 27
      b6:	80 61       	ori	r24, 0x10	; 16
      b8:	8b bb       	out	0x1b, r24	; 27
      ba:	03 c0       	rjmp	.+6      	; 0xc2 <LCD_write_char+0x1c>
      bc:	8b b3       	in	r24, 0x1b	; 27
      be:	8f 7e       	andi	r24, 0xEF	; 239
      c0:	8b bb       	out	0x1b, r24	; 27
      c2:	c5 ff       	sbrs	r28, 5
      c4:	04 c0       	rjmp	.+8      	; 0xce <LCD_write_char+0x28>
      c6:	8b b3       	in	r24, 0x1b	; 27
      c8:	80 62       	ori	r24, 0x20	; 32
      ca:	8b bb       	out	0x1b, r24	; 27
      cc:	03 c0       	rjmp	.+6      	; 0xd4 <LCD_write_char+0x2e>
      ce:	8b b3       	in	r24, 0x1b	; 27
      d0:	8f 7d       	andi	r24, 0xDF	; 223
      d2:	8b bb       	out	0x1b, r24	; 27
      d4:	c6 ff       	sbrs	r28, 6
      d6:	04 c0       	rjmp	.+8      	; 0xe0 <LCD_write_char+0x3a>
      d8:	8b b3       	in	r24, 0x1b	; 27
      da:	80 64       	ori	r24, 0x40	; 64
      dc:	8b bb       	out	0x1b, r24	; 27
      de:	03 c0       	rjmp	.+6      	; 0xe6 <LCD_write_char+0x40>
      e0:	8b b3       	in	r24, 0x1b	; 27
      e2:	8f 7b       	andi	r24, 0xBF	; 191
      e4:	8b bb       	out	0x1b, r24	; 27
      e6:	cc 23       	and	r28, r28
      e8:	24 f4       	brge	.+8      	; 0xf2 <LCD_write_char+0x4c>
      ea:	8b b3       	in	r24, 0x1b	; 27
      ec:	80 68       	ori	r24, 0x80	; 128
      ee:	8b bb       	out	0x1b, r24	; 27
      f0:	03 c0       	rjmp	.+6      	; 0xf8 <LCD_write_char+0x52>
      f2:	8b b3       	in	r24, 0x1b	; 27
      f4:	8f 77       	andi	r24, 0x7F	; 127
      f6:	8b bb       	out	0x1b, r24	; 27
      f8:	88 b3       	in	r24, 0x18	; 24
      fa:	88 60       	ori	r24, 0x08	; 8
      fc:	88 bb       	out	0x18, r24	; 24
      fe:	61 e0       	ldi	r22, 0x01	; 1
     100:	70 e0       	ldi	r23, 0x00	; 0
     102:	80 e0       	ldi	r24, 0x00	; 0
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     10a:	88 b3       	in	r24, 0x18	; 24
     10c:	87 7f       	andi	r24, 0xF7	; 247
     10e:	88 bb       	out	0x18, r24	; 24
     110:	61 e0       	ldi	r22, 0x01	; 1
     112:	70 e0       	ldi	r23, 0x00	; 0
     114:	80 e0       	ldi	r24, 0x00	; 0
     116:	90 e0       	ldi	r25, 0x00	; 0
     118:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     11c:	c0 ff       	sbrs	r28, 0
     11e:	04 c0       	rjmp	.+8      	; 0x128 <LCD_write_char+0x82>
     120:	8b b3       	in	r24, 0x1b	; 27
     122:	80 61       	ori	r24, 0x10	; 16
     124:	8b bb       	out	0x1b, r24	; 27
     126:	03 c0       	rjmp	.+6      	; 0x12e <LCD_write_char+0x88>
     128:	8b b3       	in	r24, 0x1b	; 27
     12a:	8f 7e       	andi	r24, 0xEF	; 239
     12c:	8b bb       	out	0x1b, r24	; 27
     12e:	c1 ff       	sbrs	r28, 1
     130:	04 c0       	rjmp	.+8      	; 0x13a <LCD_write_char+0x94>
     132:	8b b3       	in	r24, 0x1b	; 27
     134:	80 62       	ori	r24, 0x20	; 32
     136:	8b bb       	out	0x1b, r24	; 27
     138:	03 c0       	rjmp	.+6      	; 0x140 <LCD_write_char+0x9a>
     13a:	8b b3       	in	r24, 0x1b	; 27
     13c:	8f 7d       	andi	r24, 0xDF	; 223
     13e:	8b bb       	out	0x1b, r24	; 27
     140:	c2 ff       	sbrs	r28, 2
     142:	04 c0       	rjmp	.+8      	; 0x14c <LCD_write_char+0xa6>
     144:	8b b3       	in	r24, 0x1b	; 27
     146:	80 64       	ori	r24, 0x40	; 64
     148:	8b bb       	out	0x1b, r24	; 27
     14a:	03 c0       	rjmp	.+6      	; 0x152 <LCD_write_char+0xac>
     14c:	8b b3       	in	r24, 0x1b	; 27
     14e:	8f 7b       	andi	r24, 0xBF	; 191
     150:	8b bb       	out	0x1b, r24	; 27
     152:	c3 ff       	sbrs	r28, 3
     154:	04 c0       	rjmp	.+8      	; 0x15e <LCD_write_char+0xb8>
     156:	8b b3       	in	r24, 0x1b	; 27
     158:	80 68       	ori	r24, 0x80	; 128
     15a:	8b bb       	out	0x1b, r24	; 27
     15c:	03 c0       	rjmp	.+6      	; 0x164 <LCD_write_char+0xbe>
     15e:	8b b3       	in	r24, 0x1b	; 27
     160:	8f 77       	andi	r24, 0x7F	; 127
     162:	8b bb       	out	0x1b, r24	; 27
     164:	88 b3       	in	r24, 0x18	; 24
     166:	88 60       	ori	r24, 0x08	; 8
     168:	88 bb       	out	0x18, r24	; 24
     16a:	61 e0       	ldi	r22, 0x01	; 1
     16c:	70 e0       	ldi	r23, 0x00	; 0
     16e:	80 e0       	ldi	r24, 0x00	; 0
     170:	90 e0       	ldi	r25, 0x00	; 0
     172:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     176:	88 b3       	in	r24, 0x18	; 24
     178:	87 7f       	andi	r24, 0xF7	; 247
     17a:	88 bb       	out	0x18, r24	; 24
     17c:	61 e0       	ldi	r22, 0x01	; 1
     17e:	70 e0       	ldi	r23, 0x00	; 0
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	90 e0       	ldi	r25, 0x00	; 0
     184:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     188:	cf 91       	pop	r28
     18a:	08 95       	ret

0000018c <LCD_write_command>:
     18c:	cf 93       	push	r28
     18e:	c8 2f       	mov	r28, r24
     190:	88 b3       	in	r24, 0x18	; 24
     192:	8d 7f       	andi	r24, 0xFD	; 253
     194:	88 bb       	out	0x18, r24	; 24
     196:	c4 ff       	sbrs	r28, 4
     198:	04 c0       	rjmp	.+8      	; 0x1a2 <LCD_write_command+0x16>
     19a:	8b b3       	in	r24, 0x1b	; 27
     19c:	80 61       	ori	r24, 0x10	; 16
     19e:	8b bb       	out	0x1b, r24	; 27
     1a0:	03 c0       	rjmp	.+6      	; 0x1a8 <LCD_write_command+0x1c>
     1a2:	8b b3       	in	r24, 0x1b	; 27
     1a4:	8f 7e       	andi	r24, 0xEF	; 239
     1a6:	8b bb       	out	0x1b, r24	; 27
     1a8:	c5 ff       	sbrs	r28, 5
     1aa:	04 c0       	rjmp	.+8      	; 0x1b4 <LCD_write_command+0x28>
     1ac:	8b b3       	in	r24, 0x1b	; 27
     1ae:	80 62       	ori	r24, 0x20	; 32
     1b0:	8b bb       	out	0x1b, r24	; 27
     1b2:	03 c0       	rjmp	.+6      	; 0x1ba <LCD_write_command+0x2e>
     1b4:	8b b3       	in	r24, 0x1b	; 27
     1b6:	8f 7d       	andi	r24, 0xDF	; 223
     1b8:	8b bb       	out	0x1b, r24	; 27
     1ba:	c6 ff       	sbrs	r28, 6
     1bc:	04 c0       	rjmp	.+8      	; 0x1c6 <LCD_write_command+0x3a>
     1be:	8b b3       	in	r24, 0x1b	; 27
     1c0:	80 64       	ori	r24, 0x40	; 64
     1c2:	8b bb       	out	0x1b, r24	; 27
     1c4:	03 c0       	rjmp	.+6      	; 0x1cc <LCD_write_command+0x40>
     1c6:	8b b3       	in	r24, 0x1b	; 27
     1c8:	8f 7b       	andi	r24, 0xBF	; 191
     1ca:	8b bb       	out	0x1b, r24	; 27
     1cc:	cc 23       	and	r28, r28
     1ce:	24 f4       	brge	.+8      	; 0x1d8 <LCD_write_command+0x4c>
     1d0:	8b b3       	in	r24, 0x1b	; 27
     1d2:	80 68       	ori	r24, 0x80	; 128
     1d4:	8b bb       	out	0x1b, r24	; 27
     1d6:	03 c0       	rjmp	.+6      	; 0x1de <LCD_write_command+0x52>
     1d8:	8b b3       	in	r24, 0x1b	; 27
     1da:	8f 77       	andi	r24, 0x7F	; 127
     1dc:	8b bb       	out	0x1b, r24	; 27
     1de:	88 b3       	in	r24, 0x18	; 24
     1e0:	88 60       	ori	r24, 0x08	; 8
     1e2:	88 bb       	out	0x18, r24	; 24
     1e4:	61 e0       	ldi	r22, 0x01	; 1
     1e6:	70 e0       	ldi	r23, 0x00	; 0
     1e8:	80 e0       	ldi	r24, 0x00	; 0
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     1f0:	88 b3       	in	r24, 0x18	; 24
     1f2:	87 7f       	andi	r24, 0xF7	; 247
     1f4:	88 bb       	out	0x18, r24	; 24
     1f6:	61 e0       	ldi	r22, 0x01	; 1
     1f8:	70 e0       	ldi	r23, 0x00	; 0
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     202:	c0 ff       	sbrs	r28, 0
     204:	04 c0       	rjmp	.+8      	; 0x20e <LCD_write_command+0x82>
     206:	8b b3       	in	r24, 0x1b	; 27
     208:	80 61       	ori	r24, 0x10	; 16
     20a:	8b bb       	out	0x1b, r24	; 27
     20c:	03 c0       	rjmp	.+6      	; 0x214 <LCD_write_command+0x88>
     20e:	8b b3       	in	r24, 0x1b	; 27
     210:	8f 7e       	andi	r24, 0xEF	; 239
     212:	8b bb       	out	0x1b, r24	; 27
     214:	c1 ff       	sbrs	r28, 1
     216:	04 c0       	rjmp	.+8      	; 0x220 <LCD_write_command+0x94>
     218:	8b b3       	in	r24, 0x1b	; 27
     21a:	80 62       	ori	r24, 0x20	; 32
     21c:	8b bb       	out	0x1b, r24	; 27
     21e:	03 c0       	rjmp	.+6      	; 0x226 <LCD_write_command+0x9a>
     220:	8b b3       	in	r24, 0x1b	; 27
     222:	8f 7d       	andi	r24, 0xDF	; 223
     224:	8b bb       	out	0x1b, r24	; 27
     226:	c2 ff       	sbrs	r28, 2
     228:	04 c0       	rjmp	.+8      	; 0x232 <LCD_write_command+0xa6>
     22a:	8b b3       	in	r24, 0x1b	; 27
     22c:	80 64       	ori	r24, 0x40	; 64
     22e:	8b bb       	out	0x1b, r24	; 27
     230:	03 c0       	rjmp	.+6      	; 0x238 <LCD_write_command+0xac>
     232:	8b b3       	in	r24, 0x1b	; 27
     234:	8f 7b       	andi	r24, 0xBF	; 191
     236:	8b bb       	out	0x1b, r24	; 27
     238:	c3 ff       	sbrs	r28, 3
     23a:	04 c0       	rjmp	.+8      	; 0x244 <LCD_write_command+0xb8>
     23c:	8b b3       	in	r24, 0x1b	; 27
     23e:	80 68       	ori	r24, 0x80	; 128
     240:	8b bb       	out	0x1b, r24	; 27
     242:	03 c0       	rjmp	.+6      	; 0x24a <LCD_write_command+0xbe>
     244:	8b b3       	in	r24, 0x1b	; 27
     246:	8f 77       	andi	r24, 0x7F	; 127
     248:	8b bb       	out	0x1b, r24	; 27
     24a:	88 b3       	in	r24, 0x18	; 24
     24c:	88 60       	ori	r24, 0x08	; 8
     24e:	88 bb       	out	0x18, r24	; 24
     250:	61 e0       	ldi	r22, 0x01	; 1
     252:	70 e0       	ldi	r23, 0x00	; 0
     254:	80 e0       	ldi	r24, 0x00	; 0
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     25c:	88 b3       	in	r24, 0x18	; 24
     25e:	87 7f       	andi	r24, 0xF7	; 247
     260:	88 bb       	out	0x18, r24	; 24
     262:	61 e0       	ldi	r22, 0x01	; 1
     264:	70 e0       	ldi	r23, 0x00	; 0
     266:	80 e0       	ldi	r24, 0x00	; 0
     268:	90 e0       	ldi	r25, 0x00	; 0
     26a:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     26e:	cf 91       	pop	r28
     270:	08 95       	ret

00000272 <LCD_init>:
     272:	87 b3       	in	r24, 0x17	; 23
     274:	82 60       	ori	r24, 0x02	; 2
     276:	87 bb       	out	0x17, r24	; 23
     278:	87 b3       	in	r24, 0x17	; 23
     27a:	88 60       	ori	r24, 0x08	; 8
     27c:	87 bb       	out	0x17, r24	; 23
     27e:	8a b3       	in	r24, 0x1a	; 26
     280:	80 61       	ori	r24, 0x10	; 16
     282:	8a bb       	out	0x1a, r24	; 26
     284:	8a b3       	in	r24, 0x1a	; 26
     286:	80 62       	ori	r24, 0x20	; 32
     288:	8a bb       	out	0x1a, r24	; 26
     28a:	8a b3       	in	r24, 0x1a	; 26
     28c:	80 64       	ori	r24, 0x40	; 64
     28e:	8a bb       	out	0x1a, r24	; 26
     290:	8a b3       	in	r24, 0x1a	; 26
     292:	80 68       	ori	r24, 0x80	; 128
     294:	8a bb       	out	0x1a, r24	; 26
     296:	64 e1       	ldi	r22, 0x14	; 20
     298:	70 e0       	ldi	r23, 0x00	; 0
     29a:	80 e0       	ldi	r24, 0x00	; 0
     29c:	90 e0       	ldi	r25, 0x00	; 0
     29e:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     2a2:	82 e0       	ldi	r24, 0x02	; 2
     2a4:	0e 94 c6 00 	call	0x18c	; 0x18c <LCD_write_command>
     2a8:	88 e2       	ldi	r24, 0x28	; 40
     2aa:	0e 94 c6 00 	call	0x18c	; 0x18c <LCD_write_command>
     2ae:	8c e0       	ldi	r24, 0x0C	; 12
     2b0:	0e 94 c6 00 	call	0x18c	; 0x18c <LCD_write_command>
     2b4:	86 e0       	ldi	r24, 0x06	; 6
     2b6:	0e 94 c6 00 	call	0x18c	; 0x18c <LCD_write_command>
     2ba:	81 e0       	ldi	r24, 0x01	; 1
     2bc:	0e 94 c6 00 	call	0x18c	; 0x18c <LCD_write_command>
     2c0:	6e e1       	ldi	r22, 0x1E	; 30
     2c2:	70 e0       	ldi	r23, 0x00	; 0
     2c4:	80 e0       	ldi	r24, 0x00	; 0
     2c6:	90 e0       	ldi	r25, 0x00	; 0
     2c8:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     2cc:	08 95       	ret

000002ce <LCD_write_string>:
* Purpose      : Write a string (*txt) to lcd (valid only with 4-bit mode)
*                (assume the end char of string is NULL (Ascii:'\0' - decimal:0 ))
* Parameters   : *txt  (array of char to be written on lcd)
* Return value : void
*****************************************************************************/
void LCD_write_string(uint8 * str){
     2ce:	0f 93       	push	r16
     2d0:	1f 93       	push	r17
     2d2:	cf 93       	push	r28
     2d4:	8c 01       	movw	r16, r24
	uint8 i;
	
	for(i = 0; str[i] != '\0'; i++){
     2d6:	c0 e0       	ldi	r28, 0x00	; 0
     2d8:	03 c0       	rjmp	.+6      	; 0x2e0 <LCD_write_string+0x12>
		LCD_write_char(str[i]);
     2da:	0e 94 53 00 	call	0xa6	; 0xa6 <LCD_write_char>
* Return value : void
*****************************************************************************/
void LCD_write_string(uint8 * str){
	uint8 i;
	
	for(i = 0; str[i] != '\0'; i++){
     2de:	cf 5f       	subi	r28, 0xFF	; 255
     2e0:	f8 01       	movw	r30, r16
     2e2:	ec 0f       	add	r30, r28
     2e4:	f1 1d       	adc	r31, r1
     2e6:	80 81       	ld	r24, Z
     2e8:	81 11       	cpse	r24, r1
     2ea:	f7 cf       	rjmp	.-18     	; 0x2da <LCD_write_string+0xc>
		LCD_write_char(str[i]);
	}
	
}
     2ec:	cf 91       	pop	r28
     2ee:	1f 91       	pop	r17
     2f0:	0f 91       	pop	r16
     2f2:	08 95       	ret

000002f4 <led_init>:
     2f4:	41 e0       	ldi	r20, 0x01	; 1
     2f6:	0e 94 03 03 	call	0x606	; 0x606 <DIO_voidSetPinDirection>
     2fa:	08 95       	ret

000002fc <led_toggle>:
     2fc:	82 34       	cpi	r24, 0x42	; 66
     2fe:	a1 f0       	breq	.+40     	; 0x328 <led_toggle+0x2c>
     300:	18 f4       	brcc	.+6      	; 0x308 <led_toggle+0xc>
     302:	81 34       	cpi	r24, 0x41	; 65
     304:	31 f0       	breq	.+12     	; 0x312 <led_toggle+0x16>
     306:	08 95       	ret
     308:	83 34       	cpi	r24, 0x43	; 67
     30a:	c9 f0       	breq	.+50     	; 0x33e <led_toggle+0x42>
     30c:	84 34       	cpi	r24, 0x44	; 68
     30e:	11 f1       	breq	.+68     	; 0x354 <led_toggle+0x58>
     310:	08 95       	ret
     312:	2b b3       	in	r18, 0x1b	; 27
     314:	81 e0       	ldi	r24, 0x01	; 1
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	02 c0       	rjmp	.+4      	; 0x31e <led_toggle+0x22>
     31a:	88 0f       	add	r24, r24
     31c:	99 1f       	adc	r25, r25
     31e:	6a 95       	dec	r22
     320:	e2 f7       	brpl	.-8      	; 0x31a <led_toggle+0x1e>
     322:	82 27       	eor	r24, r18
     324:	8b bb       	out	0x1b, r24	; 27
     326:	08 95       	ret
     328:	28 b3       	in	r18, 0x18	; 24
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	90 e0       	ldi	r25, 0x00	; 0
     32e:	02 c0       	rjmp	.+4      	; 0x334 <led_toggle+0x38>
     330:	88 0f       	add	r24, r24
     332:	99 1f       	adc	r25, r25
     334:	6a 95       	dec	r22
     336:	e2 f7       	brpl	.-8      	; 0x330 <led_toggle+0x34>
     338:	82 27       	eor	r24, r18
     33a:	88 bb       	out	0x18, r24	; 24
     33c:	08 95       	ret
     33e:	25 b3       	in	r18, 0x15	; 21
     340:	81 e0       	ldi	r24, 0x01	; 1
     342:	90 e0       	ldi	r25, 0x00	; 0
     344:	02 c0       	rjmp	.+4      	; 0x34a <led_toggle+0x4e>
     346:	88 0f       	add	r24, r24
     348:	99 1f       	adc	r25, r25
     34a:	6a 95       	dec	r22
     34c:	e2 f7       	brpl	.-8      	; 0x346 <led_toggle+0x4a>
     34e:	82 27       	eor	r24, r18
     350:	85 bb       	out	0x15, r24	; 21
     352:	08 95       	ret
     354:	22 b3       	in	r18, 0x12	; 18
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	02 c0       	rjmp	.+4      	; 0x360 <led_toggle+0x64>
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	6a 95       	dec	r22
     362:	e2 f7       	brpl	.-8      	; 0x35c <led_toggle+0x60>
     364:	82 27       	eor	r24, r18
     366:	82 bb       	out	0x12, r24	; 18
     368:	08 95       	ret

0000036a <sevenseg_init>:
     36a:	8c ef       	ldi	r24, 0xFC	; 252
     36c:	84 bb       	out	0x14, r24	; 20
     36e:	80 ef       	ldi	r24, 0xF0	; 240
     370:	85 bb       	out	0x15, r24	; 21
     372:	08 95       	ret

00000374 <sevenseg_write>:
     374:	e8 2f       	mov	r30, r24
     376:	85 b3       	in	r24, 0x15	; 21
     378:	88 60       	ori	r24, 0x08	; 8
     37a:	85 bb       	out	0x15, r24	; 21
     37c:	85 b3       	in	r24, 0x15	; 21
     37e:	84 60       	ori	r24, 0x04	; 4
     380:	85 bb       	out	0x15, r24	; 21
     382:	61 30       	cpi	r22, 0x01	; 1
     384:	19 f0       	breq	.+6      	; 0x38c <sevenseg_write+0x18>
     386:	62 30       	cpi	r22, 0x02	; 2
     388:	29 f0       	breq	.+10     	; 0x394 <sevenseg_write+0x20>
     38a:	07 c0       	rjmp	.+14     	; 0x39a <sevenseg_write+0x26>
     38c:	85 b3       	in	r24, 0x15	; 21
     38e:	87 7f       	andi	r24, 0xF7	; 247
     390:	85 bb       	out	0x15, r24	; 21
     392:	03 c0       	rjmp	.+6      	; 0x39a <sevenseg_write+0x26>
     394:	85 b3       	in	r24, 0x15	; 21
     396:	8b 7f       	andi	r24, 0xFB	; 251
     398:	85 bb       	out	0x15, r24	; 21
     39a:	8e 2f       	mov	r24, r30
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	8a 30       	cpi	r24, 0x0A	; 10
     3a0:	91 05       	cpc	r25, r1
     3a2:	08 f0       	brcs	.+2      	; 0x3a6 <sevenseg_write+0x32>
     3a4:	86 c0       	rjmp	.+268    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     3a6:	fc 01       	movw	r30, r24
     3a8:	e6 5d       	subi	r30, 0xD6	; 214
     3aa:	ff 4f       	sbci	r31, 0xFF	; 255
     3ac:	0c 94 51 0a 	jmp	0x14a2	; 0x14a2 <__tablejump2__>
     3b0:	85 b3       	in	r24, 0x15	; 21
     3b2:	8f 77       	andi	r24, 0x7F	; 127
     3b4:	85 bb       	out	0x15, r24	; 21
     3b6:	85 b3       	in	r24, 0x15	; 21
     3b8:	8f 7b       	andi	r24, 0xBF	; 191
     3ba:	85 bb       	out	0x15, r24	; 21
     3bc:	85 b3       	in	r24, 0x15	; 21
     3be:	8f 7d       	andi	r24, 0xDF	; 223
     3c0:	85 bb       	out	0x15, r24	; 21
     3c2:	85 b3       	in	r24, 0x15	; 21
     3c4:	8f 7e       	andi	r24, 0xEF	; 239
     3c6:	85 bb       	out	0x15, r24	; 21
     3c8:	74 c0       	rjmp	.+232    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     3ca:	85 b3       	in	r24, 0x15	; 21
     3cc:	8f 77       	andi	r24, 0x7F	; 127
     3ce:	85 bb       	out	0x15, r24	; 21
     3d0:	85 b3       	in	r24, 0x15	; 21
     3d2:	8f 7b       	andi	r24, 0xBF	; 191
     3d4:	85 bb       	out	0x15, r24	; 21
     3d6:	85 b3       	in	r24, 0x15	; 21
     3d8:	8f 7d       	andi	r24, 0xDF	; 223
     3da:	85 bb       	out	0x15, r24	; 21
     3dc:	85 b3       	in	r24, 0x15	; 21
     3de:	80 61       	ori	r24, 0x10	; 16
     3e0:	85 bb       	out	0x15, r24	; 21
     3e2:	67 c0       	rjmp	.+206    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     3e4:	85 b3       	in	r24, 0x15	; 21
     3e6:	8f 77       	andi	r24, 0x7F	; 127
     3e8:	85 bb       	out	0x15, r24	; 21
     3ea:	85 b3       	in	r24, 0x15	; 21
     3ec:	8f 7b       	andi	r24, 0xBF	; 191
     3ee:	85 bb       	out	0x15, r24	; 21
     3f0:	85 b3       	in	r24, 0x15	; 21
     3f2:	80 62       	ori	r24, 0x20	; 32
     3f4:	85 bb       	out	0x15, r24	; 21
     3f6:	85 b3       	in	r24, 0x15	; 21
     3f8:	8f 7e       	andi	r24, 0xEF	; 239
     3fa:	85 bb       	out	0x15, r24	; 21
     3fc:	5a c0       	rjmp	.+180    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     3fe:	85 b3       	in	r24, 0x15	; 21
     400:	8f 77       	andi	r24, 0x7F	; 127
     402:	85 bb       	out	0x15, r24	; 21
     404:	85 b3       	in	r24, 0x15	; 21
     406:	8f 7b       	andi	r24, 0xBF	; 191
     408:	85 bb       	out	0x15, r24	; 21
     40a:	85 b3       	in	r24, 0x15	; 21
     40c:	80 62       	ori	r24, 0x20	; 32
     40e:	85 bb       	out	0x15, r24	; 21
     410:	85 b3       	in	r24, 0x15	; 21
     412:	80 61       	ori	r24, 0x10	; 16
     414:	85 bb       	out	0x15, r24	; 21
     416:	4d c0       	rjmp	.+154    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     418:	85 b3       	in	r24, 0x15	; 21
     41a:	8f 77       	andi	r24, 0x7F	; 127
     41c:	85 bb       	out	0x15, r24	; 21
     41e:	85 b3       	in	r24, 0x15	; 21
     420:	80 64       	ori	r24, 0x40	; 64
     422:	85 bb       	out	0x15, r24	; 21
     424:	85 b3       	in	r24, 0x15	; 21
     426:	8f 7d       	andi	r24, 0xDF	; 223
     428:	85 bb       	out	0x15, r24	; 21
     42a:	85 b3       	in	r24, 0x15	; 21
     42c:	8f 7e       	andi	r24, 0xEF	; 239
     42e:	85 bb       	out	0x15, r24	; 21
     430:	40 c0       	rjmp	.+128    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     432:	85 b3       	in	r24, 0x15	; 21
     434:	8f 77       	andi	r24, 0x7F	; 127
     436:	85 bb       	out	0x15, r24	; 21
     438:	85 b3       	in	r24, 0x15	; 21
     43a:	80 64       	ori	r24, 0x40	; 64
     43c:	85 bb       	out	0x15, r24	; 21
     43e:	85 b3       	in	r24, 0x15	; 21
     440:	8f 7d       	andi	r24, 0xDF	; 223
     442:	85 bb       	out	0x15, r24	; 21
     444:	85 b3       	in	r24, 0x15	; 21
     446:	80 61       	ori	r24, 0x10	; 16
     448:	85 bb       	out	0x15, r24	; 21
     44a:	33 c0       	rjmp	.+102    	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     44c:	85 b3       	in	r24, 0x15	; 21
     44e:	8f 77       	andi	r24, 0x7F	; 127
     450:	85 bb       	out	0x15, r24	; 21
     452:	85 b3       	in	r24, 0x15	; 21
     454:	80 64       	ori	r24, 0x40	; 64
     456:	85 bb       	out	0x15, r24	; 21
     458:	85 b3       	in	r24, 0x15	; 21
     45a:	80 62       	ori	r24, 0x20	; 32
     45c:	85 bb       	out	0x15, r24	; 21
     45e:	85 b3       	in	r24, 0x15	; 21
     460:	8f 7e       	andi	r24, 0xEF	; 239
     462:	85 bb       	out	0x15, r24	; 21
     464:	26 c0       	rjmp	.+76     	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     466:	85 b3       	in	r24, 0x15	; 21
     468:	8f 77       	andi	r24, 0x7F	; 127
     46a:	85 bb       	out	0x15, r24	; 21
     46c:	85 b3       	in	r24, 0x15	; 21
     46e:	80 64       	ori	r24, 0x40	; 64
     470:	85 bb       	out	0x15, r24	; 21
     472:	85 b3       	in	r24, 0x15	; 21
     474:	80 62       	ori	r24, 0x20	; 32
     476:	85 bb       	out	0x15, r24	; 21
     478:	85 b3       	in	r24, 0x15	; 21
     47a:	80 61       	ori	r24, 0x10	; 16
     47c:	85 bb       	out	0x15, r24	; 21
     47e:	19 c0       	rjmp	.+50     	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     480:	85 b3       	in	r24, 0x15	; 21
     482:	80 68       	ori	r24, 0x80	; 128
     484:	85 bb       	out	0x15, r24	; 21
     486:	85 b3       	in	r24, 0x15	; 21
     488:	8f 7b       	andi	r24, 0xBF	; 191
     48a:	85 bb       	out	0x15, r24	; 21
     48c:	85 b3       	in	r24, 0x15	; 21
     48e:	8f 7d       	andi	r24, 0xDF	; 223
     490:	85 bb       	out	0x15, r24	; 21
     492:	85 b3       	in	r24, 0x15	; 21
     494:	8f 7e       	andi	r24, 0xEF	; 239
     496:	85 bb       	out	0x15, r24	; 21
     498:	0c c0       	rjmp	.+24     	; 0x4b2 <__EEPROM_REGION_LENGTH__+0xb2>
     49a:	85 b3       	in	r24, 0x15	; 21
     49c:	80 68       	ori	r24, 0x80	; 128
     49e:	85 bb       	out	0x15, r24	; 21
     4a0:	85 b3       	in	r24, 0x15	; 21
     4a2:	8f 7b       	andi	r24, 0xBF	; 191
     4a4:	85 bb       	out	0x15, r24	; 21
     4a6:	85 b3       	in	r24, 0x15	; 21
     4a8:	8f 7d       	andi	r24, 0xDF	; 223
     4aa:	85 bb       	out	0x15, r24	; 21
     4ac:	85 b3       	in	r24, 0x15	; 21
     4ae:	80 61       	ori	r24, 0x10	; 16
     4b0:	85 bb       	out	0x15, r24	; 21
     4b2:	61 e0       	ldi	r22, 0x01	; 1
     4b4:	70 e0       	ldi	r23, 0x00	; 0
     4b6:	80 e0       	ldi	r24, 0x00	; 0
     4b8:	90 e0       	ldi	r25, 0x00	; 0
     4ba:	0e 94 ee 02 	call	0x5dc	; 0x5dc <delay_ms>
     4be:	08 95       	ret

000004c0 <sevenseg_write_two>:
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	cd ec       	ldi	r28, 0xCD	; 205
     4c6:	8c 9f       	mul	r24, r28
     4c8:	d1 2d       	mov	r29, r1
     4ca:	11 24       	eor	r1, r1
     4cc:	d6 95       	lsr	r29
     4ce:	d6 95       	lsr	r29
     4d0:	d6 95       	lsr	r29
     4d2:	2d 2f       	mov	r18, r29
     4d4:	22 0f       	add	r18, r18
     4d6:	92 2f       	mov	r25, r18
     4d8:	99 0f       	add	r25, r25
     4da:	99 0f       	add	r25, r25
     4dc:	92 0f       	add	r25, r18
     4de:	61 e0       	ldi	r22, 0x01	; 1
     4e0:	89 1b       	sub	r24, r25
     4e2:	0e 94 ba 01 	call	0x374	; 0x374 <sevenseg_write>
     4e6:	dc 9f       	mul	r29, r28
     4e8:	c1 2d       	mov	r28, r1
     4ea:	11 24       	eor	r1, r1
     4ec:	c6 95       	lsr	r28
     4ee:	c6 95       	lsr	r28
     4f0:	c6 95       	lsr	r28
     4f2:	cc 0f       	add	r28, r28
     4f4:	8c 2f       	mov	r24, r28
     4f6:	88 0f       	add	r24, r24
     4f8:	88 0f       	add	r24, r24
     4fa:	c8 0f       	add	r28, r24
     4fc:	62 e0       	ldi	r22, 0x02	; 2
     4fe:	8d 2f       	mov	r24, r29
     500:	8c 1b       	sub	r24, r28
     502:	0e 94 ba 01 	call	0x374	; 0x374 <sevenseg_write>
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	08 95       	ret

0000050c <task1>:
#include "HAL/SevenSeg/SevenSeg.h"

SemaphoreHandle_t c_flag = 0; // creating a semaphore variable

void task1(void){
	led_init(portD,5);
     50c:	65 e0       	ldi	r22, 0x05	; 5
     50e:	84 e4       	ldi	r24, 0x44	; 68
     510:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <led_init>
	while (1)
	{
		led_toggle(portD,5);
     514:	65 e0       	ldi	r22, 0x05	; 5
     516:	84 e4       	ldi	r24, 0x44	; 68
     518:	0e 94 7e 01 	call	0x2fc	; 0x2fc <led_toggle>
		vTaskDelay(1000);
     51c:	88 ee       	ldi	r24, 0xE8	; 232
     51e:	93 e0       	ldi	r25, 0x03	; 3
     520:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskDelay>
     524:	f7 cf       	rjmp	.-18     	; 0x514 <task1+0x8>

00000526 <task2>:
	}
}

void task2(void){
	led_init(portD, 6);
     526:	66 e0       	ldi	r22, 0x06	; 6
     528:	84 e4       	ldi	r24, 0x44	; 68
     52a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <led_init>
	while (1)
	{
		led_toggle(portD,6);
     52e:	66 e0       	ldi	r22, 0x06	; 6
     530:	84 e4       	ldi	r24, 0x44	; 68
     532:	0e 94 7e 01 	call	0x2fc	; 0x2fc <led_toggle>
		vTaskDelay(10000);
     536:	80 e1       	ldi	r24, 0x10	; 16
     538:	97 e2       	ldi	r25, 0x27	; 39
     53a:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskDelay>
     53e:	f7 cf       	rjmp	.-18     	; 0x52e <task2+0x8>

00000540 <task3>:
	}
}

void task3(void){
	sevenseg_init();
     540:	0e 94 b5 01 	call	0x36a	; 0x36a <sevenseg_init>
	uint8 count = 0;
     544:	10 e0       	ldi	r17, 0x00	; 0
	while(1)
	{
		
		for(int i = 0; i < 333; i++){
     546:	c0 e0       	ldi	r28, 0x00	; 0
     548:	d0 e0       	ldi	r29, 0x00	; 0
     54a:	08 c0       	rjmp	.+16     	; 0x55c <task3+0x1c>
			sevenseg_write_two(count);
     54c:	81 2f       	mov	r24, r17
     54e:	0e 94 60 02 	call	0x4c0	; 0x4c0 <sevenseg_write_two>
			vTaskDelay(1);
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	90 e0       	ldi	r25, 0x00	; 0
     556:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskDelay>
	sevenseg_init();
	uint8 count = 0;
	while(1)
	{
		
		for(int i = 0; i < 333; i++){
     55a:	21 96       	adiw	r28, 0x01	; 1
     55c:	cd 34       	cpi	r28, 0x4D	; 77
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	d8 07       	cpc	r29, r24
     562:	a4 f3       	brlt	.-24     	; 0x54c <task3+0xc>
			sevenseg_write_two(count);
			vTaskDelay(1);
		}
		
		count++;
     564:	1f 5f       	subi	r17, 0xFF	; 255
		if(count == 100){
     566:	14 36       	cpi	r17, 0x64	; 100
     568:	09 f4       	brne	.+2      	; 0x56c <task3+0x2c>
			count = 0;
     56a:	10 e0       	ldi	r17, 0x00	; 0
		}
		vTaskDelay(1);
     56c:	81 e0       	ldi	r24, 0x01	; 1
     56e:	90 e0       	ldi	r25, 0x00	; 0
     570:	0e 94 b6 09 	call	0x136c	; 0x136c <vTaskDelay>
	}
     574:	e8 cf       	rjmp	.-48     	; 0x546 <task3+0x6>

00000576 <main>:
}


int main(void){
     576:	ef 92       	push	r14
     578:	ff 92       	push	r15
     57a:	0f 93       	push	r16
	
	LCD_init();
     57c:	0e 94 39 01 	call	0x272	; 0x272 <LCD_init>
	LCD_write_string("Hello RTOS!");
     580:	82 e6       	ldi	r24, 0x62	; 98
     582:	90 e0       	ldi	r25, 0x00	; 0
     584:	0e 94 67 01 	call	0x2ce	; 0x2ce <LCD_write_string>
	/* Task creation and scheduling*/
	xTaskCreate(task1, "T1", 100, NULL, 1, NULL);
     588:	e1 2c       	mov	r14, r1
     58a:	f1 2c       	mov	r15, r1
     58c:	01 e0       	ldi	r16, 0x01	; 1
     58e:	20 e0       	ldi	r18, 0x00	; 0
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	44 e6       	ldi	r20, 0x64	; 100
     594:	50 e0       	ldi	r21, 0x00	; 0
     596:	6e e6       	ldi	r22, 0x6E	; 110
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	86 e8       	ldi	r24, 0x86	; 134
     59c:	92 e0       	ldi	r25, 0x02	; 2
     59e:	0e 94 06 08 	call	0x100c	; 0x100c <xTaskCreate>
	xTaskCreate(task2, "T2", 100, NULL, 1, NULL);
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	44 e6       	ldi	r20, 0x64	; 100
     5a8:	50 e0       	ldi	r21, 0x00	; 0
     5aa:	61 e7       	ldi	r22, 0x71	; 113
     5ac:	70 e0       	ldi	r23, 0x00	; 0
     5ae:	83 e9       	ldi	r24, 0x93	; 147
     5b0:	92 e0       	ldi	r25, 0x02	; 2
     5b2:	0e 94 06 08 	call	0x100c	; 0x100c <xTaskCreate>
	xTaskCreate(task3, "T3", 100, NULL, 2, NULL);
     5b6:	02 e0       	ldi	r16, 0x02	; 2
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	44 e6       	ldi	r20, 0x64	; 100
     5be:	50 e0       	ldi	r21, 0x00	; 0
     5c0:	64 e7       	ldi	r22, 0x74	; 116
     5c2:	70 e0       	ldi	r23, 0x00	; 0
     5c4:	80 ea       	ldi	r24, 0xA0	; 160
     5c6:	92 e0       	ldi	r25, 0x02	; 2
     5c8:	0e 94 06 08 	call	0x100c	; 0x100c <xTaskCreate>
	//xTaskCreate(task4, "T4", 100, NULL, 3, NULL);
	vTaskStartScheduler();
     5cc:	0e 94 5a 08 	call	0x10b4	; 0x10b4 <vTaskStartScheduler>
}
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	0f 91       	pop	r16
     5d6:	ff 90       	pop	r15
     5d8:	ef 90       	pop	r14
     5da:	08 95       	ret

000005dc <delay_ms>:
     5dc:	9b 01       	movw	r18, r22
     5de:	ac 01       	movw	r20, r24
     5e0:	a0 e4       	ldi	r26, 0x40	; 64
     5e2:	b6 e0       	ldi	r27, 0x06	; 6
     5e4:	0e 94 57 0a 	call	0x14ae	; 0x14ae <__muluhisi3>
     5e8:	ab 01       	movw	r20, r22
     5ea:	bc 01       	movw	r22, r24
     5ec:	80 e0       	ldi	r24, 0x00	; 0
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	dc 01       	movw	r26, r24
     5f2:	03 c0       	rjmp	.+6      	; 0x5fa <delay_ms+0x1e>
     5f4:	01 96       	adiw	r24, 0x01	; 1
     5f6:	a1 1d       	adc	r26, r1
     5f8:	b1 1d       	adc	r27, r1
     5fa:	84 17       	cp	r24, r20
     5fc:	95 07       	cpc	r25, r21
     5fe:	a6 07       	cpc	r26, r22
     600:	b7 07       	cpc	r27, r23
     602:	c0 f3       	brcs	.-16     	; 0x5f4 <delay_ms+0x18>
     604:	08 95       	ret

00000606 <DIO_voidSetPinDirection>:
     606:	41 11       	cpse	r20, r1
     608:	3b c0       	rjmp	.+118    	; 0x680 <DIO_voidSetPinDirection+0x7a>
     60a:	82 34       	cpi	r24, 0x42	; 66
     60c:	a9 f0       	breq	.+42     	; 0x638 <DIO_voidSetPinDirection+0x32>
     60e:	18 f4       	brcc	.+6      	; 0x616 <DIO_voidSetPinDirection+0x10>
     610:	81 34       	cpi	r24, 0x41	; 65
     612:	31 f0       	breq	.+12     	; 0x620 <DIO_voidSetPinDirection+0x1a>
     614:	08 95       	ret
     616:	83 34       	cpi	r24, 0x43	; 67
     618:	d9 f0       	breq	.+54     	; 0x650 <DIO_voidSetPinDirection+0x4a>
     61a:	84 34       	cpi	r24, 0x44	; 68
     61c:	29 f1       	breq	.+74     	; 0x668 <DIO_voidSetPinDirection+0x62>
     61e:	08 95       	ret
     620:	2a b3       	in	r18, 0x1a	; 26
     622:	81 e0       	ldi	r24, 0x01	; 1
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	02 c0       	rjmp	.+4      	; 0x62c <DIO_voidSetPinDirection+0x26>
     628:	88 0f       	add	r24, r24
     62a:	99 1f       	adc	r25, r25
     62c:	6a 95       	dec	r22
     62e:	e2 f7       	brpl	.-8      	; 0x628 <DIO_voidSetPinDirection+0x22>
     630:	80 95       	com	r24
     632:	82 23       	and	r24, r18
     634:	8a bb       	out	0x1a, r24	; 26
     636:	08 95       	ret
     638:	27 b3       	in	r18, 0x17	; 23
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	02 c0       	rjmp	.+4      	; 0x644 <DIO_voidSetPinDirection+0x3e>
     640:	88 0f       	add	r24, r24
     642:	99 1f       	adc	r25, r25
     644:	6a 95       	dec	r22
     646:	e2 f7       	brpl	.-8      	; 0x640 <DIO_voidSetPinDirection+0x3a>
     648:	80 95       	com	r24
     64a:	82 23       	and	r24, r18
     64c:	87 bb       	out	0x17, r24	; 23
     64e:	08 95       	ret
     650:	24 b3       	in	r18, 0x14	; 20
     652:	81 e0       	ldi	r24, 0x01	; 1
     654:	90 e0       	ldi	r25, 0x00	; 0
     656:	02 c0       	rjmp	.+4      	; 0x65c <DIO_voidSetPinDirection+0x56>
     658:	88 0f       	add	r24, r24
     65a:	99 1f       	adc	r25, r25
     65c:	6a 95       	dec	r22
     65e:	e2 f7       	brpl	.-8      	; 0x658 <DIO_voidSetPinDirection+0x52>
     660:	80 95       	com	r24
     662:	82 23       	and	r24, r18
     664:	84 bb       	out	0x14, r24	; 20
     666:	08 95       	ret
     668:	21 b3       	in	r18, 0x11	; 17
     66a:	81 e0       	ldi	r24, 0x01	; 1
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	02 c0       	rjmp	.+4      	; 0x674 <DIO_voidSetPinDirection+0x6e>
     670:	88 0f       	add	r24, r24
     672:	99 1f       	adc	r25, r25
     674:	6a 95       	dec	r22
     676:	e2 f7       	brpl	.-8      	; 0x670 <DIO_voidSetPinDirection+0x6a>
     678:	80 95       	com	r24
     67a:	82 23       	and	r24, r18
     67c:	81 bb       	out	0x11, r24	; 17
     67e:	08 95       	ret
     680:	82 34       	cpi	r24, 0x42	; 66
     682:	a1 f0       	breq	.+40     	; 0x6ac <DIO_voidSetPinDirection+0xa6>
     684:	18 f4       	brcc	.+6      	; 0x68c <DIO_voidSetPinDirection+0x86>
     686:	81 34       	cpi	r24, 0x41	; 65
     688:	31 f0       	breq	.+12     	; 0x696 <DIO_voidSetPinDirection+0x90>
     68a:	08 95       	ret
     68c:	83 34       	cpi	r24, 0x43	; 67
     68e:	c9 f0       	breq	.+50     	; 0x6c2 <DIO_voidSetPinDirection+0xbc>
     690:	84 34       	cpi	r24, 0x44	; 68
     692:	11 f1       	breq	.+68     	; 0x6d8 <DIO_voidSetPinDirection+0xd2>
     694:	08 95       	ret
     696:	2a b3       	in	r18, 0x1a	; 26
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	90 e0       	ldi	r25, 0x00	; 0
     69c:	02 c0       	rjmp	.+4      	; 0x6a2 <DIO_voidSetPinDirection+0x9c>
     69e:	88 0f       	add	r24, r24
     6a0:	99 1f       	adc	r25, r25
     6a2:	6a 95       	dec	r22
     6a4:	e2 f7       	brpl	.-8      	; 0x69e <DIO_voidSetPinDirection+0x98>
     6a6:	82 2b       	or	r24, r18
     6a8:	8a bb       	out	0x1a, r24	; 26
     6aa:	08 95       	ret
     6ac:	27 b3       	in	r18, 0x17	; 23
     6ae:	81 e0       	ldi	r24, 0x01	; 1
     6b0:	90 e0       	ldi	r25, 0x00	; 0
     6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <DIO_voidSetPinDirection+0xb2>
     6b4:	88 0f       	add	r24, r24
     6b6:	99 1f       	adc	r25, r25
     6b8:	6a 95       	dec	r22
     6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <DIO_voidSetPinDirection+0xae>
     6bc:	82 2b       	or	r24, r18
     6be:	87 bb       	out	0x17, r24	; 23
     6c0:	08 95       	ret
     6c2:	24 b3       	in	r18, 0x14	; 20
     6c4:	81 e0       	ldi	r24, 0x01	; 1
     6c6:	90 e0       	ldi	r25, 0x00	; 0
     6c8:	02 c0       	rjmp	.+4      	; 0x6ce <DIO_voidSetPinDirection+0xc8>
     6ca:	88 0f       	add	r24, r24
     6cc:	99 1f       	adc	r25, r25
     6ce:	6a 95       	dec	r22
     6d0:	e2 f7       	brpl	.-8      	; 0x6ca <DIO_voidSetPinDirection+0xc4>
     6d2:	82 2b       	or	r24, r18
     6d4:	84 bb       	out	0x14, r24	; 20
     6d6:	08 95       	ret
     6d8:	21 b3       	in	r18, 0x11	; 17
     6da:	81 e0       	ldi	r24, 0x01	; 1
     6dc:	90 e0       	ldi	r25, 0x00	; 0
     6de:	02 c0       	rjmp	.+4      	; 0x6e4 <DIO_voidSetPinDirection+0xde>
     6e0:	88 0f       	add	r24, r24
     6e2:	99 1f       	adc	r25, r25
     6e4:	6a 95       	dec	r22
     6e6:	e2 f7       	brpl	.-8      	; 0x6e0 <DIO_voidSetPinDirection+0xda>
     6e8:	82 2b       	or	r24, r18
     6ea:	81 bb       	out	0x11, r24	; 17
     6ec:	08 95       	ret

000006ee <__vector_1>:
     6ee:	1f 92       	push	r1
     6f0:	0f 92       	push	r0
     6f2:	0f b6       	in	r0, 0x3f	; 63
     6f4:	0f 92       	push	r0
     6f6:	11 24       	eor	r1, r1
     6f8:	2f 93       	push	r18
     6fa:	3f 93       	push	r19
     6fc:	4f 93       	push	r20
     6fe:	5f 93       	push	r21
     700:	6f 93       	push	r22
     702:	7f 93       	push	r23
     704:	8f 93       	push	r24
     706:	9f 93       	push	r25
     708:	af 93       	push	r26
     70a:	bf 93       	push	r27
     70c:	ef 93       	push	r30
     70e:	ff 93       	push	r31
     710:	e0 91 80 00 	lds	r30, 0x0080	; 0x800080 <ptr_EXT1>
     714:	f0 91 81 00 	lds	r31, 0x0081	; 0x800081 <ptr_EXT1+0x1>
     718:	09 95       	icall
     71a:	ff 91       	pop	r31
     71c:	ef 91       	pop	r30
     71e:	bf 91       	pop	r27
     720:	af 91       	pop	r26
     722:	9f 91       	pop	r25
     724:	8f 91       	pop	r24
     726:	7f 91       	pop	r23
     728:	6f 91       	pop	r22
     72a:	5f 91       	pop	r21
     72c:	4f 91       	pop	r20
     72e:	3f 91       	pop	r19
     730:	2f 91       	pop	r18
     732:	0f 90       	pop	r0
     734:	0f be       	out	0x3f, r0	; 63
     736:	0f 90       	pop	r0
     738:	1f 90       	pop	r1
     73a:	18 95       	reti

0000073c <__vector_2>:
     73c:	1f 92       	push	r1
     73e:	0f 92       	push	r0
     740:	0f b6       	in	r0, 0x3f	; 63
     742:	0f 92       	push	r0
     744:	11 24       	eor	r1, r1
     746:	2f 93       	push	r18
     748:	3f 93       	push	r19
     74a:	4f 93       	push	r20
     74c:	5f 93       	push	r21
     74e:	6f 93       	push	r22
     750:	7f 93       	push	r23
     752:	8f 93       	push	r24
     754:	9f 93       	push	r25
     756:	af 93       	push	r26
     758:	bf 93       	push	r27
     75a:	ef 93       	push	r30
     75c:	ff 93       	push	r31
     75e:	e0 91 7e 00 	lds	r30, 0x007E	; 0x80007e <ptr_EXT2>
     762:	f0 91 7f 00 	lds	r31, 0x007F	; 0x80007f <ptr_EXT2+0x1>
     766:	09 95       	icall
     768:	ff 91       	pop	r31
     76a:	ef 91       	pop	r30
     76c:	bf 91       	pop	r27
     76e:	af 91       	pop	r26
     770:	9f 91       	pop	r25
     772:	8f 91       	pop	r24
     774:	7f 91       	pop	r23
     776:	6f 91       	pop	r22
     778:	5f 91       	pop	r21
     77a:	4f 91       	pop	r20
     77c:	3f 91       	pop	r19
     77e:	2f 91       	pop	r18
     780:	0f 90       	pop	r0
     782:	0f be       	out	0x3f, r0	; 63
     784:	0f 90       	pop	r0
     786:	1f 90       	pop	r1
     788:	18 95       	reti

0000078a <__vector_3>:
     78a:	1f 92       	push	r1
     78c:	0f 92       	push	r0
     78e:	0f b6       	in	r0, 0x3f	; 63
     790:	0f 92       	push	r0
     792:	11 24       	eor	r1, r1
     794:	2f 93       	push	r18
     796:	3f 93       	push	r19
     798:	4f 93       	push	r20
     79a:	5f 93       	push	r21
     79c:	6f 93       	push	r22
     79e:	7f 93       	push	r23
     7a0:	8f 93       	push	r24
     7a2:	9f 93       	push	r25
     7a4:	af 93       	push	r26
     7a6:	bf 93       	push	r27
     7a8:	ef 93       	push	r30
     7aa:	ff 93       	push	r31
     7ac:	e0 91 7c 00 	lds	r30, 0x007C	; 0x80007c <__data_end>
     7b0:	f0 91 7d 00 	lds	r31, 0x007D	; 0x80007d <__data_end+0x1>
     7b4:	09 95       	icall
     7b6:	ff 91       	pop	r31
     7b8:	ef 91       	pop	r30
     7ba:	bf 91       	pop	r27
     7bc:	af 91       	pop	r26
     7be:	9f 91       	pop	r25
     7c0:	8f 91       	pop	r24
     7c2:	7f 91       	pop	r23
     7c4:	6f 91       	pop	r22
     7c6:	5f 91       	pop	r21
     7c8:	4f 91       	pop	r20
     7ca:	3f 91       	pop	r19
     7cc:	2f 91       	pop	r18
     7ce:	0f 90       	pop	r0
     7d0:	0f be       	out	0x3f, r0	; 63
     7d2:	0f 90       	pop	r0
     7d4:	1f 90       	pop	r1
     7d6:	18 95       	reti

000007d8 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     7d8:	e7 e8       	ldi	r30, 0x87	; 135
     7da:	f0 e0       	ldi	r31, 0x00	; 0
     7dc:	8c e8       	ldi	r24, 0x8C	; 140
     7de:	90 e0       	ldi	r25, 0x00	; 0
     7e0:	91 83       	std	Z+1, r25	; 0x01
     7e2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     7e4:	13 82       	std	Z+3, r1	; 0x03
     7e6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     7e8:	e3 e8       	ldi	r30, 0x83	; 131
     7ea:	f0 e0       	ldi	r31, 0x00	; 0
     7ec:	87 ee       	ldi	r24, 0xE7	; 231
     7ee:	93 e0       	ldi	r25, 0x03	; 3
     7f0:	93 83       	std	Z+3, r25	; 0x03
     7f2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     7f4:	11 82       	std	Z+1, r1	; 0x01
     7f6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     7f8:	ab e8       	ldi	r26, 0x8B	; 139
     7fa:	b0 e0       	ldi	r27, 0x00	; 0
     7fc:	14 96       	adiw	r26, 0x04	; 4
     7fe:	9c 93       	st	X, r25
     800:	8e 93       	st	-X, r24
     802:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     804:	12 96       	adiw	r26, 0x02	; 2
     806:	fc 93       	st	X, r31
     808:	ee 93       	st	-X, r30
     80a:	11 97       	sbiw	r26, 0x01	; 1
     80c:	08 95       	ret

0000080e <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     80e:	0f 93       	push	r16
     810:	1f 93       	push	r17
     812:	cf 93       	push	r28
     814:	df 93       	push	r29
     816:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     818:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     81c:	80 91 82 00 	lds	r24, 0x0082	; 0x800082 <xHeapHasBeenInitialised.2079>
     820:	81 11       	cpse	r24, r1
     822:	05 c0       	rjmp	.+10     	; 0x82e <pvPortMalloc+0x20>
		{
			prvHeapInit();
     824:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     828:	81 e0       	ldi	r24, 0x01	; 1
     82a:	80 93 82 00 	sts	0x0082, r24	; 0x800082 <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     82e:	20 97       	sbiw	r28, 0x00	; 0
     830:	09 f0       	breq	.+2      	; 0x834 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     832:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     834:	ce 01       	movw	r24, r28
     836:	01 97       	sbiw	r24, 0x01	; 1
     838:	86 3e       	cpi	r24, 0xE6	; 230
     83a:	93 40       	sbci	r25, 0x03	; 3
     83c:	08 f0       	brcs	.+2      	; 0x840 <pvPortMalloc+0x32>
     83e:	56 c0       	rjmp	.+172    	; 0x8ec <__stack+0x8d>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     840:	e0 91 87 00 	lds	r30, 0x0087	; 0x800087 <xStart>
     844:	f0 91 88 00 	lds	r31, 0x0088	; 0x800088 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     848:	a7 e8       	ldi	r26, 0x87	; 135
     84a:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     84c:	02 c0       	rjmp	.+4      	; 0x852 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     84e:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     850:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     852:	82 81       	ldd	r24, Z+2	; 0x02
     854:	93 81       	ldd	r25, Z+3	; 0x03
     856:	8c 17       	cp	r24, r28
     858:	9d 07       	cpc	r25, r29
     85a:	20 f4       	brcc	.+8      	; 0x864 <__stack+0x5>
     85c:	80 81       	ld	r24, Z
     85e:	91 81       	ldd	r25, Z+1	; 0x01
     860:	00 97       	sbiw	r24, 0x00	; 0
     862:	a9 f7       	brne	.-22     	; 0x84e <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	e3 38       	cpi	r30, 0x83	; 131
     868:	f8 07       	cpc	r31, r24
     86a:	09 f4       	brne	.+2      	; 0x86e <__stack+0xf>
     86c:	42 c0       	rjmp	.+132    	; 0x8f2 <__stack+0x93>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     86e:	0d 91       	ld	r16, X+
     870:	1c 91       	ld	r17, X
     872:	11 97       	sbiw	r26, 0x01	; 1
     874:	0c 5f       	subi	r16, 0xFC	; 252
     876:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     878:	80 81       	ld	r24, Z
     87a:	91 81       	ldd	r25, Z+1	; 0x01
     87c:	8d 93       	st	X+, r24
     87e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     880:	82 81       	ldd	r24, Z+2	; 0x02
     882:	93 81       	ldd	r25, Z+3	; 0x03
     884:	8c 1b       	sub	r24, r28
     886:	9d 0b       	sbc	r25, r29
     888:	89 30       	cpi	r24, 0x09	; 9
     88a:	91 05       	cpc	r25, r1
     88c:	10 f1       	brcs	.+68     	; 0x8d2 <__stack+0x73>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     88e:	af 01       	movw	r20, r30
     890:	4c 0f       	add	r20, r28
     892:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     894:	da 01       	movw	r26, r20
     896:	13 96       	adiw	r26, 0x03	; 3
     898:	9c 93       	st	X, r25
     89a:	8e 93       	st	-X, r24
     89c:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     89e:	d3 83       	std	Z+3, r29	; 0x03
     8a0:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     8a2:	12 96       	adiw	r26, 0x02	; 2
     8a4:	2d 91       	ld	r18, X+
     8a6:	3c 91       	ld	r19, X
     8a8:	13 97       	sbiw	r26, 0x03	; 3
     8aa:	67 e8       	ldi	r22, 0x87	; 135
     8ac:	70 e0       	ldi	r23, 0x00	; 0
     8ae:	01 c0       	rjmp	.+2      	; 0x8b2 <__stack+0x53>
     8b0:	bd 01       	movw	r22, r26
     8b2:	eb 01       	movw	r28, r22
     8b4:	a8 81       	ld	r26, Y
     8b6:	b9 81       	ldd	r27, Y+1	; 0x01
     8b8:	12 96       	adiw	r26, 0x02	; 2
     8ba:	8d 91       	ld	r24, X+
     8bc:	9c 91       	ld	r25, X
     8be:	13 97       	sbiw	r26, 0x03	; 3
     8c0:	82 17       	cp	r24, r18
     8c2:	93 07       	cpc	r25, r19
     8c4:	a8 f3       	brcs	.-22     	; 0x8b0 <__stack+0x51>
     8c6:	ea 01       	movw	r28, r20
     8c8:	b9 83       	std	Y+1, r27	; 0x01
     8ca:	a8 83       	st	Y, r26
     8cc:	db 01       	movw	r26, r22
     8ce:	4d 93       	st	X+, r20
     8d0:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     8d2:	22 81       	ldd	r18, Z+2	; 0x02
     8d4:	33 81       	ldd	r19, Z+3	; 0x03
     8d6:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     8da:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     8de:	82 1b       	sub	r24, r18
     8e0:	93 0b       	sbc	r25, r19
     8e2:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     8e6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     8ea:	05 c0       	rjmp	.+10     	; 0x8f6 <__stack+0x97>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     8ec:	00 e0       	ldi	r16, 0x00	; 0
     8ee:	10 e0       	ldi	r17, 0x00	; 0
     8f0:	02 c0       	rjmp	.+4      	; 0x8f6 <__stack+0x97>
     8f2:	00 e0       	ldi	r16, 0x00	; 0
     8f4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     8f6:	0e 94 44 09 	call	0x1288	; 0x1288 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     8fa:	c8 01       	movw	r24, r16
     8fc:	df 91       	pop	r29
     8fe:	cf 91       	pop	r28
     900:	1f 91       	pop	r17
     902:	0f 91       	pop	r16
     904:	08 95       	ret

00000906 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     906:	0f 93       	push	r16
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     90e:	00 97       	sbiw	r24, 0x00	; 0
     910:	41 f1       	breq	.+80     	; 0x962 <vPortFree+0x5c>
     912:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     914:	8c 01       	movw	r16, r24
     916:	04 50       	subi	r16, 0x04	; 4
     918:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     91a:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     91e:	f8 01       	movw	r30, r16
     920:	42 81       	ldd	r20, Z+2	; 0x02
     922:	53 81       	ldd	r21, Z+3	; 0x03
     924:	a7 e8       	ldi	r26, 0x87	; 135
     926:	b0 e0       	ldi	r27, 0x00	; 0
     928:	01 c0       	rjmp	.+2      	; 0x92c <vPortFree+0x26>
     92a:	df 01       	movw	r26, r30
     92c:	ed 91       	ld	r30, X+
     92e:	fc 91       	ld	r31, X
     930:	11 97       	sbiw	r26, 0x01	; 1
     932:	22 81       	ldd	r18, Z+2	; 0x02
     934:	33 81       	ldd	r19, Z+3	; 0x03
     936:	24 17       	cp	r18, r20
     938:	35 07       	cpc	r19, r21
     93a:	b8 f3       	brcs	.-18     	; 0x92a <vPortFree+0x24>
     93c:	24 97       	sbiw	r28, 0x04	; 4
     93e:	f9 83       	std	Y+1, r31	; 0x01
     940:	e8 83       	st	Y, r30
     942:	0d 93       	st	X+, r16
     944:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     946:	8a 81       	ldd	r24, Y+2	; 0x02
     948:	9b 81       	ldd	r25, Y+3	; 0x03
     94a:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     94e:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     952:	82 0f       	add	r24, r18
     954:	93 1f       	adc	r25, r19
     956:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     95a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     95e:	0e 94 44 09 	call	0x1288	; 0x1288 <xTaskResumeAll>
	}
}
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	08 95       	ret

0000096c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     96c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     96e:	03 96       	adiw	r24, 0x03	; 3
     970:	92 83       	std	Z+2, r25	; 0x02
     972:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     974:	2f ef       	ldi	r18, 0xFF	; 255
     976:	3f ef       	ldi	r19, 0xFF	; 255
     978:	34 83       	std	Z+4, r19	; 0x04
     97a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     97c:	96 83       	std	Z+6, r25	; 0x06
     97e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     980:	90 87       	std	Z+8, r25	; 0x08
     982:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     984:	10 82       	st	Z, r1
     986:	08 95       	ret

00000988 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     988:	fc 01       	movw	r30, r24
     98a:	11 86       	std	Z+9, r1	; 0x09
     98c:	10 86       	std	Z+8, r1	; 0x08
     98e:	08 95       	ret

00000990 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     990:	cf 93       	push	r28
     992:	df 93       	push	r29
     994:	9c 01       	movw	r18, r24
     996:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     998:	dc 01       	movw	r26, r24
     99a:	11 96       	adiw	r26, 0x01	; 1
     99c:	cd 91       	ld	r28, X+
     99e:	dc 91       	ld	r29, X
     9a0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     9a2:	d3 83       	std	Z+3, r29	; 0x03
     9a4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     9a6:	8c 81       	ldd	r24, Y+4	; 0x04
     9a8:	9d 81       	ldd	r25, Y+5	; 0x05
     9aa:	95 83       	std	Z+5, r25	; 0x05
     9ac:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     9ae:	8c 81       	ldd	r24, Y+4	; 0x04
     9b0:	9d 81       	ldd	r25, Y+5	; 0x05
     9b2:	dc 01       	movw	r26, r24
     9b4:	13 96       	adiw	r26, 0x03	; 3
     9b6:	7c 93       	st	X, r23
     9b8:	6e 93       	st	-X, r22
     9ba:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     9bc:	7d 83       	std	Y+5, r23	; 0x05
     9be:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     9c0:	31 87       	std	Z+9, r19	; 0x09
     9c2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     9c4:	f9 01       	movw	r30, r18
     9c6:	80 81       	ld	r24, Z
     9c8:	8f 5f       	subi	r24, 0xFF	; 255
     9ca:	80 83       	st	Z, r24
}
     9cc:	df 91       	pop	r29
     9ce:	cf 91       	pop	r28
     9d0:	08 95       	ret

000009d2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     9d8:	48 81       	ld	r20, Y
     9da:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     9dc:	4f 3f       	cpi	r20, 0xFF	; 255
     9de:	2f ef       	ldi	r18, 0xFF	; 255
     9e0:	52 07       	cpc	r21, r18
     9e2:	21 f4       	brne	.+8      	; 0x9ec <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     9e4:	fc 01       	movw	r30, r24
     9e6:	a7 81       	ldd	r26, Z+7	; 0x07
     9e8:	b0 85       	ldd	r27, Z+8	; 0x08
     9ea:	0d c0       	rjmp	.+26     	; 0xa06 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     9ec:	dc 01       	movw	r26, r24
     9ee:	13 96       	adiw	r26, 0x03	; 3
     9f0:	01 c0       	rjmp	.+2      	; 0x9f4 <vListInsert+0x22>
     9f2:	df 01       	movw	r26, r30
     9f4:	12 96       	adiw	r26, 0x02	; 2
     9f6:	ed 91       	ld	r30, X+
     9f8:	fc 91       	ld	r31, X
     9fa:	13 97       	sbiw	r26, 0x03	; 3
     9fc:	20 81       	ld	r18, Z
     9fe:	31 81       	ldd	r19, Z+1	; 0x01
     a00:	42 17       	cp	r20, r18
     a02:	53 07       	cpc	r21, r19
     a04:	b0 f7       	brcc	.-20     	; 0x9f2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     a06:	12 96       	adiw	r26, 0x02	; 2
     a08:	ed 91       	ld	r30, X+
     a0a:	fc 91       	ld	r31, X
     a0c:	13 97       	sbiw	r26, 0x03	; 3
     a0e:	fb 83       	std	Y+3, r31	; 0x03
     a10:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     a12:	d5 83       	std	Z+5, r29	; 0x05
     a14:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     a16:	bd 83       	std	Y+5, r27	; 0x05
     a18:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     a1a:	13 96       	adiw	r26, 0x03	; 3
     a1c:	dc 93       	st	X, r29
     a1e:	ce 93       	st	-X, r28
     a20:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     a22:	99 87       	std	Y+9, r25	; 0x09
     a24:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     a26:	fc 01       	movw	r30, r24
     a28:	20 81       	ld	r18, Z
     a2a:	2f 5f       	subi	r18, 0xFF	; 255
     a2c:	20 83       	st	Z, r18
}
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	08 95       	ret

00000a34 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     a34:	cf 93       	push	r28
     a36:	df 93       	push	r29
     a38:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     a3a:	a0 85       	ldd	r26, Z+8	; 0x08
     a3c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a3e:	c2 81       	ldd	r28, Z+2	; 0x02
     a40:	d3 81       	ldd	r29, Z+3	; 0x03
     a42:	84 81       	ldd	r24, Z+4	; 0x04
     a44:	95 81       	ldd	r25, Z+5	; 0x05
     a46:	9d 83       	std	Y+5, r25	; 0x05
     a48:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a4a:	c4 81       	ldd	r28, Z+4	; 0x04
     a4c:	d5 81       	ldd	r29, Z+5	; 0x05
     a4e:	82 81       	ldd	r24, Z+2	; 0x02
     a50:	93 81       	ldd	r25, Z+3	; 0x03
     a52:	9b 83       	std	Y+3, r25	; 0x03
     a54:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a56:	11 96       	adiw	r26, 0x01	; 1
     a58:	8d 91       	ld	r24, X+
     a5a:	9c 91       	ld	r25, X
     a5c:	12 97       	sbiw	r26, 0x02	; 2
     a5e:	e8 17       	cp	r30, r24
     a60:	f9 07       	cpc	r31, r25
     a62:	31 f4       	brne	.+12     	; 0xa70 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a64:	84 81       	ldd	r24, Z+4	; 0x04
     a66:	95 81       	ldd	r25, Z+5	; 0x05
     a68:	12 96       	adiw	r26, 0x02	; 2
     a6a:	9c 93       	st	X, r25
     a6c:	8e 93       	st	-X, r24
     a6e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     a70:	11 86       	std	Z+9, r1	; 0x09
     a72:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a74:	8c 91       	ld	r24, X
     a76:	81 50       	subi	r24, 0x01	; 1
     a78:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     a7a:	df 91       	pop	r29
     a7c:	cf 91       	pop	r28
     a7e:	08 95       	ret

00000a80 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     a80:	1b bc       	out	0x2b, r1	; 43
     a82:	89 ef       	ldi	r24, 0xF9	; 249
     a84:	8a bd       	out	0x2a, r24	; 42
     a86:	8b e0       	ldi	r24, 0x0B	; 11
     a88:	8e bd       	out	0x2e, r24	; 46
     a8a:	89 b7       	in	r24, 0x39	; 57
     a8c:	80 61       	ori	r24, 0x10	; 16
     a8e:	89 bf       	out	0x39, r24	; 57
     a90:	08 95       	ret

00000a92 <pxPortInitialiseStack>:
     a92:	31 e1       	ldi	r19, 0x11	; 17
     a94:	fc 01       	movw	r30, r24
     a96:	30 83       	st	Z, r19
     a98:	31 97       	sbiw	r30, 0x01	; 1
     a9a:	22 e2       	ldi	r18, 0x22	; 34
     a9c:	20 83       	st	Z, r18
     a9e:	31 97       	sbiw	r30, 0x01	; 1
     aa0:	a3 e3       	ldi	r26, 0x33	; 51
     aa2:	a0 83       	st	Z, r26
     aa4:	31 97       	sbiw	r30, 0x01	; 1
     aa6:	60 83       	st	Z, r22
     aa8:	31 97       	sbiw	r30, 0x01	; 1
     aaa:	70 83       	st	Z, r23
     aac:	31 97       	sbiw	r30, 0x01	; 1
     aae:	10 82       	st	Z, r1
     ab0:	31 97       	sbiw	r30, 0x01	; 1
     ab2:	60 e8       	ldi	r22, 0x80	; 128
     ab4:	60 83       	st	Z, r22
     ab6:	31 97       	sbiw	r30, 0x01	; 1
     ab8:	10 82       	st	Z, r1
     aba:	31 97       	sbiw	r30, 0x01	; 1
     abc:	62 e0       	ldi	r22, 0x02	; 2
     abe:	60 83       	st	Z, r22
     ac0:	31 97       	sbiw	r30, 0x01	; 1
     ac2:	63 e0       	ldi	r22, 0x03	; 3
     ac4:	60 83       	st	Z, r22
     ac6:	31 97       	sbiw	r30, 0x01	; 1
     ac8:	64 e0       	ldi	r22, 0x04	; 4
     aca:	60 83       	st	Z, r22
     acc:	31 97       	sbiw	r30, 0x01	; 1
     ace:	65 e0       	ldi	r22, 0x05	; 5
     ad0:	60 83       	st	Z, r22
     ad2:	31 97       	sbiw	r30, 0x01	; 1
     ad4:	66 e0       	ldi	r22, 0x06	; 6
     ad6:	60 83       	st	Z, r22
     ad8:	31 97       	sbiw	r30, 0x01	; 1
     ada:	67 e0       	ldi	r22, 0x07	; 7
     adc:	60 83       	st	Z, r22
     ade:	31 97       	sbiw	r30, 0x01	; 1
     ae0:	68 e0       	ldi	r22, 0x08	; 8
     ae2:	60 83       	st	Z, r22
     ae4:	31 97       	sbiw	r30, 0x01	; 1
     ae6:	69 e0       	ldi	r22, 0x09	; 9
     ae8:	60 83       	st	Z, r22
     aea:	31 97       	sbiw	r30, 0x01	; 1
     aec:	60 e1       	ldi	r22, 0x10	; 16
     aee:	60 83       	st	Z, r22
     af0:	31 97       	sbiw	r30, 0x01	; 1
     af2:	30 83       	st	Z, r19
     af4:	31 97       	sbiw	r30, 0x01	; 1
     af6:	32 e1       	ldi	r19, 0x12	; 18
     af8:	30 83       	st	Z, r19
     afa:	31 97       	sbiw	r30, 0x01	; 1
     afc:	33 e1       	ldi	r19, 0x13	; 19
     afe:	30 83       	st	Z, r19
     b00:	31 97       	sbiw	r30, 0x01	; 1
     b02:	34 e1       	ldi	r19, 0x14	; 20
     b04:	30 83       	st	Z, r19
     b06:	31 97       	sbiw	r30, 0x01	; 1
     b08:	35 e1       	ldi	r19, 0x15	; 21
     b0a:	30 83       	st	Z, r19
     b0c:	31 97       	sbiw	r30, 0x01	; 1
     b0e:	36 e1       	ldi	r19, 0x16	; 22
     b10:	30 83       	st	Z, r19
     b12:	31 97       	sbiw	r30, 0x01	; 1
     b14:	37 e1       	ldi	r19, 0x17	; 23
     b16:	30 83       	st	Z, r19
     b18:	31 97       	sbiw	r30, 0x01	; 1
     b1a:	38 e1       	ldi	r19, 0x18	; 24
     b1c:	30 83       	st	Z, r19
     b1e:	31 97       	sbiw	r30, 0x01	; 1
     b20:	39 e1       	ldi	r19, 0x19	; 25
     b22:	30 83       	st	Z, r19
     b24:	31 97       	sbiw	r30, 0x01	; 1
     b26:	30 e2       	ldi	r19, 0x20	; 32
     b28:	30 83       	st	Z, r19
     b2a:	31 97       	sbiw	r30, 0x01	; 1
     b2c:	31 e2       	ldi	r19, 0x21	; 33
     b2e:	30 83       	st	Z, r19
     b30:	31 97       	sbiw	r30, 0x01	; 1
     b32:	20 83       	st	Z, r18
     b34:	31 97       	sbiw	r30, 0x01	; 1
     b36:	23 e2       	ldi	r18, 0x23	; 35
     b38:	20 83       	st	Z, r18
     b3a:	31 97       	sbiw	r30, 0x01	; 1
     b3c:	40 83       	st	Z, r20
     b3e:	31 97       	sbiw	r30, 0x01	; 1
     b40:	50 83       	st	Z, r21
     b42:	31 97       	sbiw	r30, 0x01	; 1
     b44:	26 e2       	ldi	r18, 0x26	; 38
     b46:	20 83       	st	Z, r18
     b48:	31 97       	sbiw	r30, 0x01	; 1
     b4a:	27 e2       	ldi	r18, 0x27	; 39
     b4c:	20 83       	st	Z, r18
     b4e:	31 97       	sbiw	r30, 0x01	; 1
     b50:	28 e2       	ldi	r18, 0x28	; 40
     b52:	20 83       	st	Z, r18
     b54:	31 97       	sbiw	r30, 0x01	; 1
     b56:	29 e2       	ldi	r18, 0x29	; 41
     b58:	20 83       	st	Z, r18
     b5a:	31 97       	sbiw	r30, 0x01	; 1
     b5c:	20 e3       	ldi	r18, 0x30	; 48
     b5e:	20 83       	st	Z, r18
     b60:	31 97       	sbiw	r30, 0x01	; 1
     b62:	21 e3       	ldi	r18, 0x31	; 49
     b64:	20 83       	st	Z, r18
     b66:	86 97       	sbiw	r24, 0x26	; 38
     b68:	08 95       	ret

00000b6a <xPortStartScheduler>:
     b6a:	0e 94 40 05 	call	0xa80	; 0xa80 <prvSetupTimerInterrupt>
     b6e:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <pxCurrentTCB>
     b72:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     b76:	cd 91       	ld	r28, X+
     b78:	cd bf       	out	0x3d, r28	; 61
     b7a:	dd 91       	ld	r29, X+
     b7c:	de bf       	out	0x3e, r29	; 62
     b7e:	ff 91       	pop	r31
     b80:	ef 91       	pop	r30
     b82:	df 91       	pop	r29
     b84:	cf 91       	pop	r28
     b86:	bf 91       	pop	r27
     b88:	af 91       	pop	r26
     b8a:	9f 91       	pop	r25
     b8c:	8f 91       	pop	r24
     b8e:	7f 91       	pop	r23
     b90:	6f 91       	pop	r22
     b92:	5f 91       	pop	r21
     b94:	4f 91       	pop	r20
     b96:	3f 91       	pop	r19
     b98:	2f 91       	pop	r18
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	df 90       	pop	r13
     ba4:	cf 90       	pop	r12
     ba6:	bf 90       	pop	r11
     ba8:	af 90       	pop	r10
     baa:	9f 90       	pop	r9
     bac:	8f 90       	pop	r8
     bae:	7f 90       	pop	r7
     bb0:	6f 90       	pop	r6
     bb2:	5f 90       	pop	r5
     bb4:	4f 90       	pop	r4
     bb6:	3f 90       	pop	r3
     bb8:	2f 90       	pop	r2
     bba:	1f 90       	pop	r1
     bbc:	0f 90       	pop	r0
     bbe:	0f be       	out	0x3f, r0	; 63
     bc0:	0f 90       	pop	r0
     bc2:	08 95       	ret
     bc4:	81 e0       	ldi	r24, 0x01	; 1
     bc6:	08 95       	ret

00000bc8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     bc8:	0f 92       	push	r0
     bca:	0f b6       	in	r0, 0x3f	; 63
     bcc:	f8 94       	cli
     bce:	0f 92       	push	r0
     bd0:	1f 92       	push	r1
     bd2:	11 24       	eor	r1, r1
     bd4:	2f 92       	push	r2
     bd6:	3f 92       	push	r3
     bd8:	4f 92       	push	r4
     bda:	5f 92       	push	r5
     bdc:	6f 92       	push	r6
     bde:	7f 92       	push	r7
     be0:	8f 92       	push	r8
     be2:	9f 92       	push	r9
     be4:	af 92       	push	r10
     be6:	bf 92       	push	r11
     be8:	cf 92       	push	r12
     bea:	df 92       	push	r13
     bec:	ef 92       	push	r14
     bee:	ff 92       	push	r15
     bf0:	0f 93       	push	r16
     bf2:	1f 93       	push	r17
     bf4:	2f 93       	push	r18
     bf6:	3f 93       	push	r19
     bf8:	4f 93       	push	r20
     bfa:	5f 93       	push	r21
     bfc:	6f 93       	push	r22
     bfe:	7f 93       	push	r23
     c00:	8f 93       	push	r24
     c02:	9f 93       	push	r25
     c04:	af 93       	push	r26
     c06:	bf 93       	push	r27
     c08:	cf 93       	push	r28
     c0a:	df 93       	push	r29
     c0c:	ef 93       	push	r30
     c0e:	ff 93       	push	r31
     c10:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <pxCurrentTCB>
     c14:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     c18:	0d b6       	in	r0, 0x3d	; 61
     c1a:	0d 92       	st	X+, r0
     c1c:	0e b6       	in	r0, 0x3e	; 62
     c1e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     c20:	0e 94 fd 09 	call	0x13fa	; 0x13fa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     c24:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <pxCurrentTCB>
     c28:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     c2c:	cd 91       	ld	r28, X+
     c2e:	cd bf       	out	0x3d, r28	; 61
     c30:	dd 91       	ld	r29, X+
     c32:	de bf       	out	0x3e, r29	; 62
     c34:	ff 91       	pop	r31
     c36:	ef 91       	pop	r30
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	bf 91       	pop	r27
     c3e:	af 91       	pop	r26
     c40:	9f 91       	pop	r25
     c42:	8f 91       	pop	r24
     c44:	7f 91       	pop	r23
     c46:	6f 91       	pop	r22
     c48:	5f 91       	pop	r21
     c4a:	4f 91       	pop	r20
     c4c:	3f 91       	pop	r19
     c4e:	2f 91       	pop	r18
     c50:	1f 91       	pop	r17
     c52:	0f 91       	pop	r16
     c54:	ff 90       	pop	r15
     c56:	ef 90       	pop	r14
     c58:	df 90       	pop	r13
     c5a:	cf 90       	pop	r12
     c5c:	bf 90       	pop	r11
     c5e:	af 90       	pop	r10
     c60:	9f 90       	pop	r9
     c62:	8f 90       	pop	r8
     c64:	7f 90       	pop	r7
     c66:	6f 90       	pop	r6
     c68:	5f 90       	pop	r5
     c6a:	4f 90       	pop	r4
     c6c:	3f 90       	pop	r3
     c6e:	2f 90       	pop	r2
     c70:	1f 90       	pop	r1
     c72:	0f 90       	pop	r0
     c74:	0f be       	out	0x3f, r0	; 63
     c76:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c78:	08 95       	ret

00000c7a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     c7a:	0f 92       	push	r0
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	0f 92       	push	r0
     c82:	1f 92       	push	r1
     c84:	11 24       	eor	r1, r1
     c86:	2f 92       	push	r2
     c88:	3f 92       	push	r3
     c8a:	4f 92       	push	r4
     c8c:	5f 92       	push	r5
     c8e:	6f 92       	push	r6
     c90:	7f 92       	push	r7
     c92:	8f 92       	push	r8
     c94:	9f 92       	push	r9
     c96:	af 92       	push	r10
     c98:	bf 92       	push	r11
     c9a:	cf 92       	push	r12
     c9c:	df 92       	push	r13
     c9e:	ef 92       	push	r14
     ca0:	ff 92       	push	r15
     ca2:	0f 93       	push	r16
     ca4:	1f 93       	push	r17
     ca6:	2f 93       	push	r18
     ca8:	3f 93       	push	r19
     caa:	4f 93       	push	r20
     cac:	5f 93       	push	r21
     cae:	6f 93       	push	r22
     cb0:	7f 93       	push	r23
     cb2:	8f 93       	push	r24
     cb4:	9f 93       	push	r25
     cb6:	af 93       	push	r26
     cb8:	bf 93       	push	r27
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	ef 93       	push	r30
     cc0:	ff 93       	push	r31
     cc2:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <pxCurrentTCB>
     cc6:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     cca:	0d b6       	in	r0, 0x3d	; 61
     ccc:	0d 92       	st	X+, r0
     cce:	0e b6       	in	r0, 0x3e	; 62
     cd0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     cd2:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskIncrementTick>
     cd6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     cd8:	0e 94 fd 09 	call	0x13fa	; 0x13fa <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     cdc:	a0 91 fb 04 	lds	r26, 0x04FB	; 0x8004fb <pxCurrentTCB>
     ce0:	b0 91 fc 04 	lds	r27, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     ce4:	cd 91       	ld	r28, X+
     ce6:	cd bf       	out	0x3d, r28	; 61
     ce8:	dd 91       	ld	r29, X+
     cea:	de bf       	out	0x3e, r29	; 62
     cec:	ff 91       	pop	r31
     cee:	ef 91       	pop	r30
     cf0:	df 91       	pop	r29
     cf2:	cf 91       	pop	r28
     cf4:	bf 91       	pop	r27
     cf6:	af 91       	pop	r26
     cf8:	9f 91       	pop	r25
     cfa:	8f 91       	pop	r24
     cfc:	7f 91       	pop	r23
     cfe:	6f 91       	pop	r22
     d00:	5f 91       	pop	r21
     d02:	4f 91       	pop	r20
     d04:	3f 91       	pop	r19
     d06:	2f 91       	pop	r18
     d08:	1f 91       	pop	r17
     d0a:	0f 91       	pop	r16
     d0c:	ff 90       	pop	r15
     d0e:	ef 90       	pop	r14
     d10:	df 90       	pop	r13
     d12:	cf 90       	pop	r12
     d14:	bf 90       	pop	r11
     d16:	af 90       	pop	r10
     d18:	9f 90       	pop	r9
     d1a:	8f 90       	pop	r8
     d1c:	7f 90       	pop	r7
     d1e:	6f 90       	pop	r6
     d20:	5f 90       	pop	r5
     d22:	4f 90       	pop	r4
     d24:	3f 90       	pop	r3
     d26:	2f 90       	pop	r2
     d28:	1f 90       	pop	r1
     d2a:	0f 90       	pop	r0
     d2c:	0f be       	out	0x3f, r0	; 63
     d2e:	0f 90       	pop	r0

	asm volatile ( "ret" );
     d30:	08 95       	ret

00000d32 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     d32:	0e 94 3d 06 	call	0xc7a	; 0xc7a <vPortYieldFromTick>
		asm volatile ( "reti" );
     d36:	18 95       	reti

00000d38 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d38:	e0 91 96 04 	lds	r30, 0x0496	; 0x800496 <pxDelayedTaskList>
     d3c:	f0 91 97 04 	lds	r31, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
     d40:	80 81       	ld	r24, Z
     d42:	81 11       	cpse	r24, r1
     d44:	07 c0       	rjmp	.+14     	; 0xd54 <prvResetNextTaskUnblockTime+0x1c>
     d46:	8f ef       	ldi	r24, 0xFF	; 255
     d48:	9f ef       	ldi	r25, 0xFF	; 255
     d4a:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <xNextTaskUnblockTime+0x1>
     d4e:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xNextTaskUnblockTime>
     d52:	08 95       	ret
     d54:	e0 91 96 04 	lds	r30, 0x0496	; 0x800496 <pxDelayedTaskList>
     d58:	f0 91 97 04 	lds	r31, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
     d5c:	05 80       	ldd	r0, Z+5	; 0x05
     d5e:	f6 81       	ldd	r31, Z+6	; 0x06
     d60:	e0 2d       	mov	r30, r0
     d62:	06 80       	ldd	r0, Z+6	; 0x06
     d64:	f7 81       	ldd	r31, Z+7	; 0x07
     d66:	e0 2d       	mov	r30, r0
     d68:	82 81       	ldd	r24, Z+2	; 0x02
     d6a:	93 81       	ldd	r25, Z+3	; 0x03
     d6c:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <xNextTaskUnblockTime+0x1>
     d70:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xNextTaskUnblockTime>
     d74:	08 95       	ret

00000d76 <prvDeleteTCB>:
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	ec 01       	movw	r28, r24
     d7c:	8f 89       	ldd	r24, Y+23	; 0x17
     d7e:	98 8d       	ldd	r25, Y+24	; 0x18
     d80:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
     d84:	ce 01       	movw	r24, r28
     d86:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	08 95       	ret

00000d90 <prvInitialiseNewTask>:
     d90:	6f 92       	push	r6
     d92:	7f 92       	push	r7
     d94:	8f 92       	push	r8
     d96:	9f 92       	push	r9
     d98:	af 92       	push	r10
     d9a:	bf 92       	push	r11
     d9c:	cf 92       	push	r12
     d9e:	df 92       	push	r13
     da0:	ef 92       	push	r14
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
     daa:	cd b7       	in	r28, 0x3d	; 61
     dac:	de b7       	in	r29, 0x3e	; 62
     dae:	4c 01       	movw	r8, r24
     db0:	f5 01       	movw	r30, r10
     db2:	87 89       	ldd	r24, Z+23	; 0x17
     db4:	90 8d       	ldd	r25, Z+24	; 0x18
     db6:	21 50       	subi	r18, 0x01	; 1
     db8:	31 09       	sbc	r19, r1
     dba:	3c 01       	movw	r6, r24
     dbc:	62 0e       	add	r6, r18
     dbe:	73 1e       	adc	r7, r19
     dc0:	20 e0       	ldi	r18, 0x00	; 0
     dc2:	0f c0       	rjmp	.+30     	; 0xde2 <prvInitialiseNewTask+0x52>
     dc4:	82 2f       	mov	r24, r18
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	fb 01       	movw	r30, r22
     dca:	e8 0f       	add	r30, r24
     dcc:	f9 1f       	adc	r31, r25
     dce:	30 81       	ld	r19, Z
     dd0:	d5 01       	movw	r26, r10
     dd2:	a8 0f       	add	r26, r24
     dd4:	b9 1f       	adc	r27, r25
     dd6:	59 96       	adiw	r26, 0x19	; 25
     dd8:	3c 93       	st	X, r19
     dda:	80 81       	ld	r24, Z
     ddc:	88 23       	and	r24, r24
     dde:	19 f0       	breq	.+6      	; 0xde6 <prvInitialiseNewTask+0x56>
     de0:	2f 5f       	subi	r18, 0xFF	; 255
     de2:	28 30       	cpi	r18, 0x08	; 8
     de4:	78 f3       	brcs	.-34     	; 0xdc4 <prvInitialiseNewTask+0x34>
     de6:	f5 01       	movw	r30, r10
     de8:	10 a2       	std	Z+32, r1	; 0x20
     dea:	f8 e0       	ldi	r31, 0x08	; 8
     dec:	fe 15       	cp	r31, r14
     dee:	18 f4       	brcc	.+6      	; 0xdf6 <prvInitialiseNewTask+0x66>
     df0:	68 94       	set
     df2:	ee 24       	eor	r14, r14
     df4:	e3 f8       	bld	r14, 3
     df6:	f5 01       	movw	r30, r10
     df8:	e6 8a       	std	Z+22, r14	; 0x16
     dfa:	e1 a2       	std	Z+33, r14	; 0x21
     dfc:	12 a2       	std	Z+34, r1	; 0x22
     dfe:	c5 01       	movw	r24, r10
     e00:	02 96       	adiw	r24, 0x02	; 2
     e02:	0e 94 c4 04 	call	0x988	; 0x988 <vListInitialiseItem>
     e06:	c5 01       	movw	r24, r10
     e08:	0c 96       	adiw	r24, 0x0c	; 12
     e0a:	0e 94 c4 04 	call	0x988	; 0x988 <vListInitialiseItem>
     e0e:	f5 01       	movw	r30, r10
     e10:	b1 86       	std	Z+9, r11	; 0x09
     e12:	a0 86       	std	Z+8, r10	; 0x08
     e14:	89 e0       	ldi	r24, 0x09	; 9
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	8e 19       	sub	r24, r14
     e1a:	91 09       	sbc	r25, r1
     e1c:	95 87       	std	Z+13, r25	; 0x0d
     e1e:	84 87       	std	Z+12, r24	; 0x0c
     e20:	b3 8a       	std	Z+19, r11	; 0x13
     e22:	a2 8a       	std	Z+18, r10	; 0x12
     e24:	13 a2       	std	Z+35, r1	; 0x23
     e26:	14 a2       	std	Z+36, r1	; 0x24
     e28:	15 a2       	std	Z+37, r1	; 0x25
     e2a:	16 a2       	std	Z+38, r1	; 0x26
     e2c:	17 a2       	std	Z+39, r1	; 0x27
     e2e:	a8 01       	movw	r20, r16
     e30:	b4 01       	movw	r22, r8
     e32:	c3 01       	movw	r24, r6
     e34:	0e 94 49 05 	call	0xa92	; 0xa92 <pxPortInitialiseStack>
     e38:	f5 01       	movw	r30, r10
     e3a:	91 83       	std	Z+1, r25	; 0x01
     e3c:	80 83       	st	Z, r24
     e3e:	c1 14       	cp	r12, r1
     e40:	d1 04       	cpc	r13, r1
     e42:	19 f0       	breq	.+6      	; 0xe4a <prvInitialiseNewTask+0xba>
     e44:	f6 01       	movw	r30, r12
     e46:	b1 82       	std	Z+1, r11	; 0x01
     e48:	a0 82       	st	Z, r10
     e4a:	df 91       	pop	r29
     e4c:	cf 91       	pop	r28
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	ef 90       	pop	r14
     e54:	df 90       	pop	r13
     e56:	cf 90       	pop	r12
     e58:	bf 90       	pop	r11
     e5a:	af 90       	pop	r10
     e5c:	9f 90       	pop	r9
     e5e:	8f 90       	pop	r8
     e60:	7f 90       	pop	r7
     e62:	6f 90       	pop	r6
     e64:	08 95       	ret

00000e66 <prvInitialiseTaskLists>:
     e66:	cf 93       	push	r28
     e68:	c0 e0       	ldi	r28, 0x00	; 0
     e6a:	10 c0       	rjmp	.+32     	; 0xe8c <prvInitialiseTaskLists+0x26>
     e6c:	8c 2f       	mov	r24, r28
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	9c 01       	movw	r18, r24
     e72:	22 0f       	add	r18, r18
     e74:	33 1f       	adc	r19, r19
     e76:	22 0f       	add	r18, r18
     e78:	33 1f       	adc	r19, r19
     e7a:	22 0f       	add	r18, r18
     e7c:	33 1f       	adc	r19, r19
     e7e:	82 0f       	add	r24, r18
     e80:	93 1f       	adc	r25, r19
     e82:	86 55       	subi	r24, 0x56	; 86
     e84:	9b 4f       	sbci	r25, 0xFB	; 251
     e86:	0e 94 b6 04 	call	0x96c	; 0x96c <vListInitialise>
     e8a:	cf 5f       	subi	r28, 0xFF	; 255
     e8c:	c9 30       	cpi	r28, 0x09	; 9
     e8e:	70 f3       	brcs	.-36     	; 0xe6c <prvInitialiseTaskLists+0x6>
     e90:	81 ea       	ldi	r24, 0xA1	; 161
     e92:	94 e0       	ldi	r25, 0x04	; 4
     e94:	0e 94 b6 04 	call	0x96c	; 0x96c <vListInitialise>
     e98:	88 e9       	ldi	r24, 0x98	; 152
     e9a:	94 e0       	ldi	r25, 0x04	; 4
     e9c:	0e 94 b6 04 	call	0x96c	; 0x96c <vListInitialise>
     ea0:	8b e8       	ldi	r24, 0x8B	; 139
     ea2:	94 e0       	ldi	r25, 0x04	; 4
     ea4:	0e 94 b6 04 	call	0x96c	; 0x96c <vListInitialise>
     ea8:	82 e8       	ldi	r24, 0x82	; 130
     eaa:	94 e0       	ldi	r25, 0x04	; 4
     eac:	0e 94 b6 04 	call	0x96c	; 0x96c <vListInitialise>
     eb0:	81 ea       	ldi	r24, 0xA1	; 161
     eb2:	94 e0       	ldi	r25, 0x04	; 4
     eb4:	90 93 97 04 	sts	0x0497, r25	; 0x800497 <pxDelayedTaskList+0x1>
     eb8:	80 93 96 04 	sts	0x0496, r24	; 0x800496 <pxDelayedTaskList>
     ebc:	88 e9       	ldi	r24, 0x98	; 152
     ebe:	94 e0       	ldi	r25, 0x04	; 4
     ec0:	90 93 95 04 	sts	0x0495, r25	; 0x800495 <pxOverflowDelayedTaskList+0x1>
     ec4:	80 93 94 04 	sts	0x0494, r24	; 0x800494 <pxOverflowDelayedTaskList>
     ec8:	cf 91       	pop	r28
     eca:	08 95       	ret

00000ecc <prvAddNewTaskToReadyList>:
     ecc:	cf 93       	push	r28
     ece:	df 93       	push	r29
     ed0:	ec 01       	movw	r28, r24
     ed2:	0f b6       	in	r0, 0x3f	; 63
     ed4:	f8 94       	cli
     ed6:	0f 92       	push	r0
     ed8:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <uxCurrentNumberOfTasks>
     edc:	8f 5f       	subi	r24, 0xFF	; 255
     ede:	80 93 80 04 	sts	0x0480, r24	; 0x800480 <uxCurrentNumberOfTasks>
     ee2:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <pxCurrentTCB>
     ee6:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     eea:	89 2b       	or	r24, r25
     eec:	59 f4       	brne	.+22     	; 0xf04 <prvAddNewTaskToReadyList+0x38>
     eee:	d0 93 fc 04 	sts	0x04FC, r29	; 0x8004fc <pxCurrentTCB+0x1>
     ef2:	c0 93 fb 04 	sts	0x04FB, r28	; 0x8004fb <pxCurrentTCB>
     ef6:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <uxCurrentNumberOfTasks>
     efa:	81 30       	cpi	r24, 0x01	; 1
     efc:	99 f4       	brne	.+38     	; 0xf24 <prvAddNewTaskToReadyList+0x58>
     efe:	0e 94 33 07 	call	0xe66	; 0xe66 <prvInitialiseTaskLists>
     f02:	10 c0       	rjmp	.+32     	; 0xf24 <prvAddNewTaskToReadyList+0x58>
     f04:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <xSchedulerRunning>
     f08:	81 11       	cpse	r24, r1
     f0a:	0c c0       	rjmp	.+24     	; 0xf24 <prvAddNewTaskToReadyList+0x58>
     f0c:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
     f10:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     f14:	96 89       	ldd	r25, Z+22	; 0x16
     f16:	8e 89       	ldd	r24, Y+22	; 0x16
     f18:	89 17       	cp	r24, r25
     f1a:	20 f0       	brcs	.+8      	; 0xf24 <prvAddNewTaskToReadyList+0x58>
     f1c:	d0 93 fc 04 	sts	0x04FC, r29	; 0x8004fc <pxCurrentTCB+0x1>
     f20:	c0 93 fb 04 	sts	0x04FB, r28	; 0x8004fb <pxCurrentTCB>
     f24:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <uxTaskNumber>
     f28:	8f 5f       	subi	r24, 0xFF	; 255
     f2a:	80 93 78 04 	sts	0x0478, r24	; 0x800478 <uxTaskNumber>
     f2e:	8e 89       	ldd	r24, Y+22	; 0x16
     f30:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <uxTopReadyPriority>
     f34:	98 17       	cp	r25, r24
     f36:	10 f4       	brcc	.+4      	; 0xf3c <prvAddNewTaskToReadyList+0x70>
     f38:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <uxTopReadyPriority>
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	9c 01       	movw	r18, r24
     f40:	22 0f       	add	r18, r18
     f42:	33 1f       	adc	r19, r19
     f44:	22 0f       	add	r18, r18
     f46:	33 1f       	adc	r19, r19
     f48:	22 0f       	add	r18, r18
     f4a:	33 1f       	adc	r19, r19
     f4c:	82 0f       	add	r24, r18
     f4e:	93 1f       	adc	r25, r19
     f50:	be 01       	movw	r22, r28
     f52:	6e 5f       	subi	r22, 0xFE	; 254
     f54:	7f 4f       	sbci	r23, 0xFF	; 255
     f56:	86 55       	subi	r24, 0x56	; 86
     f58:	9b 4f       	sbci	r25, 0xFB	; 251
     f5a:	0e 94 c8 04 	call	0x990	; 0x990 <vListInsertEnd>
     f5e:	0f 90       	pop	r0
     f60:	0f be       	out	0x3f, r0	; 63
     f62:	80 91 7c 04 	lds	r24, 0x047C	; 0x80047c <xSchedulerRunning>
     f66:	88 23       	and	r24, r24
     f68:	51 f0       	breq	.+20     	; 0xf7e <prvAddNewTaskToReadyList+0xb2>
     f6a:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
     f6e:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     f72:	96 89       	ldd	r25, Z+22	; 0x16
     f74:	8e 89       	ldd	r24, Y+22	; 0x16
     f76:	98 17       	cp	r25, r24
     f78:	10 f4       	brcc	.+4      	; 0xf7e <prvAddNewTaskToReadyList+0xb2>
     f7a:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <vPortYield>
     f7e:	df 91       	pop	r29
     f80:	cf 91       	pop	r28
     f82:	08 95       	ret

00000f84 <prvAddCurrentTaskToDelayedList>:
     f84:	0f 93       	push	r16
     f86:	1f 93       	push	r17
     f88:	cf 93       	push	r28
     f8a:	df 93       	push	r29
     f8c:	ec 01       	movw	r28, r24
     f8e:	00 91 7e 04 	lds	r16, 0x047E	; 0x80047e <xTickCount>
     f92:	10 91 7f 04 	lds	r17, 0x047F	; 0x80047f <xTickCount+0x1>
     f96:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <pxCurrentTCB>
     f9a:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     f9e:	02 96       	adiw	r24, 0x02	; 2
     fa0:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
     fa4:	c0 0f       	add	r28, r16
     fa6:	d1 1f       	adc	r29, r17
     fa8:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
     fac:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     fb0:	d3 83       	std	Z+3, r29	; 0x03
     fb2:	c2 83       	std	Z+2, r28	; 0x02
     fb4:	c0 17       	cp	r28, r16
     fb6:	d1 07       	cpc	r29, r17
     fb8:	68 f4       	brcc	.+26     	; 0xfd4 <prvAddCurrentTaskToDelayedList+0x50>
     fba:	60 91 fb 04 	lds	r22, 0x04FB	; 0x8004fb <pxCurrentTCB>
     fbe:	70 91 fc 04 	lds	r23, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     fc2:	80 91 94 04 	lds	r24, 0x0494	; 0x800494 <pxOverflowDelayedTaskList>
     fc6:	90 91 95 04 	lds	r25, 0x0495	; 0x800495 <pxOverflowDelayedTaskList+0x1>
     fca:	6e 5f       	subi	r22, 0xFE	; 254
     fcc:	7f 4f       	sbci	r23, 0xFF	; 255
     fce:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <vListInsert>
     fd2:	17 c0       	rjmp	.+46     	; 0x1002 <prvAddCurrentTaskToDelayedList+0x7e>
     fd4:	60 91 fb 04 	lds	r22, 0x04FB	; 0x8004fb <pxCurrentTCB>
     fd8:	70 91 fc 04 	lds	r23, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
     fdc:	80 91 96 04 	lds	r24, 0x0496	; 0x800496 <pxDelayedTaskList>
     fe0:	90 91 97 04 	lds	r25, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
     fe4:	6e 5f       	subi	r22, 0xFE	; 254
     fe6:	7f 4f       	sbci	r23, 0xFF	; 255
     fe8:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <vListInsert>
     fec:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xNextTaskUnblockTime>
     ff0:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <xNextTaskUnblockTime+0x1>
     ff4:	c8 17       	cp	r28, r24
     ff6:	d9 07       	cpc	r29, r25
     ff8:	20 f4       	brcc	.+8      	; 0x1002 <prvAddCurrentTaskToDelayedList+0x7e>
     ffa:	d0 93 77 04 	sts	0x0477, r29	; 0x800477 <xNextTaskUnblockTime+0x1>
     ffe:	c0 93 76 04 	sts	0x0476, r28	; 0x800476 <xNextTaskUnblockTime>
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	08 95       	ret

0000100c <xTaskCreate>:
    100c:	2f 92       	push	r2
    100e:	3f 92       	push	r3
    1010:	4f 92       	push	r4
    1012:	5f 92       	push	r5
    1014:	6f 92       	push	r6
    1016:	7f 92       	push	r7
    1018:	8f 92       	push	r8
    101a:	9f 92       	push	r9
    101c:	af 92       	push	r10
    101e:	bf 92       	push	r11
    1020:	cf 92       	push	r12
    1022:	df 92       	push	r13
    1024:	ef 92       	push	r14
    1026:	ff 92       	push	r15
    1028:	0f 93       	push	r16
    102a:	1f 93       	push	r17
    102c:	cf 93       	push	r28
    102e:	df 93       	push	r29
    1030:	3c 01       	movw	r6, r24
    1032:	1b 01       	movw	r2, r22
    1034:	5a 01       	movw	r10, r20
    1036:	29 01       	movw	r4, r18
    1038:	ca 01       	movw	r24, r20
    103a:	0e 94 07 04 	call	0x80e	; 0x80e <pvPortMalloc>
    103e:	6c 01       	movw	r12, r24
    1040:	89 2b       	or	r24, r25
    1042:	71 f0       	breq	.+28     	; 0x1060 <xTaskCreate+0x54>
    1044:	88 e2       	ldi	r24, 0x28	; 40
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	0e 94 07 04 	call	0x80e	; 0x80e <pvPortMalloc>
    104c:	ec 01       	movw	r28, r24
    104e:	89 2b       	or	r24, r25
    1050:	19 f0       	breq	.+6      	; 0x1058 <xTaskCreate+0x4c>
    1052:	d8 8e       	std	Y+24, r13	; 0x18
    1054:	cf 8a       	std	Y+23, r12	; 0x17
    1056:	06 c0       	rjmp	.+12     	; 0x1064 <xTaskCreate+0x58>
    1058:	c6 01       	movw	r24, r12
    105a:	0e 94 83 04 	call	0x906	; 0x906 <vPortFree>
    105e:	02 c0       	rjmp	.+4      	; 0x1064 <xTaskCreate+0x58>
    1060:	c0 e0       	ldi	r28, 0x00	; 0
    1062:	d0 e0       	ldi	r29, 0x00	; 0
    1064:	20 97       	sbiw	r28, 0x00	; 0
    1066:	91 f0       	breq	.+36     	; 0x108c <xTaskCreate+0x80>
    1068:	95 01       	movw	r18, r10
    106a:	40 e0       	ldi	r20, 0x00	; 0
    106c:	50 e0       	ldi	r21, 0x00	; 0
    106e:	81 2c       	mov	r8, r1
    1070:	91 2c       	mov	r9, r1
    1072:	5e 01       	movw	r10, r28
    1074:	67 01       	movw	r12, r14
    1076:	e0 2e       	mov	r14, r16
    1078:	82 01       	movw	r16, r4
    107a:	b1 01       	movw	r22, r2
    107c:	c3 01       	movw	r24, r6
    107e:	0e 94 c8 06 	call	0xd90	; 0xd90 <prvInitialiseNewTask>
    1082:	ce 01       	movw	r24, r28
    1084:	0e 94 66 07 	call	0xecc	; 0xecc <prvAddNewTaskToReadyList>
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	01 c0       	rjmp	.+2      	; 0x108e <xTaskCreate+0x82>
    108c:	8f ef       	ldi	r24, 0xFF	; 255
    108e:	df 91       	pop	r29
    1090:	cf 91       	pop	r28
    1092:	1f 91       	pop	r17
    1094:	0f 91       	pop	r16
    1096:	ff 90       	pop	r15
    1098:	ef 90       	pop	r14
    109a:	df 90       	pop	r13
    109c:	cf 90       	pop	r12
    109e:	bf 90       	pop	r11
    10a0:	af 90       	pop	r10
    10a2:	9f 90       	pop	r9
    10a4:	8f 90       	pop	r8
    10a6:	7f 90       	pop	r7
    10a8:	6f 90       	pop	r6
    10aa:	5f 90       	pop	r5
    10ac:	4f 90       	pop	r4
    10ae:	3f 90       	pop	r3
    10b0:	2f 90       	pop	r2
    10b2:	08 95       	ret

000010b4 <vTaskStartScheduler>:
    10b4:	ef 92       	push	r14
    10b6:	ff 92       	push	r15
    10b8:	0f 93       	push	r16
    10ba:	0f 2e       	mov	r0, r31
    10bc:	f4 e7       	ldi	r31, 0x74	; 116
    10be:	ef 2e       	mov	r14, r31
    10c0:	f4 e0       	ldi	r31, 0x04	; 4
    10c2:	ff 2e       	mov	r15, r31
    10c4:	f0 2d       	mov	r31, r0
    10c6:	00 e0       	ldi	r16, 0x00	; 0
    10c8:	20 e0       	ldi	r18, 0x00	; 0
    10ca:	30 e0       	ldi	r19, 0x00	; 0
    10cc:	40 e5       	ldi	r20, 0x50	; 80
    10ce:	50 e0       	ldi	r21, 0x00	; 0
    10d0:	67 e7       	ldi	r22, 0x77	; 119
    10d2:	70 e0       	ldi	r23, 0x00	; 0
    10d4:	8a ef       	ldi	r24, 0xFA	; 250
    10d6:	99 e0       	ldi	r25, 0x09	; 9
    10d8:	0e 94 06 08 	call	0x100c	; 0x100c <xTaskCreate>
    10dc:	81 30       	cpi	r24, 0x01	; 1
    10de:	81 f4       	brne	.+32     	; 0x1100 <vTaskStartScheduler+0x4c>
    10e0:	f8 94       	cli
    10e2:	8f ef       	ldi	r24, 0xFF	; 255
    10e4:	9f ef       	ldi	r25, 0xFF	; 255
    10e6:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <xNextTaskUnblockTime+0x1>
    10ea:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xNextTaskUnblockTime>
    10ee:	81 e0       	ldi	r24, 0x01	; 1
    10f0:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <xSchedulerRunning>
    10f4:	10 92 7f 04 	sts	0x047F, r1	; 0x80047f <xTickCount+0x1>
    10f8:	10 92 7e 04 	sts	0x047E, r1	; 0x80047e <xTickCount>
    10fc:	0e 94 b5 05 	call	0xb6a	; 0xb6a <xPortStartScheduler>
    1100:	0f 91       	pop	r16
    1102:	ff 90       	pop	r15
    1104:	ef 90       	pop	r14
    1106:	08 95       	ret

00001108 <vTaskSuspendAll>:
    1108:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <uxSchedulerSuspended>
    110c:	8f 5f       	subi	r24, 0xFF	; 255
    110e:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <uxSchedulerSuspended>
    1112:	08 95       	ret

00001114 <xTaskIncrementTick>:
    1114:	df 92       	push	r13
    1116:	ef 92       	push	r14
    1118:	ff 92       	push	r15
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <uxSchedulerSuspended>
    1126:	81 11       	cpse	r24, r1
    1128:	97 c0       	rjmp	.+302    	; 0x1258 <xTaskIncrementTick+0x144>
    112a:	e0 90 7e 04 	lds	r14, 0x047E	; 0x80047e <xTickCount>
    112e:	f0 90 7f 04 	lds	r15, 0x047F	; 0x80047f <xTickCount+0x1>
    1132:	8f ef       	ldi	r24, 0xFF	; 255
    1134:	e8 1a       	sub	r14, r24
    1136:	f8 0a       	sbc	r15, r24
    1138:	f0 92 7f 04 	sts	0x047F, r15	; 0x80047f <xTickCount+0x1>
    113c:	e0 92 7e 04 	sts	0x047E, r14	; 0x80047e <xTickCount>
    1140:	e1 14       	cp	r14, r1
    1142:	f1 04       	cpc	r15, r1
    1144:	b9 f4       	brne	.+46     	; 0x1174 <xTaskIncrementTick+0x60>
    1146:	80 91 96 04 	lds	r24, 0x0496	; 0x800496 <pxDelayedTaskList>
    114a:	90 91 97 04 	lds	r25, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
    114e:	20 91 94 04 	lds	r18, 0x0494	; 0x800494 <pxOverflowDelayedTaskList>
    1152:	30 91 95 04 	lds	r19, 0x0495	; 0x800495 <pxOverflowDelayedTaskList+0x1>
    1156:	30 93 97 04 	sts	0x0497, r19	; 0x800497 <pxDelayedTaskList+0x1>
    115a:	20 93 96 04 	sts	0x0496, r18	; 0x800496 <pxDelayedTaskList>
    115e:	90 93 95 04 	sts	0x0495, r25	; 0x800495 <pxOverflowDelayedTaskList+0x1>
    1162:	80 93 94 04 	sts	0x0494, r24	; 0x800494 <pxOverflowDelayedTaskList>
    1166:	80 91 79 04 	lds	r24, 0x0479	; 0x800479 <xNumOfOverflows>
    116a:	8f 5f       	subi	r24, 0xFF	; 255
    116c:	80 93 79 04 	sts	0x0479, r24	; 0x800479 <xNumOfOverflows>
    1170:	0e 94 9c 06 	call	0xd38	; 0xd38 <prvResetNextTaskUnblockTime>
    1174:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <xNextTaskUnblockTime>
    1178:	90 91 77 04 	lds	r25, 0x0477	; 0x800477 <xNextTaskUnblockTime+0x1>
    117c:	e8 16       	cp	r14, r24
    117e:	f9 06       	cpc	r15, r25
    1180:	28 f4       	brcc	.+10     	; 0x118c <xTaskIncrementTick+0x78>
    1182:	d1 2c       	mov	r13, r1
    1184:	53 c0       	rjmp	.+166    	; 0x122c <xTaskIncrementTick+0x118>
    1186:	dd 24       	eor	r13, r13
    1188:	d3 94       	inc	r13
    118a:	01 c0       	rjmp	.+2      	; 0x118e <xTaskIncrementTick+0x7a>
    118c:	d1 2c       	mov	r13, r1
    118e:	e0 91 96 04 	lds	r30, 0x0496	; 0x800496 <pxDelayedTaskList>
    1192:	f0 91 97 04 	lds	r31, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
    1196:	80 81       	ld	r24, Z
    1198:	81 11       	cpse	r24, r1
    119a:	07 c0       	rjmp	.+14     	; 0x11aa <xTaskIncrementTick+0x96>
    119c:	8f ef       	ldi	r24, 0xFF	; 255
    119e:	9f ef       	ldi	r25, 0xFF	; 255
    11a0:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <xNextTaskUnblockTime+0x1>
    11a4:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xNextTaskUnblockTime>
    11a8:	41 c0       	rjmp	.+130    	; 0x122c <xTaskIncrementTick+0x118>
    11aa:	e0 91 96 04 	lds	r30, 0x0496	; 0x800496 <pxDelayedTaskList>
    11ae:	f0 91 97 04 	lds	r31, 0x0497	; 0x800497 <pxDelayedTaskList+0x1>
    11b2:	05 80       	ldd	r0, Z+5	; 0x05
    11b4:	f6 81       	ldd	r31, Z+6	; 0x06
    11b6:	e0 2d       	mov	r30, r0
    11b8:	c6 81       	ldd	r28, Z+6	; 0x06
    11ba:	d7 81       	ldd	r29, Z+7	; 0x07
    11bc:	8a 81       	ldd	r24, Y+2	; 0x02
    11be:	9b 81       	ldd	r25, Y+3	; 0x03
    11c0:	e8 16       	cp	r14, r24
    11c2:	f9 06       	cpc	r15, r25
    11c4:	28 f4       	brcc	.+10     	; 0x11d0 <xTaskIncrementTick+0xbc>
    11c6:	90 93 77 04 	sts	0x0477, r25	; 0x800477 <xNextTaskUnblockTime+0x1>
    11ca:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <xNextTaskUnblockTime>
    11ce:	2e c0       	rjmp	.+92     	; 0x122c <xTaskIncrementTick+0x118>
    11d0:	8e 01       	movw	r16, r28
    11d2:	0e 5f       	subi	r16, 0xFE	; 254
    11d4:	1f 4f       	sbci	r17, 0xFF	; 255
    11d6:	c8 01       	movw	r24, r16
    11d8:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
    11dc:	8c 89       	ldd	r24, Y+20	; 0x14
    11de:	9d 89       	ldd	r25, Y+21	; 0x15
    11e0:	89 2b       	or	r24, r25
    11e2:	21 f0       	breq	.+8      	; 0x11ec <xTaskIncrementTick+0xd8>
    11e4:	ce 01       	movw	r24, r28
    11e6:	0c 96       	adiw	r24, 0x0c	; 12
    11e8:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
    11ec:	8e 89       	ldd	r24, Y+22	; 0x16
    11ee:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <uxTopReadyPriority>
    11f2:	98 17       	cp	r25, r24
    11f4:	10 f4       	brcc	.+4      	; 0x11fa <xTaskIncrementTick+0xe6>
    11f6:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <uxTopReadyPriority>
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	9c 01       	movw	r18, r24
    11fe:	22 0f       	add	r18, r18
    1200:	33 1f       	adc	r19, r19
    1202:	22 0f       	add	r18, r18
    1204:	33 1f       	adc	r19, r19
    1206:	22 0f       	add	r18, r18
    1208:	33 1f       	adc	r19, r19
    120a:	82 0f       	add	r24, r18
    120c:	93 1f       	adc	r25, r19
    120e:	b8 01       	movw	r22, r16
    1210:	86 55       	subi	r24, 0x56	; 86
    1212:	9b 4f       	sbci	r25, 0xFB	; 251
    1214:	0e 94 c8 04 	call	0x990	; 0x990 <vListInsertEnd>
    1218:	9e 89       	ldd	r25, Y+22	; 0x16
    121a:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
    121e:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
    1222:	86 89       	ldd	r24, Z+22	; 0x16
    1224:	98 17       	cp	r25, r24
    1226:	08 f0       	brcs	.+2      	; 0x122a <xTaskIncrementTick+0x116>
    1228:	ae cf       	rjmp	.-164    	; 0x1186 <xTaskIncrementTick+0x72>
    122a:	b1 cf       	rjmp	.-158    	; 0x118e <xTaskIncrementTick+0x7a>
    122c:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
    1230:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
    1234:	86 89       	ldd	r24, Z+22	; 0x16
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	fc 01       	movw	r30, r24
    123a:	ee 0f       	add	r30, r30
    123c:	ff 1f       	adc	r31, r31
    123e:	ee 0f       	add	r30, r30
    1240:	ff 1f       	adc	r31, r31
    1242:	ee 0f       	add	r30, r30
    1244:	ff 1f       	adc	r31, r31
    1246:	8e 0f       	add	r24, r30
    1248:	9f 1f       	adc	r25, r31
    124a:	fc 01       	movw	r30, r24
    124c:	e6 55       	subi	r30, 0x56	; 86
    124e:	fb 4f       	sbci	r31, 0xFB	; 251
    1250:	80 81       	ld	r24, Z
    1252:	82 30       	cpi	r24, 0x02	; 2
    1254:	40 f4       	brcc	.+16     	; 0x1266 <xTaskIncrementTick+0x152>
    1256:	09 c0       	rjmp	.+18     	; 0x126a <xTaskIncrementTick+0x156>
    1258:	80 91 7b 04 	lds	r24, 0x047B	; 0x80047b <uxPendedTicks>
    125c:	8f 5f       	subi	r24, 0xFF	; 255
    125e:	80 93 7b 04 	sts	0x047B, r24	; 0x80047b <uxPendedTicks>
    1262:	d1 2c       	mov	r13, r1
    1264:	02 c0       	rjmp	.+4      	; 0x126a <xTaskIncrementTick+0x156>
    1266:	dd 24       	eor	r13, r13
    1268:	d3 94       	inc	r13
    126a:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xYieldPending>
    126e:	88 23       	and	r24, r24
    1270:	11 f0       	breq	.+4      	; 0x1276 <xTaskIncrementTick+0x162>
    1272:	dd 24       	eor	r13, r13
    1274:	d3 94       	inc	r13
    1276:	8d 2d       	mov	r24, r13
    1278:	df 91       	pop	r29
    127a:	cf 91       	pop	r28
    127c:	1f 91       	pop	r17
    127e:	0f 91       	pop	r16
    1280:	ff 90       	pop	r15
    1282:	ef 90       	pop	r14
    1284:	df 90       	pop	r13
    1286:	08 95       	ret

00001288 <xTaskResumeAll>:
    1288:	0f 93       	push	r16
    128a:	1f 93       	push	r17
    128c:	cf 93       	push	r28
    128e:	df 93       	push	r29
    1290:	0f b6       	in	r0, 0x3f	; 63
    1292:	f8 94       	cli
    1294:	0f 92       	push	r0
    1296:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <uxSchedulerSuspended>
    129a:	81 50       	subi	r24, 0x01	; 1
    129c:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <uxSchedulerSuspended>
    12a0:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <uxSchedulerSuspended>
    12a4:	81 11       	cpse	r24, r1
    12a6:	58 c0       	rjmp	.+176    	; 0x1358 <xTaskResumeAll+0xd0>
    12a8:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <uxCurrentNumberOfTasks>
    12ac:	81 11       	cpse	r24, r1
    12ae:	33 c0       	rjmp	.+102    	; 0x1316 <xTaskResumeAll+0x8e>
    12b0:	56 c0       	rjmp	.+172    	; 0x135e <xTaskResumeAll+0xd6>
    12b2:	e0 91 90 04 	lds	r30, 0x0490	; 0x800490 <xPendingReadyList+0x5>
    12b6:	f0 91 91 04 	lds	r31, 0x0491	; 0x800491 <xPendingReadyList+0x6>
    12ba:	c6 81       	ldd	r28, Z+6	; 0x06
    12bc:	d7 81       	ldd	r29, Z+7	; 0x07
    12be:	ce 01       	movw	r24, r28
    12c0:	0c 96       	adiw	r24, 0x0c	; 12
    12c2:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
    12c6:	8e 01       	movw	r16, r28
    12c8:	0e 5f       	subi	r16, 0xFE	; 254
    12ca:	1f 4f       	sbci	r17, 0xFF	; 255
    12cc:	c8 01       	movw	r24, r16
    12ce:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
    12d2:	8e 89       	ldd	r24, Y+22	; 0x16
    12d4:	90 91 7d 04 	lds	r25, 0x047D	; 0x80047d <uxTopReadyPriority>
    12d8:	98 17       	cp	r25, r24
    12da:	10 f4       	brcc	.+4      	; 0x12e0 <xTaskResumeAll+0x58>
    12dc:	80 93 7d 04 	sts	0x047D, r24	; 0x80047d <uxTopReadyPriority>
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	9c 01       	movw	r18, r24
    12e4:	22 0f       	add	r18, r18
    12e6:	33 1f       	adc	r19, r19
    12e8:	22 0f       	add	r18, r18
    12ea:	33 1f       	adc	r19, r19
    12ec:	22 0f       	add	r18, r18
    12ee:	33 1f       	adc	r19, r19
    12f0:	82 0f       	add	r24, r18
    12f2:	93 1f       	adc	r25, r19
    12f4:	b8 01       	movw	r22, r16
    12f6:	86 55       	subi	r24, 0x56	; 86
    12f8:	9b 4f       	sbci	r25, 0xFB	; 251
    12fa:	0e 94 c8 04 	call	0x990	; 0x990 <vListInsertEnd>
    12fe:	9e 89       	ldd	r25, Y+22	; 0x16
    1300:	e0 91 fb 04 	lds	r30, 0x04FB	; 0x8004fb <pxCurrentTCB>
    1304:	f0 91 fc 04 	lds	r31, 0x04FC	; 0x8004fc <pxCurrentTCB+0x1>
    1308:	86 89       	ldd	r24, Z+22	; 0x16
    130a:	98 17       	cp	r25, r24
    130c:	30 f0       	brcs	.+12     	; 0x131a <xTaskResumeAll+0x92>
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <xYieldPending>
    1314:	02 c0       	rjmp	.+4      	; 0x131a <xTaskResumeAll+0x92>
    1316:	c0 e0       	ldi	r28, 0x00	; 0
    1318:	d0 e0       	ldi	r29, 0x00	; 0
    131a:	80 91 8b 04 	lds	r24, 0x048B	; 0x80048b <xPendingReadyList>
    131e:	81 11       	cpse	r24, r1
    1320:	c8 cf       	rjmp	.-112    	; 0x12b2 <xTaskResumeAll+0x2a>
    1322:	cd 2b       	or	r28, r29
    1324:	11 f0       	breq	.+4      	; 0x132a <xTaskResumeAll+0xa2>
    1326:	0e 94 9c 06 	call	0xd38	; 0xd38 <prvResetNextTaskUnblockTime>
    132a:	c0 91 7b 04 	lds	r28, 0x047B	; 0x80047b <uxPendedTicks>
    132e:	cc 23       	and	r28, r28
    1330:	59 f0       	breq	.+22     	; 0x1348 <xTaskResumeAll+0xc0>
    1332:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskIncrementTick>
    1336:	88 23       	and	r24, r24
    1338:	19 f0       	breq	.+6      	; 0x1340 <xTaskResumeAll+0xb8>
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <xYieldPending>
    1340:	c1 50       	subi	r28, 0x01	; 1
    1342:	b9 f7       	brne	.-18     	; 0x1332 <xTaskResumeAll+0xaa>
    1344:	10 92 7b 04 	sts	0x047B, r1	; 0x80047b <uxPendedTicks>
    1348:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <xYieldPending>
    134c:	88 23       	and	r24, r24
    134e:	31 f0       	breq	.+12     	; 0x135c <xTaskResumeAll+0xd4>
    1350:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <vPortYield>
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	03 c0       	rjmp	.+6      	; 0x135e <xTaskResumeAll+0xd6>
    1358:	80 e0       	ldi	r24, 0x00	; 0
    135a:	01 c0       	rjmp	.+2      	; 0x135e <xTaskResumeAll+0xd6>
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	0f 90       	pop	r0
    1360:	0f be       	out	0x3f, r0	; 63
    1362:	df 91       	pop	r29
    1364:	cf 91       	pop	r28
    1366:	1f 91       	pop	r17
    1368:	0f 91       	pop	r16
    136a:	08 95       	ret

0000136c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    136c:	cf 93       	push	r28
    136e:	df 93       	push	r29
    1370:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1372:	89 2b       	or	r24, r25
    1374:	49 f0       	breq	.+18     	; 0x1388 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1376:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    137a:	60 e0       	ldi	r22, 0x00	; 0
    137c:	ce 01       	movw	r24, r28
    137e:	0e 94 c2 07 	call	0xf84	; 0xf84 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1382:	0e 94 44 09 	call	0x1288	; 0x1288 <xTaskResumeAll>
    1386:	01 c0       	rjmp	.+2      	; 0x138a <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1388:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    138a:	81 11       	cpse	r24, r1
    138c:	02 c0       	rjmp	.+4      	; 0x1392 <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    138e:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	08 95       	ret

00001398 <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    139c:	24 c0       	rjmp	.+72     	; 0x13e6 <prvCheckTasksWaitingTermination+0x4e>
		{
			vTaskSuspendAll();
    139e:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13a2:	c0 91 82 04 	lds	r28, 0x0482	; 0x800482 <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
    13a6:	0e 94 44 09 	call	0x1288	; 0x1288 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    13aa:	cc 23       	and	r28, r28
    13ac:	e1 f0       	breq	.+56     	; 0x13e6 <prvCheckTasksWaitingTermination+0x4e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    13ae:	0f b6       	in	r0, 0x3f	; 63
    13b0:	f8 94       	cli
    13b2:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    13b4:	e0 91 87 04 	lds	r30, 0x0487	; 0x800487 <xTasksWaitingTermination+0x5>
    13b8:	f0 91 88 04 	lds	r31, 0x0488	; 0x800488 <xTasksWaitingTermination+0x6>
    13bc:	c6 81       	ldd	r28, Z+6	; 0x06
    13be:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    13c0:	ce 01       	movw	r24, r28
    13c2:	02 96       	adiw	r24, 0x02	; 2
    13c4:	0e 94 1a 05 	call	0xa34	; 0xa34 <uxListRemove>
					--uxCurrentNumberOfTasks;
    13c8:	80 91 80 04 	lds	r24, 0x0480	; 0x800480 <uxCurrentNumberOfTasks>
    13cc:	81 50       	subi	r24, 0x01	; 1
    13ce:	80 93 80 04 	sts	0x0480, r24	; 0x800480 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
    13d2:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <uxDeletedTasksWaitingCleanUp>
    13d6:	81 50       	subi	r24, 0x01	; 1
    13d8:	80 93 81 04 	sts	0x0481, r24	; 0x800481 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
    13dc:	0f 90       	pop	r0
    13de:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    13e0:	ce 01       	movw	r24, r28
    13e2:	0e 94 bb 06 	call	0xd76	; 0xd76 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    13e6:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <uxDeletedTasksWaitingCleanUp>
    13ea:	81 11       	cpse	r24, r1
    13ec:	d8 cf       	rjmp	.-80     	; 0x139e <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    13ee:	df 91       	pop	r29
    13f0:	cf 91       	pop	r28
    13f2:	08 95       	ret

000013f4 <prvIdleTask>:

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    13f4:	0e 94 cc 09 	call	0x1398	; 0x1398 <prvCheckTasksWaitingTermination>
    13f8:	fd cf       	rjmp	.-6      	; 0x13f4 <prvIdleTask>

000013fa <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    13fa:	80 91 73 04 	lds	r24, 0x0473	; 0x800473 <uxSchedulerSuspended>
    13fe:	88 23       	and	r24, r24
    1400:	21 f0       	breq	.+8      	; 0x140a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <xYieldPending>
    1408:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    140a:	10 92 7a 04 	sts	0x047A, r1	; 0x80047a <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    140e:	20 91 7d 04 	lds	r18, 0x047D	; 0x80047d <uxTopReadyPriority>
    1412:	01 c0       	rjmp	.+2      	; 0x1416 <vTaskSwitchContext+0x1c>
    1414:	21 50       	subi	r18, 0x01	; 1
    1416:	82 2f       	mov	r24, r18
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	fc 01       	movw	r30, r24
    141c:	ee 0f       	add	r30, r30
    141e:	ff 1f       	adc	r31, r31
    1420:	ee 0f       	add	r30, r30
    1422:	ff 1f       	adc	r31, r31
    1424:	ee 0f       	add	r30, r30
    1426:	ff 1f       	adc	r31, r31
    1428:	e8 0f       	add	r30, r24
    142a:	f9 1f       	adc	r31, r25
    142c:	e6 55       	subi	r30, 0x56	; 86
    142e:	fb 4f       	sbci	r31, 0xFB	; 251
    1430:	30 81       	ld	r19, Z
    1432:	33 23       	and	r19, r19
    1434:	79 f3       	breq	.-34     	; 0x1414 <vTaskSwitchContext+0x1a>
    1436:	ac 01       	movw	r20, r24
    1438:	44 0f       	add	r20, r20
    143a:	55 1f       	adc	r21, r21
    143c:	44 0f       	add	r20, r20
    143e:	55 1f       	adc	r21, r21
    1440:	44 0f       	add	r20, r20
    1442:	55 1f       	adc	r21, r21
    1444:	48 0f       	add	r20, r24
    1446:	59 1f       	adc	r21, r25
    1448:	df 01       	movw	r26, r30
    144a:	01 80       	ldd	r0, Z+1	; 0x01
    144c:	f2 81       	ldd	r31, Z+2	; 0x02
    144e:	e0 2d       	mov	r30, r0
    1450:	02 80       	ldd	r0, Z+2	; 0x02
    1452:	f3 81       	ldd	r31, Z+3	; 0x03
    1454:	e0 2d       	mov	r30, r0
    1456:	12 96       	adiw	r26, 0x02	; 2
    1458:	fc 93       	st	X, r31
    145a:	ee 93       	st	-X, r30
    145c:	11 97       	sbiw	r26, 0x01	; 1
    145e:	43 55       	subi	r20, 0x53	; 83
    1460:	5b 4f       	sbci	r21, 0xFB	; 251
    1462:	e4 17       	cp	r30, r20
    1464:	f5 07       	cpc	r31, r21
    1466:	29 f4       	brne	.+10     	; 0x1472 <vTaskSwitchContext+0x78>
    1468:	42 81       	ldd	r20, Z+2	; 0x02
    146a:	53 81       	ldd	r21, Z+3	; 0x03
    146c:	fd 01       	movw	r30, r26
    146e:	52 83       	std	Z+2, r21	; 0x02
    1470:	41 83       	std	Z+1, r20	; 0x01
    1472:	fc 01       	movw	r30, r24
    1474:	ee 0f       	add	r30, r30
    1476:	ff 1f       	adc	r31, r31
    1478:	ee 0f       	add	r30, r30
    147a:	ff 1f       	adc	r31, r31
    147c:	ee 0f       	add	r30, r30
    147e:	ff 1f       	adc	r31, r31
    1480:	8e 0f       	add	r24, r30
    1482:	9f 1f       	adc	r25, r31
    1484:	fc 01       	movw	r30, r24
    1486:	e6 55       	subi	r30, 0x56	; 86
    1488:	fb 4f       	sbci	r31, 0xFB	; 251
    148a:	01 80       	ldd	r0, Z+1	; 0x01
    148c:	f2 81       	ldd	r31, Z+2	; 0x02
    148e:	e0 2d       	mov	r30, r0
    1490:	86 81       	ldd	r24, Z+6	; 0x06
    1492:	97 81       	ldd	r25, Z+7	; 0x07
    1494:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <pxCurrentTCB+0x1>
    1498:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <pxCurrentTCB>
    149c:	20 93 7d 04 	sts	0x047D, r18	; 0x80047d <uxTopReadyPriority>
    14a0:	08 95       	ret

000014a2 <__tablejump2__>:
    14a2:	ee 0f       	add	r30, r30
    14a4:	ff 1f       	adc	r31, r31
    14a6:	05 90       	lpm	r0, Z+
    14a8:	f4 91       	lpm	r31, Z
    14aa:	e0 2d       	mov	r30, r0
    14ac:	09 94       	ijmp

000014ae <__muluhisi3>:
    14ae:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <__umulhisi3>
    14b2:	a5 9f       	mul	r26, r21
    14b4:	90 0d       	add	r25, r0
    14b6:	b4 9f       	mul	r27, r20
    14b8:	90 0d       	add	r25, r0
    14ba:	a4 9f       	mul	r26, r20
    14bc:	80 0d       	add	r24, r0
    14be:	91 1d       	adc	r25, r1
    14c0:	11 24       	eor	r1, r1
    14c2:	08 95       	ret

000014c4 <__umulhisi3>:
    14c4:	a2 9f       	mul	r26, r18
    14c6:	b0 01       	movw	r22, r0
    14c8:	b3 9f       	mul	r27, r19
    14ca:	c0 01       	movw	r24, r0
    14cc:	a3 9f       	mul	r26, r19
    14ce:	70 0d       	add	r23, r0
    14d0:	81 1d       	adc	r24, r1
    14d2:	11 24       	eor	r1, r1
    14d4:	91 1d       	adc	r25, r1
    14d6:	b2 9f       	mul	r27, r18
    14d8:	70 0d       	add	r23, r0
    14da:	81 1d       	adc	r24, r1
    14dc:	11 24       	eor	r1, r1
    14de:	91 1d       	adc	r25, r1
    14e0:	08 95       	ret

000014e2 <_exit>:
    14e2:	f8 94       	cli

000014e4 <__stop_program>:
    14e4:	ff cf       	rjmp	.-2      	; 0x14e4 <__stop_program>
