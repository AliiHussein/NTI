
Application.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001396  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000010  00800060  00001396  0000142a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000483  00800070  00800070  0000143a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000143a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000146c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c0  00000000  00000000  000014a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003888  00000000  00000000  00001868  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000117f  00000000  00000000  000050f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000221f  00000000  00000000  0000626f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b88  00000000  00000000  00008490  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001402  00000000  00000000  00009018  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000343c  00000000  00000000  0000a41a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000360  00000000  00000000  0000d856  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 79 02 	jmp	0x4f2	; 0x4f2 <__vector_1>
       8:	0c 94 a0 02 	jmp	0x540	; 0x540 <__vector_2>
       c:	0c 94 c7 02 	jmp	0x58e	; 0x58e <__vector_3>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__vector_7>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 15 03 	jmp	0x62a	; 0x62a <__vector_10>
      2c:	0c 94 ee 02 	jmp	0x5dc	; 0x5dc <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	ca 00       	.word	0x00ca	; ????
      56:	d7 00       	.word	0x00d7	; ????
      58:	e4 00       	.word	0x00e4	; ????
      5a:	f1 00       	.word	0x00f1	; ????
      5c:	fe 00       	.word	0x00fe	; ????
      5e:	0b 01       	movw	r0, r22
      60:	18 01       	movw	r2, r16
      62:	25 01       	movw	r4, r10
      64:	32 01       	movw	r6, r4
      66:	3f 01       	movw	r6, r30

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf e5       	ldi	r28, 0x5F	; 95
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	10 e0       	ldi	r17, 0x00	; 0
      76:	a0 e6       	ldi	r26, 0x60	; 96
      78:	b0 e0       	ldi	r27, 0x00	; 0
      7a:	e6 e9       	ldi	r30, 0x96	; 150
      7c:	f3 e1       	ldi	r31, 0x13	; 19
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 37       	cpi	r26, 0x70	; 112
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	24 e0       	ldi	r18, 0x04	; 4
      8c:	a0 e7       	ldi	r26, 0x70	; 112
      8e:	b0 e0       	ldi	r27, 0x00	; 0
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a3 3f       	cpi	r26, 0xF3	; 243
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <main>
      9e:	0c 94 c9 09 	jmp	0x1392	; 0x1392 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <led_init>:
void led_on(uint8 copy_u8PortID, uint8 copy_u8PinID){
	DIO_voidSetPinValue(copy_u8PortID, copy_u8PinID, HIGH);
}

void led_off(uint8 copy_u8PortID, uint8 copy_u8PinID){
	DIO_voidSetPinValue(copy_u8PortID, copy_u8PinID, LOW);
      a6:	41 e0       	ldi	r20, 0x01	; 1
      a8:	0e 94 05 02 	call	0x40a	; 0x40a <DIO_voidSetPinDirection>
      ac:	08 95       	ret

000000ae <led_toggle>:
}

void led_toggle(uint8 copy_u8PortID, uint8 copy_u8PinID){
	switch(copy_u8PortID){
      ae:	82 34       	cpi	r24, 0x42	; 66
      b0:	a1 f0       	breq	.+40     	; 0xda <led_toggle+0x2c>
      b2:	18 f4       	brcc	.+6      	; 0xba <led_toggle+0xc>
      b4:	81 34       	cpi	r24, 0x41	; 65
      b6:	31 f0       	breq	.+12     	; 0xc4 <led_toggle+0x16>
      b8:	08 95       	ret
      ba:	83 34       	cpi	r24, 0x43	; 67
      bc:	c9 f0       	breq	.+50     	; 0xf0 <led_toggle+0x42>
      be:	84 34       	cpi	r24, 0x44	; 68
      c0:	11 f1       	breq	.+68     	; 0x106 <led_toggle+0x58>
      c2:	08 95       	ret
		case portA: TOGBIT(PORTA, copy_u8PinID); break;
      c4:	2b b3       	in	r18, 0x1b	; 27
      c6:	81 e0       	ldi	r24, 0x01	; 1
      c8:	90 e0       	ldi	r25, 0x00	; 0
      ca:	02 c0       	rjmp	.+4      	; 0xd0 <led_toggle+0x22>
      cc:	88 0f       	add	r24, r24
      ce:	99 1f       	adc	r25, r25
      d0:	6a 95       	dec	r22
      d2:	e2 f7       	brpl	.-8      	; 0xcc <led_toggle+0x1e>
      d4:	82 27       	eor	r24, r18
      d6:	8b bb       	out	0x1b, r24	; 27
      d8:	08 95       	ret
		case portB: TOGBIT(PORTB, copy_u8PinID); break;
      da:	28 b3       	in	r18, 0x18	; 24
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	90 e0       	ldi	r25, 0x00	; 0
      e0:	02 c0       	rjmp	.+4      	; 0xe6 <led_toggle+0x38>
      e2:	88 0f       	add	r24, r24
      e4:	99 1f       	adc	r25, r25
      e6:	6a 95       	dec	r22
      e8:	e2 f7       	brpl	.-8      	; 0xe2 <led_toggle+0x34>
      ea:	82 27       	eor	r24, r18
      ec:	88 bb       	out	0x18, r24	; 24
      ee:	08 95       	ret
		case portC: TOGBIT(PORTC, copy_u8PinID); break;
      f0:	25 b3       	in	r18, 0x15	; 21
      f2:	81 e0       	ldi	r24, 0x01	; 1
      f4:	90 e0       	ldi	r25, 0x00	; 0
      f6:	02 c0       	rjmp	.+4      	; 0xfc <led_toggle+0x4e>
      f8:	88 0f       	add	r24, r24
      fa:	99 1f       	adc	r25, r25
      fc:	6a 95       	dec	r22
      fe:	e2 f7       	brpl	.-8      	; 0xf8 <led_toggle+0x4a>
     100:	82 27       	eor	r24, r18
     102:	85 bb       	out	0x15, r24	; 21
     104:	08 95       	ret
		case portD: TOGBIT(PORTD, copy_u8PinID); break;
     106:	22 b3       	in	r18, 0x12	; 18
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	02 c0       	rjmp	.+4      	; 0x112 <led_toggle+0x64>
     10e:	88 0f       	add	r24, r24
     110:	99 1f       	adc	r25, r25
     112:	6a 95       	dec	r22
     114:	e2 f7       	brpl	.-8      	; 0x10e <led_toggle+0x60>
     116:	82 27       	eor	r24, r18
     118:	82 bb       	out	0x12, r24	; 18
     11a:	08 95       	ret

0000011c <sevenseg_init>:
 */ 

#include "SevenSeg.h"

void sevenseg_init(){
	SEVEN_SEG_INIT_PORTS();
     11c:	8f ef       	ldi	r24, 0xFF	; 255
     11e:	87 bb       	out	0x17, r24	; 23
     120:	88 bb       	out	0x18, r24	; 24
     122:	8a b3       	in	r24, 0x1a	; 26
     124:	84 60       	ori	r24, 0x04	; 4
     126:	8a bb       	out	0x1a, r24	; 26
     128:	8a b3       	in	r24, 0x1a	; 26
     12a:	88 60       	ori	r24, 0x08	; 8
     12c:	8a bb       	out	0x1a, r24	; 26
     12e:	08 95       	ret

00000130 <sevenseg_write>:
	
}

void sevenseg_write(uint8 value, uint8 ss_num){
     130:	e8 2f       	mov	r30, r24
	
	EN1_DIS();EN2_DIS();EN3_DIS();EN4_DIS();
     132:	8b b3       	in	r24, 0x1b	; 27
     134:	88 60       	ori	r24, 0x08	; 8
     136:	8b bb       	out	0x1b, r24	; 27
     138:	8b b3       	in	r24, 0x1b	; 27
     13a:	84 60       	ori	r24, 0x04	; 4
     13c:	8b bb       	out	0x1b, r24	; 27
     13e:	88 b3       	in	r24, 0x18	; 24
     140:	80 62       	ori	r24, 0x20	; 32
     142:	88 bb       	out	0x18, r24	; 24
     144:	88 b3       	in	r24, 0x18	; 24
     146:	80 64       	ori	r24, 0x40	; 64
     148:	88 bb       	out	0x18, r24	; 24
	
	switch(ss_num){
     14a:	62 30       	cpi	r22, 0x02	; 2
     14c:	69 f0       	breq	.+26     	; 0x168 <sevenseg_write+0x38>
     14e:	18 f4       	brcc	.+6      	; 0x156 <sevenseg_write+0x26>
     150:	61 30       	cpi	r22, 0x01	; 1
     152:	31 f0       	breq	.+12     	; 0x160 <sevenseg_write+0x30>
     154:	14 c0       	rjmp	.+40     	; 0x17e <sevenseg_write+0x4e>
     156:	63 30       	cpi	r22, 0x03	; 3
     158:	59 f0       	breq	.+22     	; 0x170 <sevenseg_write+0x40>
     15a:	64 30       	cpi	r22, 0x04	; 4
     15c:	69 f0       	breq	.+26     	; 0x178 <sevenseg_write+0x48>
     15e:	0f c0       	rjmp	.+30     	; 0x17e <sevenseg_write+0x4e>
		case 1: EN1_EN(); break;
     160:	8b b3       	in	r24, 0x1b	; 27
     162:	87 7f       	andi	r24, 0xF7	; 247
     164:	8b bb       	out	0x1b, r24	; 27
     166:	0b c0       	rjmp	.+22     	; 0x17e <sevenseg_write+0x4e>
		case 2: EN2_EN(); break;
     168:	8b b3       	in	r24, 0x1b	; 27
     16a:	8b 7f       	andi	r24, 0xFB	; 251
     16c:	8b bb       	out	0x1b, r24	; 27
     16e:	07 c0       	rjmp	.+14     	; 0x17e <sevenseg_write+0x4e>
		case 3: EN3_EN(); break;
     170:	88 b3       	in	r24, 0x18	; 24
     172:	8f 7d       	andi	r24, 0xDF	; 223
     174:	88 bb       	out	0x18, r24	; 24
     176:	03 c0       	rjmp	.+6      	; 0x17e <sevenseg_write+0x4e>
		case 4: EN4_EN(); break;
     178:	88 b3       	in	r24, 0x18	; 24
     17a:	8f 7b       	andi	r24, 0xBF	; 191
     17c:	88 bb       	out	0x18, r24	; 24
	}
	
	switch(value){
     17e:	8e 2f       	mov	r24, r30
     180:	90 e0       	ldi	r25, 0x00	; 0
     182:	8a 30       	cpi	r24, 0x0A	; 10
     184:	91 05       	cpc	r25, r1
     186:	08 f0       	brcs	.+2      	; 0x18a <sevenseg_write+0x5a>
     188:	86 c0       	rjmp	.+268    	; 0x296 <sevenseg_write+0x166>
     18a:	fc 01       	movw	r30, r24
     18c:	e6 5d       	subi	r30, 0xD6	; 214
     18e:	ff 4f       	sbci	r31, 0xFF	; 255
     190:	0c 94 c3 09 	jmp	0x1386	; 0x1386 <__tablejump2__>
		case 0: CLRBIT(PORTB, 4); CLRBIT(PORTB, 2); CLRBIT(PORTB, 1); CLRBIT(PORTB, 0); break;
     194:	88 b3       	in	r24, 0x18	; 24
     196:	8f 7e       	andi	r24, 0xEF	; 239
     198:	88 bb       	out	0x18, r24	; 24
     19a:	88 b3       	in	r24, 0x18	; 24
     19c:	8b 7f       	andi	r24, 0xFB	; 251
     19e:	88 bb       	out	0x18, r24	; 24
     1a0:	88 b3       	in	r24, 0x18	; 24
     1a2:	8d 7f       	andi	r24, 0xFD	; 253
     1a4:	88 bb       	out	0x18, r24	; 24
     1a6:	88 b3       	in	r24, 0x18	; 24
     1a8:	8e 7f       	andi	r24, 0xFE	; 254
     1aa:	88 bb       	out	0x18, r24	; 24
     1ac:	74 c0       	rjmp	.+232    	; 0x296 <sevenseg_write+0x166>
		case 1: CLRBIT(PORTB, 4); CLRBIT(PORTB, 2); CLRBIT(PORTB, 1); SETBIT(PORTB, 0); break;
     1ae:	88 b3       	in	r24, 0x18	; 24
     1b0:	8f 7e       	andi	r24, 0xEF	; 239
     1b2:	88 bb       	out	0x18, r24	; 24
     1b4:	88 b3       	in	r24, 0x18	; 24
     1b6:	8b 7f       	andi	r24, 0xFB	; 251
     1b8:	88 bb       	out	0x18, r24	; 24
     1ba:	88 b3       	in	r24, 0x18	; 24
     1bc:	8d 7f       	andi	r24, 0xFD	; 253
     1be:	88 bb       	out	0x18, r24	; 24
     1c0:	88 b3       	in	r24, 0x18	; 24
     1c2:	81 60       	ori	r24, 0x01	; 1
     1c4:	88 bb       	out	0x18, r24	; 24
     1c6:	67 c0       	rjmp	.+206    	; 0x296 <sevenseg_write+0x166>
		case 2: CLRBIT(PORTB, 4); CLRBIT(PORTB, 2); SETBIT(PORTB, 1); CLRBIT(PORTB, 0); break;
     1c8:	88 b3       	in	r24, 0x18	; 24
     1ca:	8f 7e       	andi	r24, 0xEF	; 239
     1cc:	88 bb       	out	0x18, r24	; 24
     1ce:	88 b3       	in	r24, 0x18	; 24
     1d0:	8b 7f       	andi	r24, 0xFB	; 251
     1d2:	88 bb       	out	0x18, r24	; 24
     1d4:	88 b3       	in	r24, 0x18	; 24
     1d6:	82 60       	ori	r24, 0x02	; 2
     1d8:	88 bb       	out	0x18, r24	; 24
     1da:	88 b3       	in	r24, 0x18	; 24
     1dc:	8e 7f       	andi	r24, 0xFE	; 254
     1de:	88 bb       	out	0x18, r24	; 24
     1e0:	5a c0       	rjmp	.+180    	; 0x296 <sevenseg_write+0x166>
		case 3: CLRBIT(PORTB, 4); CLRBIT(PORTB, 2); SETBIT(PORTB, 1); SETBIT(PORTB, 0); break;
     1e2:	88 b3       	in	r24, 0x18	; 24
     1e4:	8f 7e       	andi	r24, 0xEF	; 239
     1e6:	88 bb       	out	0x18, r24	; 24
     1e8:	88 b3       	in	r24, 0x18	; 24
     1ea:	8b 7f       	andi	r24, 0xFB	; 251
     1ec:	88 bb       	out	0x18, r24	; 24
     1ee:	88 b3       	in	r24, 0x18	; 24
     1f0:	82 60       	ori	r24, 0x02	; 2
     1f2:	88 bb       	out	0x18, r24	; 24
     1f4:	88 b3       	in	r24, 0x18	; 24
     1f6:	81 60       	ori	r24, 0x01	; 1
     1f8:	88 bb       	out	0x18, r24	; 24
     1fa:	4d c0       	rjmp	.+154    	; 0x296 <sevenseg_write+0x166>
		case 4: CLRBIT(PORTB, 4); SETBIT(PORTB, 2); CLRBIT(PORTB, 1); CLRBIT(PORTB, 0); break;
     1fc:	88 b3       	in	r24, 0x18	; 24
     1fe:	8f 7e       	andi	r24, 0xEF	; 239
     200:	88 bb       	out	0x18, r24	; 24
     202:	88 b3       	in	r24, 0x18	; 24
     204:	84 60       	ori	r24, 0x04	; 4
     206:	88 bb       	out	0x18, r24	; 24
     208:	88 b3       	in	r24, 0x18	; 24
     20a:	8d 7f       	andi	r24, 0xFD	; 253
     20c:	88 bb       	out	0x18, r24	; 24
     20e:	88 b3       	in	r24, 0x18	; 24
     210:	8e 7f       	andi	r24, 0xFE	; 254
     212:	88 bb       	out	0x18, r24	; 24
     214:	40 c0       	rjmp	.+128    	; 0x296 <sevenseg_write+0x166>
		case 5: CLRBIT(PORTB, 4); SETBIT(PORTB, 2); CLRBIT(PORTB, 1); SETBIT(PORTB, 0); break;
     216:	88 b3       	in	r24, 0x18	; 24
     218:	8f 7e       	andi	r24, 0xEF	; 239
     21a:	88 bb       	out	0x18, r24	; 24
     21c:	88 b3       	in	r24, 0x18	; 24
     21e:	84 60       	ori	r24, 0x04	; 4
     220:	88 bb       	out	0x18, r24	; 24
     222:	88 b3       	in	r24, 0x18	; 24
     224:	8d 7f       	andi	r24, 0xFD	; 253
     226:	88 bb       	out	0x18, r24	; 24
     228:	88 b3       	in	r24, 0x18	; 24
     22a:	81 60       	ori	r24, 0x01	; 1
     22c:	88 bb       	out	0x18, r24	; 24
     22e:	33 c0       	rjmp	.+102    	; 0x296 <sevenseg_write+0x166>
		case 6: CLRBIT(PORTB, 4); SETBIT(PORTB, 2); SETBIT(PORTB, 1); CLRBIT(PORTB, 0); break;
     230:	88 b3       	in	r24, 0x18	; 24
     232:	8f 7e       	andi	r24, 0xEF	; 239
     234:	88 bb       	out	0x18, r24	; 24
     236:	88 b3       	in	r24, 0x18	; 24
     238:	84 60       	ori	r24, 0x04	; 4
     23a:	88 bb       	out	0x18, r24	; 24
     23c:	88 b3       	in	r24, 0x18	; 24
     23e:	82 60       	ori	r24, 0x02	; 2
     240:	88 bb       	out	0x18, r24	; 24
     242:	88 b3       	in	r24, 0x18	; 24
     244:	8e 7f       	andi	r24, 0xFE	; 254
     246:	88 bb       	out	0x18, r24	; 24
     248:	26 c0       	rjmp	.+76     	; 0x296 <sevenseg_write+0x166>
		case 7: CLRBIT(PORTB, 4); SETBIT(PORTB, 2); SETBIT(PORTB, 1); SETBIT(PORTB, 0); break;
     24a:	88 b3       	in	r24, 0x18	; 24
     24c:	8f 7e       	andi	r24, 0xEF	; 239
     24e:	88 bb       	out	0x18, r24	; 24
     250:	88 b3       	in	r24, 0x18	; 24
     252:	84 60       	ori	r24, 0x04	; 4
     254:	88 bb       	out	0x18, r24	; 24
     256:	88 b3       	in	r24, 0x18	; 24
     258:	82 60       	ori	r24, 0x02	; 2
     25a:	88 bb       	out	0x18, r24	; 24
     25c:	88 b3       	in	r24, 0x18	; 24
     25e:	81 60       	ori	r24, 0x01	; 1
     260:	88 bb       	out	0x18, r24	; 24
     262:	19 c0       	rjmp	.+50     	; 0x296 <sevenseg_write+0x166>
		case 8: SETBIT(PORTB, 4); CLRBIT(PORTB, 2); CLRBIT(PORTB, 1); CLRBIT(PORTB, 0); break;
     264:	88 b3       	in	r24, 0x18	; 24
     266:	80 61       	ori	r24, 0x10	; 16
     268:	88 bb       	out	0x18, r24	; 24
     26a:	88 b3       	in	r24, 0x18	; 24
     26c:	8b 7f       	andi	r24, 0xFB	; 251
     26e:	88 bb       	out	0x18, r24	; 24
     270:	88 b3       	in	r24, 0x18	; 24
     272:	8d 7f       	andi	r24, 0xFD	; 253
     274:	88 bb       	out	0x18, r24	; 24
     276:	88 b3       	in	r24, 0x18	; 24
     278:	8e 7f       	andi	r24, 0xFE	; 254
     27a:	88 bb       	out	0x18, r24	; 24
     27c:	0c c0       	rjmp	.+24     	; 0x296 <sevenseg_write+0x166>
		case 9: SETBIT(PORTB, 4); CLRBIT(PORTB, 2); CLRBIT(PORTB, 1); SETBIT(PORTB, 0); break;
     27e:	88 b3       	in	r24, 0x18	; 24
     280:	80 61       	ori	r24, 0x10	; 16
     282:	88 bb       	out	0x18, r24	; 24
     284:	88 b3       	in	r24, 0x18	; 24
     286:	8b 7f       	andi	r24, 0xFB	; 251
     288:	88 bb       	out	0x18, r24	; 24
     28a:	88 b3       	in	r24, 0x18	; 24
     28c:	8d 7f       	andi	r24, 0xFD	; 253
     28e:	88 bb       	out	0x18, r24	; 24
     290:	88 b3       	in	r24, 0x18	; 24
     292:	81 60       	ori	r24, 0x01	; 1
     294:	88 bb       	out	0x18, r24	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     296:	8f e9       	ldi	r24, 0x9F	; 159
     298:	9f e0       	ldi	r25, 0x0F	; 15
     29a:	01 97       	sbiw	r24, 0x01	; 1
     29c:	f1 f7       	brne	.-4      	; 0x29a <sevenseg_write+0x16a>
     29e:	00 c0       	rjmp	.+0      	; 0x2a0 <sevenseg_write+0x170>
     2a0:	00 00       	nop
     2a2:	08 95       	ret

000002a4 <sevenseg_write_four>:
	}	
	_delay_ms(1);
}

void sevenseg_write_four(uint32 value){
     2a4:	4f 92       	push	r4
     2a6:	5f 92       	push	r5
     2a8:	6f 92       	push	r6
     2aa:	7f 92       	push	r7
     2ac:	8f 92       	push	r8
     2ae:	9f 92       	push	r9
     2b0:	af 92       	push	r10
     2b2:	bf 92       	push	r11
     2b4:	cf 92       	push	r12
     2b6:	df 92       	push	r13
     2b8:	ef 92       	push	r14
     2ba:	ff 92       	push	r15
     2bc:	4b 01       	movw	r8, r22
     2be:	5c 01       	movw	r10, r24
	
	sevenseg_write(value%10, 1);
     2c0:	0f 2e       	mov	r0, r31
     2c2:	fa e0       	ldi	r31, 0x0A	; 10
     2c4:	cf 2e       	mov	r12, r31
     2c6:	d1 2c       	mov	r13, r1
     2c8:	e1 2c       	mov	r14, r1
     2ca:	f1 2c       	mov	r15, r1
     2cc:	f0 2d       	mov	r31, r0
     2ce:	a7 01       	movw	r20, r14
     2d0:	96 01       	movw	r18, r12
     2d2:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
     2d6:	29 01       	movw	r4, r18
     2d8:	3a 01       	movw	r6, r20
     2da:	86 2f       	mov	r24, r22
     2dc:	61 e0       	ldi	r22, 0x01	; 1
     2de:	0e 94 98 00 	call	0x130	; 0x130 <sevenseg_write>
	value/=10;
	sevenseg_write(value%10, 2);
     2e2:	c3 01       	movw	r24, r6
     2e4:	b2 01       	movw	r22, r4
     2e6:	a7 01       	movw	r20, r14
     2e8:	96 01       	movw	r18, r12
     2ea:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
     2ee:	86 2f       	mov	r24, r22
     2f0:	62 e0       	ldi	r22, 0x02	; 2
     2f2:	0e 94 98 00 	call	0x130	; 0x130 <sevenseg_write>
	value/=10;
     2f6:	c5 01       	movw	r24, r10
     2f8:	b4 01       	movw	r22, r8
     2fa:	24 e6       	ldi	r18, 0x64	; 100
     2fc:	30 e0       	ldi	r19, 0x00	; 0
     2fe:	40 e0       	ldi	r20, 0x00	; 0
     300:	50 e0       	ldi	r21, 0x00	; 0
     302:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
	sevenseg_write(value%10, 3);
     306:	ca 01       	movw	r24, r20
     308:	b9 01       	movw	r22, r18
     30a:	a7 01       	movw	r20, r14
     30c:	96 01       	movw	r18, r12
     30e:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
     312:	86 2f       	mov	r24, r22
     314:	63 e0       	ldi	r22, 0x03	; 3
     316:	0e 94 98 00 	call	0x130	; 0x130 <sevenseg_write>
	value/=10;
     31a:	c5 01       	movw	r24, r10
     31c:	b4 01       	movw	r22, r8
     31e:	28 ee       	ldi	r18, 0xE8	; 232
     320:	33 e0       	ldi	r19, 0x03	; 3
     322:	40 e0       	ldi	r20, 0x00	; 0
     324:	50 e0       	ldi	r21, 0x00	; 0
     326:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
	sevenseg_write(value%10, 4);
     32a:	ca 01       	movw	r24, r20
     32c:	b9 01       	movw	r22, r18
     32e:	a7 01       	movw	r20, r14
     330:	96 01       	movw	r18, r12
     332:	0e 94 a1 09 	call	0x1342	; 0x1342 <__udivmodsi4>
     336:	86 2f       	mov	r24, r22
     338:	64 e0       	ldi	r22, 0x04	; 4
     33a:	0e 94 98 00 	call	0x130	; 0x130 <sevenseg_write>
     33e:	ff 90       	pop	r15
     340:	ef 90       	pop	r14
     342:	df 90       	pop	r13
     344:	cf 90       	pop	r12
     346:	bf 90       	pop	r11
     348:	af 90       	pop	r10
     34a:	9f 90       	pop	r9
     34c:	8f 90       	pop	r8
     34e:	7f 90       	pop	r7
     350:	6f 90       	pop	r6
     352:	5f 90       	pop	r5
     354:	4f 90       	pop	r4
     356:	08 95       	ret

00000358 <task1>:
#include "HAL/LED/LED.h"
#include "HAL/SevenSeg/SevenSeg.h"


void task1(void){
	led_init(portA,5);
     358:	65 e0       	ldi	r22, 0x05	; 5
     35a:	81 e4       	ldi	r24, 0x41	; 65
     35c:	0e 94 53 00 	call	0xa6	; 0xa6 <led_init>
	while (1)
	{
		led_toggle(portA,5);
     360:	65 e0       	ldi	r22, 0x05	; 5
     362:	81 e4       	ldi	r24, 0x41	; 65
     364:	0e 94 57 00 	call	0xae	; 0xae <led_toggle>
		vTaskDelay(1000);
     368:	88 ee       	ldi	r24, 0xE8	; 232
     36a:	93 e0       	ldi	r25, 0x03	; 3
     36c:	0e 94 06 09 	call	0x120c	; 0x120c <vTaskDelay>
     370:	f7 cf       	rjmp	.-18     	; 0x360 <task1+0x8>

00000372 <task2>:
	}
}

void task2(void){
	led_init(portA, 6);
     372:	66 e0       	ldi	r22, 0x06	; 6
     374:	81 e4       	ldi	r24, 0x41	; 65
     376:	0e 94 53 00 	call	0xa6	; 0xa6 <led_init>
	while (1)
	{
		led_toggle(portA,6);
     37a:	66 e0       	ldi	r22, 0x06	; 6
     37c:	81 e4       	ldi	r24, 0x41	; 65
     37e:	0e 94 57 00 	call	0xae	; 0xae <led_toggle>
		vTaskDelay(5000);
     382:	88 e8       	ldi	r24, 0x88	; 136
     384:	93 e1       	ldi	r25, 0x13	; 19
     386:	0e 94 06 09 	call	0x120c	; 0x120c <vTaskDelay>
     38a:	f7 cf       	rjmp	.-18     	; 0x37a <task2+0x8>

0000038c <task3>:
	}
}

void task3(void){
	sevenseg_init();
     38c:	0e 94 8e 00 	call	0x11c	; 0x11c <sevenseg_init>
	uint8 count = 0;
     390:	c0 e0       	ldi	r28, 0x00	; 0
	while(1)
	{
		sevenseg_write_four(count);
     392:	6c 2f       	mov	r22, r28
     394:	70 e0       	ldi	r23, 0x00	; 0
     396:	80 e0       	ldi	r24, 0x00	; 0
     398:	90 e0       	ldi	r25, 0x00	; 0
     39a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <sevenseg_write_four>
		count++;
     39e:	cf 5f       	subi	r28, 0xFF	; 255
		if(count == 100){
     3a0:	c4 36       	cpi	r28, 0x64	; 100
     3a2:	09 f4       	brne	.+2      	; 0x3a6 <task3+0x1a>
			count = 0;
     3a4:	c0 e0       	ldi	r28, 0x00	; 0
		}
		vTaskDelay(1000);
     3a6:	88 ee       	ldi	r24, 0xE8	; 232
     3a8:	93 e0       	ldi	r25, 0x03	; 3
     3aa:	0e 94 06 09 	call	0x120c	; 0x120c <vTaskDelay>
		
	}
     3ae:	f1 cf       	rjmp	.-30     	; 0x392 <task3+0x6>

000003b0 <main>:
}



int main(void){
     3b0:	ef 92       	push	r14
     3b2:	ff 92       	push	r15
     3b4:	0f 93       	push	r16
	
	/* Task creation and scheduling*/
	xTaskCreate(task1, "T1", 100, NULL, 1, NULL);
     3b6:	e1 2c       	mov	r14, r1
     3b8:	f1 2c       	mov	r15, r1
     3ba:	01 e0       	ldi	r16, 0x01	; 1
     3bc:	20 e0       	ldi	r18, 0x00	; 0
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	44 e6       	ldi	r20, 0x64	; 100
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	62 e6       	ldi	r22, 0x62	; 98
     3c6:	70 e0       	ldi	r23, 0x00	; 0
     3c8:	8c ea       	ldi	r24, 0xAC	; 172
     3ca:	91 e0       	ldi	r25, 0x01	; 1
     3cc:	0e 94 56 07 	call	0xeac	; 0xeac <xTaskCreate>
	xTaskCreate(task2, "T2", 100, NULL, 1, NULL);
     3d0:	20 e0       	ldi	r18, 0x00	; 0
     3d2:	30 e0       	ldi	r19, 0x00	; 0
     3d4:	44 e6       	ldi	r20, 0x64	; 100
     3d6:	50 e0       	ldi	r21, 0x00	; 0
     3d8:	65 e6       	ldi	r22, 0x65	; 101
     3da:	70 e0       	ldi	r23, 0x00	; 0
     3dc:	89 eb       	ldi	r24, 0xB9	; 185
     3de:	91 e0       	ldi	r25, 0x01	; 1
     3e0:	0e 94 56 07 	call	0xeac	; 0xeac <xTaskCreate>
	xTaskCreate(task3, "T3", 100, NULL, 2, NULL);
     3e4:	02 e0       	ldi	r16, 0x02	; 2
     3e6:	20 e0       	ldi	r18, 0x00	; 0
     3e8:	30 e0       	ldi	r19, 0x00	; 0
     3ea:	44 e6       	ldi	r20, 0x64	; 100
     3ec:	50 e0       	ldi	r21, 0x00	; 0
     3ee:	68 e6       	ldi	r22, 0x68	; 104
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	86 ec       	ldi	r24, 0xC6	; 198
     3f4:	91 e0       	ldi	r25, 0x01	; 1
     3f6:	0e 94 56 07 	call	0xeac	; 0xeac <xTaskCreate>
	vTaskStartScheduler();
     3fa:	0e 94 aa 07 	call	0xf54	; 0xf54 <vTaskStartScheduler>
	
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	0f 91       	pop	r16
     404:	ff 90       	pop	r15
     406:	ef 90       	pop	r14
     408:	08 95       	ret

0000040a <DIO_voidSetPinDirection>:
	}
}

void DIO_voidSetPinDirection(uint8 copy_u8PortID, uint8 copy_u8PinID, uint8 Copy_u8PinDir){
	
	if(Copy_u8PinDir == INPUT){ // input
     40a:	41 11       	cpse	r20, r1
     40c:	3b c0       	rjmp	.+118    	; 0x484 <DIO_voidSetPinDirection+0x7a>
		switch(copy_u8PortID){
     40e:	82 34       	cpi	r24, 0x42	; 66
     410:	a9 f0       	breq	.+42     	; 0x43c <DIO_voidSetPinDirection+0x32>
     412:	18 f4       	brcc	.+6      	; 0x41a <DIO_voidSetPinDirection+0x10>
     414:	81 34       	cpi	r24, 0x41	; 65
     416:	31 f0       	breq	.+12     	; 0x424 <DIO_voidSetPinDirection+0x1a>
     418:	08 95       	ret
     41a:	83 34       	cpi	r24, 0x43	; 67
     41c:	d9 f0       	breq	.+54     	; 0x454 <DIO_voidSetPinDirection+0x4a>
     41e:	84 34       	cpi	r24, 0x44	; 68
     420:	29 f1       	breq	.+74     	; 0x46c <DIO_voidSetPinDirection+0x62>
     422:	08 95       	ret
			case portA: CLRBIT(DDRA, copy_u8PinID); break;
     424:	2a b3       	in	r18, 0x1a	; 26
     426:	81 e0       	ldi	r24, 0x01	; 1
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	02 c0       	rjmp	.+4      	; 0x430 <DIO_voidSetPinDirection+0x26>
     42c:	88 0f       	add	r24, r24
     42e:	99 1f       	adc	r25, r25
     430:	6a 95       	dec	r22
     432:	e2 f7       	brpl	.-8      	; 0x42c <DIO_voidSetPinDirection+0x22>
     434:	80 95       	com	r24
     436:	82 23       	and	r24, r18
     438:	8a bb       	out	0x1a, r24	; 26
     43a:	08 95       	ret
			case portB: CLRBIT(DDRB, copy_u8PinID); break;
     43c:	27 b3       	in	r18, 0x17	; 23
     43e:	81 e0       	ldi	r24, 0x01	; 1
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	02 c0       	rjmp	.+4      	; 0x448 <DIO_voidSetPinDirection+0x3e>
     444:	88 0f       	add	r24, r24
     446:	99 1f       	adc	r25, r25
     448:	6a 95       	dec	r22
     44a:	e2 f7       	brpl	.-8      	; 0x444 <DIO_voidSetPinDirection+0x3a>
     44c:	80 95       	com	r24
     44e:	82 23       	and	r24, r18
     450:	87 bb       	out	0x17, r24	; 23
     452:	08 95       	ret
			case portC: CLRBIT(DDRC, copy_u8PinID); break;
     454:	24 b3       	in	r18, 0x14	; 20
     456:	81 e0       	ldi	r24, 0x01	; 1
     458:	90 e0       	ldi	r25, 0x00	; 0
     45a:	02 c0       	rjmp	.+4      	; 0x460 <DIO_voidSetPinDirection+0x56>
     45c:	88 0f       	add	r24, r24
     45e:	99 1f       	adc	r25, r25
     460:	6a 95       	dec	r22
     462:	e2 f7       	brpl	.-8      	; 0x45c <DIO_voidSetPinDirection+0x52>
     464:	80 95       	com	r24
     466:	82 23       	and	r24, r18
     468:	84 bb       	out	0x14, r24	; 20
     46a:	08 95       	ret
			case portD: CLRBIT(DDRD, copy_u8PinID); break;
     46c:	21 b3       	in	r18, 0x11	; 17
     46e:	81 e0       	ldi	r24, 0x01	; 1
     470:	90 e0       	ldi	r25, 0x00	; 0
     472:	02 c0       	rjmp	.+4      	; 0x478 <DIO_voidSetPinDirection+0x6e>
     474:	88 0f       	add	r24, r24
     476:	99 1f       	adc	r25, r25
     478:	6a 95       	dec	r22
     47a:	e2 f7       	brpl	.-8      	; 0x474 <DIO_voidSetPinDirection+0x6a>
     47c:	80 95       	com	r24
     47e:	82 23       	and	r24, r18
     480:	81 bb       	out	0x11, r24	; 17
     482:	08 95       	ret
		}
	}
	else{ // output
		switch(copy_u8PortID){
     484:	82 34       	cpi	r24, 0x42	; 66
     486:	a1 f0       	breq	.+40     	; 0x4b0 <DIO_voidSetPinDirection+0xa6>
     488:	18 f4       	brcc	.+6      	; 0x490 <DIO_voidSetPinDirection+0x86>
     48a:	81 34       	cpi	r24, 0x41	; 65
     48c:	31 f0       	breq	.+12     	; 0x49a <DIO_voidSetPinDirection+0x90>
     48e:	08 95       	ret
     490:	83 34       	cpi	r24, 0x43	; 67
     492:	c9 f0       	breq	.+50     	; 0x4c6 <DIO_voidSetPinDirection+0xbc>
     494:	84 34       	cpi	r24, 0x44	; 68
     496:	11 f1       	breq	.+68     	; 0x4dc <DIO_voidSetPinDirection+0xd2>
     498:	08 95       	ret
			case portA: SETBIT(DDRA, copy_u8PinID); break;
     49a:	2a b3       	in	r18, 0x1a	; 26
     49c:	81 e0       	ldi	r24, 0x01	; 1
     49e:	90 e0       	ldi	r25, 0x00	; 0
     4a0:	02 c0       	rjmp	.+4      	; 0x4a6 <DIO_voidSetPinDirection+0x9c>
     4a2:	88 0f       	add	r24, r24
     4a4:	99 1f       	adc	r25, r25
     4a6:	6a 95       	dec	r22
     4a8:	e2 f7       	brpl	.-8      	; 0x4a2 <DIO_voidSetPinDirection+0x98>
     4aa:	82 2b       	or	r24, r18
     4ac:	8a bb       	out	0x1a, r24	; 26
     4ae:	08 95       	ret
			case portB: SETBIT(DDRB, copy_u8PinID); break;
     4b0:	27 b3       	in	r18, 0x17	; 23
     4b2:	81 e0       	ldi	r24, 0x01	; 1
     4b4:	90 e0       	ldi	r25, 0x00	; 0
     4b6:	02 c0       	rjmp	.+4      	; 0x4bc <DIO_voidSetPinDirection+0xb2>
     4b8:	88 0f       	add	r24, r24
     4ba:	99 1f       	adc	r25, r25
     4bc:	6a 95       	dec	r22
     4be:	e2 f7       	brpl	.-8      	; 0x4b8 <DIO_voidSetPinDirection+0xae>
     4c0:	82 2b       	or	r24, r18
     4c2:	87 bb       	out	0x17, r24	; 23
     4c4:	08 95       	ret
			case portC: SETBIT(DDRC, copy_u8PinID); break;
     4c6:	24 b3       	in	r18, 0x14	; 20
     4c8:	81 e0       	ldi	r24, 0x01	; 1
     4ca:	90 e0       	ldi	r25, 0x00	; 0
     4cc:	02 c0       	rjmp	.+4      	; 0x4d2 <DIO_voidSetPinDirection+0xc8>
     4ce:	88 0f       	add	r24, r24
     4d0:	99 1f       	adc	r25, r25
     4d2:	6a 95       	dec	r22
     4d4:	e2 f7       	brpl	.-8      	; 0x4ce <DIO_voidSetPinDirection+0xc4>
     4d6:	82 2b       	or	r24, r18
     4d8:	84 bb       	out	0x14, r24	; 20
     4da:	08 95       	ret
			case portD: SETBIT(DDRD, copy_u8PinID); break;
     4dc:	21 b3       	in	r18, 0x11	; 17
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <DIO_voidSetPinDirection+0xde>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	6a 95       	dec	r22
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <DIO_voidSetPinDirection+0xda>
     4ec:	82 2b       	or	r24, r18
     4ee:	81 bb       	out	0x11, r24	; 17
     4f0:	08 95       	ret

000004f2 <__vector_1>:
	}
}

void __vector_1() __attribute__((signal));

void __vector_1(){
     4f2:	1f 92       	push	r1
     4f4:	0f 92       	push	r0
     4f6:	0f b6       	in	r0, 0x3f	; 63
     4f8:	0f 92       	push	r0
     4fa:	11 24       	eor	r1, r1
     4fc:	2f 93       	push	r18
     4fe:	3f 93       	push	r19
     500:	4f 93       	push	r20
     502:	5f 93       	push	r21
     504:	6f 93       	push	r22
     506:	7f 93       	push	r23
     508:	8f 93       	push	r24
     50a:	9f 93       	push	r25
     50c:	af 93       	push	r26
     50e:	bf 93       	push	r27
     510:	ef 93       	push	r30
     512:	ff 93       	push	r31
	ptr_EXT1();
     514:	e0 91 74 00 	lds	r30, 0x0074	; 0x800074 <ptr_EXT1>
     518:	f0 91 75 00 	lds	r31, 0x0075	; 0x800075 <ptr_EXT1+0x1>
     51c:	09 95       	icall
}
     51e:	ff 91       	pop	r31
     520:	ef 91       	pop	r30
     522:	bf 91       	pop	r27
     524:	af 91       	pop	r26
     526:	9f 91       	pop	r25
     528:	8f 91       	pop	r24
     52a:	7f 91       	pop	r23
     52c:	6f 91       	pop	r22
     52e:	5f 91       	pop	r21
     530:	4f 91       	pop	r20
     532:	3f 91       	pop	r19
     534:	2f 91       	pop	r18
     536:	0f 90       	pop	r0
     538:	0f be       	out	0x3f, r0	; 63
     53a:	0f 90       	pop	r0
     53c:	1f 90       	pop	r1
     53e:	18 95       	reti

00000540 <__vector_2>:

void __vector_2() __attribute__((signal));

void __vector_2(){
     540:	1f 92       	push	r1
     542:	0f 92       	push	r0
     544:	0f b6       	in	r0, 0x3f	; 63
     546:	0f 92       	push	r0
     548:	11 24       	eor	r1, r1
     54a:	2f 93       	push	r18
     54c:	3f 93       	push	r19
     54e:	4f 93       	push	r20
     550:	5f 93       	push	r21
     552:	6f 93       	push	r22
     554:	7f 93       	push	r23
     556:	8f 93       	push	r24
     558:	9f 93       	push	r25
     55a:	af 93       	push	r26
     55c:	bf 93       	push	r27
     55e:	ef 93       	push	r30
     560:	ff 93       	push	r31
	ptr_EXT2();
     562:	e0 91 72 00 	lds	r30, 0x0072	; 0x800072 <ptr_EXT2>
     566:	f0 91 73 00 	lds	r31, 0x0073	; 0x800073 <ptr_EXT2+0x1>
     56a:	09 95       	icall
}
     56c:	ff 91       	pop	r31
     56e:	ef 91       	pop	r30
     570:	bf 91       	pop	r27
     572:	af 91       	pop	r26
     574:	9f 91       	pop	r25
     576:	8f 91       	pop	r24
     578:	7f 91       	pop	r23
     57a:	6f 91       	pop	r22
     57c:	5f 91       	pop	r21
     57e:	4f 91       	pop	r20
     580:	3f 91       	pop	r19
     582:	2f 91       	pop	r18
     584:	0f 90       	pop	r0
     586:	0f be       	out	0x3f, r0	; 63
     588:	0f 90       	pop	r0
     58a:	1f 90       	pop	r1
     58c:	18 95       	reti

0000058e <__vector_3>:

void __vector_3() __attribute__((signal));

void __vector_3(){
     58e:	1f 92       	push	r1
     590:	0f 92       	push	r0
     592:	0f b6       	in	r0, 0x3f	; 63
     594:	0f 92       	push	r0
     596:	11 24       	eor	r1, r1
     598:	2f 93       	push	r18
     59a:	3f 93       	push	r19
     59c:	4f 93       	push	r20
     59e:	5f 93       	push	r21
     5a0:	6f 93       	push	r22
     5a2:	7f 93       	push	r23
     5a4:	8f 93       	push	r24
     5a6:	9f 93       	push	r25
     5a8:	af 93       	push	r26
     5aa:	bf 93       	push	r27
     5ac:	ef 93       	push	r30
     5ae:	ff 93       	push	r31
	ptr_EXT3();
     5b0:	e0 91 70 00 	lds	r30, 0x0070	; 0x800070 <__data_end>
     5b4:	f0 91 71 00 	lds	r31, 0x0071	; 0x800071 <__data_end+0x1>
     5b8:	09 95       	icall
     5ba:	ff 91       	pop	r31
     5bc:	ef 91       	pop	r30
     5be:	bf 91       	pop	r27
     5c0:	af 91       	pop	r26
     5c2:	9f 91       	pop	r25
     5c4:	8f 91       	pop	r24
     5c6:	7f 91       	pop	r23
     5c8:	6f 91       	pop	r22
     5ca:	5f 91       	pop	r21
     5cc:	4f 91       	pop	r20
     5ce:	3f 91       	pop	r19
     5d0:	2f 91       	pop	r18
     5d2:	0f 90       	pop	r0
     5d4:	0f be       	out	0x3f, r0	; 63
     5d6:	0f 90       	pop	r0
     5d8:	1f 90       	pop	r1
     5da:	18 95       	reti

000005dc <__vector_11>:
	timer0_disable();
}

void __vector_11() __attribute__((signal));

void __vector_11(){
     5dc:	1f 92       	push	r1
     5de:	0f 92       	push	r0
     5e0:	0f b6       	in	r0, 0x3f	; 63
     5e2:	0f 92       	push	r0
     5e4:	11 24       	eor	r1, r1
     5e6:	2f 93       	push	r18
     5e8:	3f 93       	push	r19
     5ea:	4f 93       	push	r20
     5ec:	5f 93       	push	r21
     5ee:	6f 93       	push	r22
     5f0:	7f 93       	push	r23
     5f2:	8f 93       	push	r24
     5f4:	9f 93       	push	r25
     5f6:	af 93       	push	r26
     5f8:	bf 93       	push	r27
     5fa:	ef 93       	push	r30
     5fc:	ff 93       	push	r31
	ptr_t0();
     5fe:	e0 91 76 00 	lds	r30, 0x0076	; 0x800076 <ptr_t0>
     602:	f0 91 77 00 	lds	r31, 0x0077	; 0x800077 <ptr_t0+0x1>
     606:	09 95       	icall
}
     608:	ff 91       	pop	r31
     60a:	ef 91       	pop	r30
     60c:	bf 91       	pop	r27
     60e:	af 91       	pop	r26
     610:	9f 91       	pop	r25
     612:	8f 91       	pop	r24
     614:	7f 91       	pop	r23
     616:	6f 91       	pop	r22
     618:	5f 91       	pop	r21
     61a:	4f 91       	pop	r20
     61c:	3f 91       	pop	r19
     61e:	2f 91       	pop	r18
     620:	0f 90       	pop	r0
     622:	0f be       	out	0x3f, r0	; 63
     624:	0f 90       	pop	r0
     626:	1f 90       	pop	r1
     628:	18 95       	reti

0000062a <__vector_10>:

void __vector_10() __attribute__((signal));

void __vector_10(){
     62a:	1f 92       	push	r1
     62c:	0f 92       	push	r0
     62e:	0f b6       	in	r0, 0x3f	; 63
     630:	0f 92       	push	r0
     632:	11 24       	eor	r1, r1
     634:	2f 93       	push	r18
     636:	3f 93       	push	r19
     638:	4f 93       	push	r20
     63a:	5f 93       	push	r21
     63c:	6f 93       	push	r22
     63e:	7f 93       	push	r23
     640:	8f 93       	push	r24
     642:	9f 93       	push	r25
     644:	af 93       	push	r26
     646:	bf 93       	push	r27
     648:	ef 93       	push	r30
     64a:	ff 93       	push	r31
	ptr_t0();
     64c:	e0 91 76 00 	lds	r30, 0x0076	; 0x800076 <ptr_t0>
     650:	f0 91 77 00 	lds	r31, 0x0077	; 0x800077 <ptr_t0+0x1>
     654:	09 95       	icall
}
     656:	ff 91       	pop	r31
     658:	ef 91       	pop	r30
     65a:	bf 91       	pop	r27
     65c:	af 91       	pop	r26
     65e:	9f 91       	pop	r25
     660:	8f 91       	pop	r24
     662:	7f 91       	pop	r23
     664:	6f 91       	pop	r22
     666:	5f 91       	pop	r21
     668:	4f 91       	pop	r20
     66a:	3f 91       	pop	r19
     66c:	2f 91       	pop	r18
     66e:	0f 90       	pop	r0
     670:	0f be       	out	0x3f, r0	; 63
     672:	0f 90       	pop	r0
     674:	1f 90       	pop	r1
     676:	18 95       	reti

00000678 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     678:	ed e7       	ldi	r30, 0x7D	; 125
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	82 e8       	ldi	r24, 0x82	; 130
     67e:	90 e0       	ldi	r25, 0x00	; 0
     680:	91 83       	std	Z+1, r25	; 0x01
     682:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     684:	13 82       	std	Z+3, r1	; 0x03
     686:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     688:	e9 e7       	ldi	r30, 0x79	; 121
     68a:	f0 e0       	ldi	r31, 0x00	; 0
     68c:	87 ee       	ldi	r24, 0xE7	; 231
     68e:	93 e0       	ldi	r25, 0x03	; 3
     690:	93 83       	std	Z+3, r25	; 0x03
     692:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     694:	11 82       	std	Z+1, r1	; 0x01
     696:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     698:	a1 e8       	ldi	r26, 0x81	; 129
     69a:	b0 e0       	ldi	r27, 0x00	; 0
     69c:	14 96       	adiw	r26, 0x04	; 4
     69e:	9c 93       	st	X, r25
     6a0:	8e 93       	st	-X, r24
     6a2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     6a4:	12 96       	adiw	r26, 0x02	; 2
     6a6:	fc 93       	st	X, r31
     6a8:	ee 93       	st	-X, r30
     6aa:	11 97       	sbiw	r26, 0x01	; 1
     6ac:	08 95       	ret

000006ae <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     6ae:	0f 93       	push	r16
     6b0:	1f 93       	push	r17
     6b2:	cf 93       	push	r28
     6b4:	df 93       	push	r29
     6b6:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     6b8:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     6bc:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <xHeapHasBeenInitialised.2079>
     6c0:	81 11       	cpse	r24, r1
     6c2:	05 c0       	rjmp	.+10     	; 0x6ce <pvPortMalloc+0x20>
		{
			prvHeapInit();
     6c4:	0e 94 3c 03 	call	0x678	; 0x678 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     6c8:	81 e0       	ldi	r24, 0x01	; 1
     6ca:	80 93 78 00 	sts	0x0078, r24	; 0x800078 <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     6ce:	20 97       	sbiw	r28, 0x00	; 0
     6d0:	09 f0       	breq	.+2      	; 0x6d4 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     6d2:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     6d4:	ce 01       	movw	r24, r28
     6d6:	01 97       	sbiw	r24, 0x01	; 1
     6d8:	86 3e       	cpi	r24, 0xE6	; 230
     6da:	93 40       	sbci	r25, 0x03	; 3
     6dc:	08 f0       	brcs	.+2      	; 0x6e0 <pvPortMalloc+0x32>
     6de:	56 c0       	rjmp	.+172    	; 0x78c <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     6e0:	e0 91 7d 00 	lds	r30, 0x007D	; 0x80007d <xStart>
     6e4:	f0 91 7e 00 	lds	r31, 0x007E	; 0x80007e <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     6e8:	ad e7       	ldi	r26, 0x7D	; 125
     6ea:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6ec:	02 c0       	rjmp	.+4      	; 0x6f2 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     6ee:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     6f0:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6f2:	82 81       	ldd	r24, Z+2	; 0x02
     6f4:	93 81       	ldd	r25, Z+3	; 0x03
     6f6:	8c 17       	cp	r24, r28
     6f8:	9d 07       	cpc	r25, r29
     6fa:	20 f4       	brcc	.+8      	; 0x704 <pvPortMalloc+0x56>
     6fc:	80 81       	ld	r24, Z
     6fe:	91 81       	ldd	r25, Z+1	; 0x01
     700:	00 97       	sbiw	r24, 0x00	; 0
     702:	a9 f7       	brne	.-22     	; 0x6ee <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     704:	80 e0       	ldi	r24, 0x00	; 0
     706:	e9 37       	cpi	r30, 0x79	; 121
     708:	f8 07       	cpc	r31, r24
     70a:	09 f4       	brne	.+2      	; 0x70e <pvPortMalloc+0x60>
     70c:	42 c0       	rjmp	.+132    	; 0x792 <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     70e:	0d 91       	ld	r16, X+
     710:	1c 91       	ld	r17, X
     712:	11 97       	sbiw	r26, 0x01	; 1
     714:	0c 5f       	subi	r16, 0xFC	; 252
     716:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     718:	80 81       	ld	r24, Z
     71a:	91 81       	ldd	r25, Z+1	; 0x01
     71c:	8d 93       	st	X+, r24
     71e:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     720:	82 81       	ldd	r24, Z+2	; 0x02
     722:	93 81       	ldd	r25, Z+3	; 0x03
     724:	8c 1b       	sub	r24, r28
     726:	9d 0b       	sbc	r25, r29
     728:	89 30       	cpi	r24, 0x09	; 9
     72a:	91 05       	cpc	r25, r1
     72c:	10 f1       	brcs	.+68     	; 0x772 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     72e:	af 01       	movw	r20, r30
     730:	4c 0f       	add	r20, r28
     732:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     734:	da 01       	movw	r26, r20
     736:	13 96       	adiw	r26, 0x03	; 3
     738:	9c 93       	st	X, r25
     73a:	8e 93       	st	-X, r24
     73c:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     73e:	d3 83       	std	Z+3, r29	; 0x03
     740:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     742:	12 96       	adiw	r26, 0x02	; 2
     744:	2d 91       	ld	r18, X+
     746:	3c 91       	ld	r19, X
     748:	13 97       	sbiw	r26, 0x03	; 3
     74a:	6d e7       	ldi	r22, 0x7D	; 125
     74c:	70 e0       	ldi	r23, 0x00	; 0
     74e:	01 c0       	rjmp	.+2      	; 0x752 <pvPortMalloc+0xa4>
     750:	bd 01       	movw	r22, r26
     752:	eb 01       	movw	r28, r22
     754:	a8 81       	ld	r26, Y
     756:	b9 81       	ldd	r27, Y+1	; 0x01
     758:	12 96       	adiw	r26, 0x02	; 2
     75a:	8d 91       	ld	r24, X+
     75c:	9c 91       	ld	r25, X
     75e:	13 97       	sbiw	r26, 0x03	; 3
     760:	82 17       	cp	r24, r18
     762:	93 07       	cpc	r25, r19
     764:	a8 f3       	brcs	.-22     	; 0x750 <pvPortMalloc+0xa2>
     766:	ea 01       	movw	r28, r20
     768:	b9 83       	std	Y+1, r27	; 0x01
     76a:	a8 83       	st	Y, r26
     76c:	db 01       	movw	r26, r22
     76e:	4d 93       	st	X+, r20
     770:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     772:	22 81       	ldd	r18, Z+2	; 0x02
     774:	33 81       	ldd	r19, Z+3	; 0x03
     776:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     77a:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     77e:	82 1b       	sub	r24, r18
     780:	93 0b       	sbc	r25, r19
     782:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     786:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     78a:	05 c0       	rjmp	.+10     	; 0x796 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     78c:	00 e0       	ldi	r16, 0x00	; 0
     78e:	10 e0       	ldi	r17, 0x00	; 0
     790:	02 c0       	rjmp	.+4      	; 0x796 <pvPortMalloc+0xe8>
     792:	00 e0       	ldi	r16, 0x00	; 0
     794:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     796:	0e 94 94 08 	call	0x1128	; 0x1128 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     79a:	c8 01       	movw	r24, r16
     79c:	df 91       	pop	r29
     79e:	cf 91       	pop	r28
     7a0:	1f 91       	pop	r17
     7a2:	0f 91       	pop	r16
     7a4:	08 95       	ret

000007a6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7a6:	0f 93       	push	r16
     7a8:	1f 93       	push	r17
     7aa:	cf 93       	push	r28
     7ac:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     7ae:	00 97       	sbiw	r24, 0x00	; 0
     7b0:	41 f1       	breq	.+80     	; 0x802 <__DATA_REGION_LENGTH__+0x2>
     7b2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     7b4:	8c 01       	movw	r16, r24
     7b6:	04 50       	subi	r16, 0x04	; 4
     7b8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     7ba:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     7be:	f8 01       	movw	r30, r16
     7c0:	42 81       	ldd	r20, Z+2	; 0x02
     7c2:	53 81       	ldd	r21, Z+3	; 0x03
     7c4:	ad e7       	ldi	r26, 0x7D	; 125
     7c6:	b0 e0       	ldi	r27, 0x00	; 0
     7c8:	01 c0       	rjmp	.+2      	; 0x7cc <vPortFree+0x26>
     7ca:	df 01       	movw	r26, r30
     7cc:	ed 91       	ld	r30, X+
     7ce:	fc 91       	ld	r31, X
     7d0:	11 97       	sbiw	r26, 0x01	; 1
     7d2:	22 81       	ldd	r18, Z+2	; 0x02
     7d4:	33 81       	ldd	r19, Z+3	; 0x03
     7d6:	24 17       	cp	r18, r20
     7d8:	35 07       	cpc	r19, r21
     7da:	b8 f3       	brcs	.-18     	; 0x7ca <vPortFree+0x24>
     7dc:	24 97       	sbiw	r28, 0x04	; 4
     7de:	f9 83       	std	Y+1, r31	; 0x01
     7e0:	e8 83       	st	Y, r30
     7e2:	0d 93       	st	X+, r16
     7e4:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     7e6:	8a 81       	ldd	r24, Y+2	; 0x02
     7e8:	9b 81       	ldd	r25, Y+3	; 0x03
     7ea:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     7ee:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     7f2:	82 0f       	add	r24, r18
     7f4:	93 1f       	adc	r25, r19
     7f6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     7fa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     7fe:	0e 94 94 08 	call	0x1128	; 0x1128 <xTaskResumeAll>
	}
}
     802:	df 91       	pop	r29
     804:	cf 91       	pop	r28
     806:	1f 91       	pop	r17
     808:	0f 91       	pop	r16
     80a:	08 95       	ret

0000080c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     80c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     80e:	03 96       	adiw	r24, 0x03	; 3
     810:	92 83       	std	Z+2, r25	; 0x02
     812:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     814:	2f ef       	ldi	r18, 0xFF	; 255
     816:	3f ef       	ldi	r19, 0xFF	; 255
     818:	34 83       	std	Z+4, r19	; 0x04
     81a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     81c:	96 83       	std	Z+6, r25	; 0x06
     81e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     820:	90 87       	std	Z+8, r25	; 0x08
     822:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     824:	10 82       	st	Z, r1
     826:	08 95       	ret

00000828 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     828:	fc 01       	movw	r30, r24
     82a:	11 86       	std	Z+9, r1	; 0x09
     82c:	10 86       	std	Z+8, r1	; 0x08
     82e:	08 95       	ret

00000830 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	9c 01       	movw	r18, r24
     836:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     838:	dc 01       	movw	r26, r24
     83a:	11 96       	adiw	r26, 0x01	; 1
     83c:	cd 91       	ld	r28, X+
     83e:	dc 91       	ld	r29, X
     840:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     842:	d3 83       	std	Z+3, r29	; 0x03
     844:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     846:	8c 81       	ldd	r24, Y+4	; 0x04
     848:	9d 81       	ldd	r25, Y+5	; 0x05
     84a:	95 83       	std	Z+5, r25	; 0x05
     84c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     84e:	8c 81       	ldd	r24, Y+4	; 0x04
     850:	9d 81       	ldd	r25, Y+5	; 0x05
     852:	dc 01       	movw	r26, r24
     854:	13 96       	adiw	r26, 0x03	; 3
     856:	7c 93       	st	X, r23
     858:	6e 93       	st	-X, r22
     85a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     85c:	7d 83       	std	Y+5, r23	; 0x05
     85e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     860:	31 87       	std	Z+9, r19	; 0x09
     862:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     864:	f9 01       	movw	r30, r18
     866:	80 81       	ld	r24, Z
     868:	8f 5f       	subi	r24, 0xFF	; 255
     86a:	80 83       	st	Z, r24
}
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	08 95       	ret

00000872 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     872:	cf 93       	push	r28
     874:	df 93       	push	r29
     876:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     878:	48 81       	ld	r20, Y
     87a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     87c:	4f 3f       	cpi	r20, 0xFF	; 255
     87e:	2f ef       	ldi	r18, 0xFF	; 255
     880:	52 07       	cpc	r21, r18
     882:	21 f4       	brne	.+8      	; 0x88c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     884:	fc 01       	movw	r30, r24
     886:	a7 81       	ldd	r26, Z+7	; 0x07
     888:	b0 85       	ldd	r27, Z+8	; 0x08
     88a:	0d c0       	rjmp	.+26     	; 0x8a6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     88c:	dc 01       	movw	r26, r24
     88e:	13 96       	adiw	r26, 0x03	; 3
     890:	01 c0       	rjmp	.+2      	; 0x894 <vListInsert+0x22>
     892:	df 01       	movw	r26, r30
     894:	12 96       	adiw	r26, 0x02	; 2
     896:	ed 91       	ld	r30, X+
     898:	fc 91       	ld	r31, X
     89a:	13 97       	sbiw	r26, 0x03	; 3
     89c:	20 81       	ld	r18, Z
     89e:	31 81       	ldd	r19, Z+1	; 0x01
     8a0:	42 17       	cp	r20, r18
     8a2:	53 07       	cpc	r21, r19
     8a4:	b0 f7       	brcc	.-20     	; 0x892 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     8a6:	12 96       	adiw	r26, 0x02	; 2
     8a8:	ed 91       	ld	r30, X+
     8aa:	fc 91       	ld	r31, X
     8ac:	13 97       	sbiw	r26, 0x03	; 3
     8ae:	fb 83       	std	Y+3, r31	; 0x03
     8b0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     8b2:	d5 83       	std	Z+5, r29	; 0x05
     8b4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     8b6:	bd 83       	std	Y+5, r27	; 0x05
     8b8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     8ba:	13 96       	adiw	r26, 0x03	; 3
     8bc:	dc 93       	st	X, r29
     8be:	ce 93       	st	-X, r28
     8c0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     8c2:	99 87       	std	Y+9, r25	; 0x09
     8c4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8c6:	fc 01       	movw	r30, r24
     8c8:	20 81       	ld	r18, Z
     8ca:	2f 5f       	subi	r18, 0xFF	; 255
     8cc:	20 83       	st	Z, r18
}
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	08 95       	ret

000008d4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     8d4:	cf 93       	push	r28
     8d6:	df 93       	push	r29
     8d8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     8da:	a0 85       	ldd	r26, Z+8	; 0x08
     8dc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     8de:	c2 81       	ldd	r28, Z+2	; 0x02
     8e0:	d3 81       	ldd	r29, Z+3	; 0x03
     8e2:	84 81       	ldd	r24, Z+4	; 0x04
     8e4:	95 81       	ldd	r25, Z+5	; 0x05
     8e6:	9d 83       	std	Y+5, r25	; 0x05
     8e8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     8ea:	c4 81       	ldd	r28, Z+4	; 0x04
     8ec:	d5 81       	ldd	r29, Z+5	; 0x05
     8ee:	82 81       	ldd	r24, Z+2	; 0x02
     8f0:	93 81       	ldd	r25, Z+3	; 0x03
     8f2:	9b 83       	std	Y+3, r25	; 0x03
     8f4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     8f6:	11 96       	adiw	r26, 0x01	; 1
     8f8:	8d 91       	ld	r24, X+
     8fa:	9c 91       	ld	r25, X
     8fc:	12 97       	sbiw	r26, 0x02	; 2
     8fe:	e8 17       	cp	r30, r24
     900:	f9 07       	cpc	r31, r25
     902:	31 f4       	brne	.+12     	; 0x910 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     904:	84 81       	ldd	r24, Z+4	; 0x04
     906:	95 81       	ldd	r25, Z+5	; 0x05
     908:	12 96       	adiw	r26, 0x02	; 2
     90a:	9c 93       	st	X, r25
     90c:	8e 93       	st	-X, r24
     90e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     910:	11 86       	std	Z+9, r1	; 0x09
     912:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     914:	8c 91       	ld	r24, X
     916:	81 50       	subi	r24, 0x01	; 1
     918:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     91a:	df 91       	pop	r29
     91c:	cf 91       	pop	r28
     91e:	08 95       	ret

00000920 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     920:	1b bc       	out	0x2b, r1	; 43
     922:	89 ef       	ldi	r24, 0xF9	; 249
     924:	8a bd       	out	0x2a, r24	; 42
     926:	8b e0       	ldi	r24, 0x0B	; 11
     928:	8e bd       	out	0x2e, r24	; 46
     92a:	89 b7       	in	r24, 0x39	; 57
     92c:	80 61       	ori	r24, 0x10	; 16
     92e:	89 bf       	out	0x39, r24	; 57
     930:	08 95       	ret

00000932 <pxPortInitialiseStack>:
     932:	31 e1       	ldi	r19, 0x11	; 17
     934:	fc 01       	movw	r30, r24
     936:	30 83       	st	Z, r19
     938:	31 97       	sbiw	r30, 0x01	; 1
     93a:	22 e2       	ldi	r18, 0x22	; 34
     93c:	20 83       	st	Z, r18
     93e:	31 97       	sbiw	r30, 0x01	; 1
     940:	a3 e3       	ldi	r26, 0x33	; 51
     942:	a0 83       	st	Z, r26
     944:	31 97       	sbiw	r30, 0x01	; 1
     946:	60 83       	st	Z, r22
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	70 83       	st	Z, r23
     94c:	31 97       	sbiw	r30, 0x01	; 1
     94e:	10 82       	st	Z, r1
     950:	31 97       	sbiw	r30, 0x01	; 1
     952:	60 e8       	ldi	r22, 0x80	; 128
     954:	60 83       	st	Z, r22
     956:	31 97       	sbiw	r30, 0x01	; 1
     958:	10 82       	st	Z, r1
     95a:	31 97       	sbiw	r30, 0x01	; 1
     95c:	62 e0       	ldi	r22, 0x02	; 2
     95e:	60 83       	st	Z, r22
     960:	31 97       	sbiw	r30, 0x01	; 1
     962:	63 e0       	ldi	r22, 0x03	; 3
     964:	60 83       	st	Z, r22
     966:	31 97       	sbiw	r30, 0x01	; 1
     968:	64 e0       	ldi	r22, 0x04	; 4
     96a:	60 83       	st	Z, r22
     96c:	31 97       	sbiw	r30, 0x01	; 1
     96e:	65 e0       	ldi	r22, 0x05	; 5
     970:	60 83       	st	Z, r22
     972:	31 97       	sbiw	r30, 0x01	; 1
     974:	66 e0       	ldi	r22, 0x06	; 6
     976:	60 83       	st	Z, r22
     978:	31 97       	sbiw	r30, 0x01	; 1
     97a:	67 e0       	ldi	r22, 0x07	; 7
     97c:	60 83       	st	Z, r22
     97e:	31 97       	sbiw	r30, 0x01	; 1
     980:	68 e0       	ldi	r22, 0x08	; 8
     982:	60 83       	st	Z, r22
     984:	31 97       	sbiw	r30, 0x01	; 1
     986:	69 e0       	ldi	r22, 0x09	; 9
     988:	60 83       	st	Z, r22
     98a:	31 97       	sbiw	r30, 0x01	; 1
     98c:	60 e1       	ldi	r22, 0x10	; 16
     98e:	60 83       	st	Z, r22
     990:	31 97       	sbiw	r30, 0x01	; 1
     992:	30 83       	st	Z, r19
     994:	31 97       	sbiw	r30, 0x01	; 1
     996:	32 e1       	ldi	r19, 0x12	; 18
     998:	30 83       	st	Z, r19
     99a:	31 97       	sbiw	r30, 0x01	; 1
     99c:	33 e1       	ldi	r19, 0x13	; 19
     99e:	30 83       	st	Z, r19
     9a0:	31 97       	sbiw	r30, 0x01	; 1
     9a2:	34 e1       	ldi	r19, 0x14	; 20
     9a4:	30 83       	st	Z, r19
     9a6:	31 97       	sbiw	r30, 0x01	; 1
     9a8:	35 e1       	ldi	r19, 0x15	; 21
     9aa:	30 83       	st	Z, r19
     9ac:	31 97       	sbiw	r30, 0x01	; 1
     9ae:	36 e1       	ldi	r19, 0x16	; 22
     9b0:	30 83       	st	Z, r19
     9b2:	31 97       	sbiw	r30, 0x01	; 1
     9b4:	37 e1       	ldi	r19, 0x17	; 23
     9b6:	30 83       	st	Z, r19
     9b8:	31 97       	sbiw	r30, 0x01	; 1
     9ba:	38 e1       	ldi	r19, 0x18	; 24
     9bc:	30 83       	st	Z, r19
     9be:	31 97       	sbiw	r30, 0x01	; 1
     9c0:	39 e1       	ldi	r19, 0x19	; 25
     9c2:	30 83       	st	Z, r19
     9c4:	31 97       	sbiw	r30, 0x01	; 1
     9c6:	30 e2       	ldi	r19, 0x20	; 32
     9c8:	30 83       	st	Z, r19
     9ca:	31 97       	sbiw	r30, 0x01	; 1
     9cc:	31 e2       	ldi	r19, 0x21	; 33
     9ce:	30 83       	st	Z, r19
     9d0:	31 97       	sbiw	r30, 0x01	; 1
     9d2:	20 83       	st	Z, r18
     9d4:	31 97       	sbiw	r30, 0x01	; 1
     9d6:	23 e2       	ldi	r18, 0x23	; 35
     9d8:	20 83       	st	Z, r18
     9da:	31 97       	sbiw	r30, 0x01	; 1
     9dc:	40 83       	st	Z, r20
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	50 83       	st	Z, r21
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	26 e2       	ldi	r18, 0x26	; 38
     9e6:	20 83       	st	Z, r18
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	27 e2       	ldi	r18, 0x27	; 39
     9ec:	20 83       	st	Z, r18
     9ee:	31 97       	sbiw	r30, 0x01	; 1
     9f0:	28 e2       	ldi	r18, 0x28	; 40
     9f2:	20 83       	st	Z, r18
     9f4:	31 97       	sbiw	r30, 0x01	; 1
     9f6:	29 e2       	ldi	r18, 0x29	; 41
     9f8:	20 83       	st	Z, r18
     9fa:	31 97       	sbiw	r30, 0x01	; 1
     9fc:	20 e3       	ldi	r18, 0x30	; 48
     9fe:	20 83       	st	Z, r18
     a00:	31 97       	sbiw	r30, 0x01	; 1
     a02:	21 e3       	ldi	r18, 0x31	; 49
     a04:	20 83       	st	Z, r18
     a06:	86 97       	sbiw	r24, 0x26	; 38
     a08:	08 95       	ret

00000a0a <xPortStartScheduler>:
     a0a:	0e 94 90 04 	call	0x920	; 0x920 <prvSetupTimerInterrupt>
     a0e:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     a12:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     a16:	cd 91       	ld	r28, X+
     a18:	cd bf       	out	0x3d, r28	; 61
     a1a:	dd 91       	ld	r29, X+
     a1c:	de bf       	out	0x3e, r29	; 62
     a1e:	ff 91       	pop	r31
     a20:	ef 91       	pop	r30
     a22:	df 91       	pop	r29
     a24:	cf 91       	pop	r28
     a26:	bf 91       	pop	r27
     a28:	af 91       	pop	r26
     a2a:	9f 91       	pop	r25
     a2c:	8f 91       	pop	r24
     a2e:	7f 91       	pop	r23
     a30:	6f 91       	pop	r22
     a32:	5f 91       	pop	r21
     a34:	4f 91       	pop	r20
     a36:	3f 91       	pop	r19
     a38:	2f 91       	pop	r18
     a3a:	1f 91       	pop	r17
     a3c:	0f 91       	pop	r16
     a3e:	ff 90       	pop	r15
     a40:	ef 90       	pop	r14
     a42:	df 90       	pop	r13
     a44:	cf 90       	pop	r12
     a46:	bf 90       	pop	r11
     a48:	af 90       	pop	r10
     a4a:	9f 90       	pop	r9
     a4c:	8f 90       	pop	r8
     a4e:	7f 90       	pop	r7
     a50:	6f 90       	pop	r6
     a52:	5f 90       	pop	r5
     a54:	4f 90       	pop	r4
     a56:	3f 90       	pop	r3
     a58:	2f 90       	pop	r2
     a5a:	1f 90       	pop	r1
     a5c:	0f 90       	pop	r0
     a5e:	0f be       	out	0x3f, r0	; 63
     a60:	0f 90       	pop	r0
     a62:	08 95       	ret
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	08 95       	ret

00000a68 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     a68:	0f 92       	push	r0
     a6a:	0f b6       	in	r0, 0x3f	; 63
     a6c:	f8 94       	cli
     a6e:	0f 92       	push	r0
     a70:	1f 92       	push	r1
     a72:	11 24       	eor	r1, r1
     a74:	2f 92       	push	r2
     a76:	3f 92       	push	r3
     a78:	4f 92       	push	r4
     a7a:	5f 92       	push	r5
     a7c:	6f 92       	push	r6
     a7e:	7f 92       	push	r7
     a80:	8f 92       	push	r8
     a82:	9f 92       	push	r9
     a84:	af 92       	push	r10
     a86:	bf 92       	push	r11
     a88:	cf 92       	push	r12
     a8a:	df 92       	push	r13
     a8c:	ef 92       	push	r14
     a8e:	ff 92       	push	r15
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	2f 93       	push	r18
     a96:	3f 93       	push	r19
     a98:	4f 93       	push	r20
     a9a:	5f 93       	push	r21
     a9c:	6f 93       	push	r22
     a9e:	7f 93       	push	r23
     aa0:	8f 93       	push	r24
     aa2:	9f 93       	push	r25
     aa4:	af 93       	push	r26
     aa6:	bf 93       	push	r27
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	ef 93       	push	r30
     aae:	ff 93       	push	r31
     ab0:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     ab4:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     ab8:	0d b6       	in	r0, 0x3d	; 61
     aba:	0d 92       	st	X+, r0
     abc:	0e b6       	in	r0, 0x3e	; 62
     abe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ac0:	0e 94 4d 09 	call	0x129a	; 0x129a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ac4:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     ac8:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     acc:	cd 91       	ld	r28, X+
     ace:	cd bf       	out	0x3d, r28	; 61
     ad0:	dd 91       	ld	r29, X+
     ad2:	de bf       	out	0x3e, r29	; 62
     ad4:	ff 91       	pop	r31
     ad6:	ef 91       	pop	r30
     ad8:	df 91       	pop	r29
     ada:	cf 91       	pop	r28
     adc:	bf 91       	pop	r27
     ade:	af 91       	pop	r26
     ae0:	9f 91       	pop	r25
     ae2:	8f 91       	pop	r24
     ae4:	7f 91       	pop	r23
     ae6:	6f 91       	pop	r22
     ae8:	5f 91       	pop	r21
     aea:	4f 91       	pop	r20
     aec:	3f 91       	pop	r19
     aee:	2f 91       	pop	r18
     af0:	1f 91       	pop	r17
     af2:	0f 91       	pop	r16
     af4:	ff 90       	pop	r15
     af6:	ef 90       	pop	r14
     af8:	df 90       	pop	r13
     afa:	cf 90       	pop	r12
     afc:	bf 90       	pop	r11
     afe:	af 90       	pop	r10
     b00:	9f 90       	pop	r9
     b02:	8f 90       	pop	r8
     b04:	7f 90       	pop	r7
     b06:	6f 90       	pop	r6
     b08:	5f 90       	pop	r5
     b0a:	4f 90       	pop	r4
     b0c:	3f 90       	pop	r3
     b0e:	2f 90       	pop	r2
     b10:	1f 90       	pop	r1
     b12:	0f 90       	pop	r0
     b14:	0f be       	out	0x3f, r0	; 63
     b16:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b18:	08 95       	ret

00000b1a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b1a:	0f 92       	push	r0
     b1c:	0f b6       	in	r0, 0x3f	; 63
     b1e:	f8 94       	cli
     b20:	0f 92       	push	r0
     b22:	1f 92       	push	r1
     b24:	11 24       	eor	r1, r1
     b26:	2f 92       	push	r2
     b28:	3f 92       	push	r3
     b2a:	4f 92       	push	r4
     b2c:	5f 92       	push	r5
     b2e:	6f 92       	push	r6
     b30:	7f 92       	push	r7
     b32:	8f 92       	push	r8
     b34:	9f 92       	push	r9
     b36:	af 92       	push	r10
     b38:	bf 92       	push	r11
     b3a:	cf 92       	push	r12
     b3c:	df 92       	push	r13
     b3e:	ef 92       	push	r14
     b40:	ff 92       	push	r15
     b42:	0f 93       	push	r16
     b44:	1f 93       	push	r17
     b46:	2f 93       	push	r18
     b48:	3f 93       	push	r19
     b4a:	4f 93       	push	r20
     b4c:	5f 93       	push	r21
     b4e:	6f 93       	push	r22
     b50:	7f 93       	push	r23
     b52:	8f 93       	push	r24
     b54:	9f 93       	push	r25
     b56:	af 93       	push	r26
     b58:	bf 93       	push	r27
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
     b5e:	ef 93       	push	r30
     b60:	ff 93       	push	r31
     b62:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     b66:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     b6a:	0d b6       	in	r0, 0x3d	; 61
     b6c:	0d 92       	st	X+, r0
     b6e:	0e b6       	in	r0, 0x3e	; 62
     b70:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     b72:	0e 94 da 07 	call	0xfb4	; 0xfb4 <xTaskIncrementTick>
     b76:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     b78:	0e 94 4d 09 	call	0x129a	; 0x129a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     b7c:	a0 91 f1 04 	lds	r26, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     b80:	b0 91 f2 04 	lds	r27, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     b84:	cd 91       	ld	r28, X+
     b86:	cd bf       	out	0x3d, r28	; 61
     b88:	dd 91       	ld	r29, X+
     b8a:	de bf       	out	0x3e, r29	; 62
     b8c:	ff 91       	pop	r31
     b8e:	ef 91       	pop	r30
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	bf 91       	pop	r27
     b96:	af 91       	pop	r26
     b98:	9f 91       	pop	r25
     b9a:	8f 91       	pop	r24
     b9c:	7f 91       	pop	r23
     b9e:	6f 91       	pop	r22
     ba0:	5f 91       	pop	r21
     ba2:	4f 91       	pop	r20
     ba4:	3f 91       	pop	r19
     ba6:	2f 91       	pop	r18
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	ff 90       	pop	r15
     bae:	ef 90       	pop	r14
     bb0:	df 90       	pop	r13
     bb2:	cf 90       	pop	r12
     bb4:	bf 90       	pop	r11
     bb6:	af 90       	pop	r10
     bb8:	9f 90       	pop	r9
     bba:	8f 90       	pop	r8
     bbc:	7f 90       	pop	r7
     bbe:	6f 90       	pop	r6
     bc0:	5f 90       	pop	r5
     bc2:	4f 90       	pop	r4
     bc4:	3f 90       	pop	r3
     bc6:	2f 90       	pop	r2
     bc8:	1f 90       	pop	r1
     bca:	0f 90       	pop	r0
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	0f 90       	pop	r0

	asm volatile ( "ret" );
     bd0:	08 95       	ret

00000bd2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     bd2:	0e 94 8d 05 	call	0xb1a	; 0xb1a <vPortYieldFromTick>
		asm volatile ( "reti" );
     bd6:	18 95       	reti

00000bd8 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     bd8:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <pxDelayedTaskList>
     bdc:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
     be0:	80 81       	ld	r24, Z
     be2:	81 11       	cpse	r24, r1
     be4:	07 c0       	rjmp	.+14     	; 0xbf4 <prvResetNextTaskUnblockTime+0x1c>
     be6:	8f ef       	ldi	r24, 0xFF	; 255
     be8:	9f ef       	ldi	r25, 0xFF	; 255
     bea:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextTaskUnblockTime+0x1>
     bee:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextTaskUnblockTime>
     bf2:	08 95       	ret
     bf4:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <pxDelayedTaskList>
     bf8:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
     bfc:	05 80       	ldd	r0, Z+5	; 0x05
     bfe:	f6 81       	ldd	r31, Z+6	; 0x06
     c00:	e0 2d       	mov	r30, r0
     c02:	06 80       	ldd	r0, Z+6	; 0x06
     c04:	f7 81       	ldd	r31, Z+7	; 0x07
     c06:	e0 2d       	mov	r30, r0
     c08:	82 81       	ldd	r24, Z+2	; 0x02
     c0a:	93 81       	ldd	r25, Z+3	; 0x03
     c0c:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextTaskUnblockTime+0x1>
     c10:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextTaskUnblockTime>
     c14:	08 95       	ret

00000c16 <prvDeleteTCB>:
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
     c1a:	ec 01       	movw	r28, r24
     c1c:	8f 89       	ldd	r24, Y+23	; 0x17
     c1e:	98 8d       	ldd	r25, Y+24	; 0x18
     c20:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <vPortFree>
     c24:	ce 01       	movw	r24, r28
     c26:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <vPortFree>
     c2a:	df 91       	pop	r29
     c2c:	cf 91       	pop	r28
     c2e:	08 95       	ret

00000c30 <prvInitialiseNewTask>:
     c30:	6f 92       	push	r6
     c32:	7f 92       	push	r7
     c34:	8f 92       	push	r8
     c36:	9f 92       	push	r9
     c38:	af 92       	push	r10
     c3a:	bf 92       	push	r11
     c3c:	cf 92       	push	r12
     c3e:	df 92       	push	r13
     c40:	ef 92       	push	r14
     c42:	0f 93       	push	r16
     c44:	1f 93       	push	r17
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	cd b7       	in	r28, 0x3d	; 61
     c4c:	de b7       	in	r29, 0x3e	; 62
     c4e:	4c 01       	movw	r8, r24
     c50:	f5 01       	movw	r30, r10
     c52:	87 89       	ldd	r24, Z+23	; 0x17
     c54:	90 8d       	ldd	r25, Z+24	; 0x18
     c56:	21 50       	subi	r18, 0x01	; 1
     c58:	31 09       	sbc	r19, r1
     c5a:	3c 01       	movw	r6, r24
     c5c:	62 0e       	add	r6, r18
     c5e:	73 1e       	adc	r7, r19
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	0f c0       	rjmp	.+30     	; 0xc82 <prvInitialiseNewTask+0x52>
     c64:	82 2f       	mov	r24, r18
     c66:	90 e0       	ldi	r25, 0x00	; 0
     c68:	fb 01       	movw	r30, r22
     c6a:	e8 0f       	add	r30, r24
     c6c:	f9 1f       	adc	r31, r25
     c6e:	30 81       	ld	r19, Z
     c70:	d5 01       	movw	r26, r10
     c72:	a8 0f       	add	r26, r24
     c74:	b9 1f       	adc	r27, r25
     c76:	59 96       	adiw	r26, 0x19	; 25
     c78:	3c 93       	st	X, r19
     c7a:	80 81       	ld	r24, Z
     c7c:	88 23       	and	r24, r24
     c7e:	19 f0       	breq	.+6      	; 0xc86 <prvInitialiseNewTask+0x56>
     c80:	2f 5f       	subi	r18, 0xFF	; 255
     c82:	28 30       	cpi	r18, 0x08	; 8
     c84:	78 f3       	brcs	.-34     	; 0xc64 <prvInitialiseNewTask+0x34>
     c86:	f5 01       	movw	r30, r10
     c88:	10 a2       	std	Z+32, r1	; 0x20
     c8a:	f8 e0       	ldi	r31, 0x08	; 8
     c8c:	fe 15       	cp	r31, r14
     c8e:	18 f4       	brcc	.+6      	; 0xc96 <prvInitialiseNewTask+0x66>
     c90:	68 94       	set
     c92:	ee 24       	eor	r14, r14
     c94:	e3 f8       	bld	r14, 3
     c96:	f5 01       	movw	r30, r10
     c98:	e6 8a       	std	Z+22, r14	; 0x16
     c9a:	e1 a2       	std	Z+33, r14	; 0x21
     c9c:	12 a2       	std	Z+34, r1	; 0x22
     c9e:	c5 01       	movw	r24, r10
     ca0:	02 96       	adiw	r24, 0x02	; 2
     ca2:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialiseItem>
     ca6:	c5 01       	movw	r24, r10
     ca8:	0c 96       	adiw	r24, 0x0c	; 12
     caa:	0e 94 14 04 	call	0x828	; 0x828 <vListInitialiseItem>
     cae:	f5 01       	movw	r30, r10
     cb0:	b1 86       	std	Z+9, r11	; 0x09
     cb2:	a0 86       	std	Z+8, r10	; 0x08
     cb4:	89 e0       	ldi	r24, 0x09	; 9
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	8e 19       	sub	r24, r14
     cba:	91 09       	sbc	r25, r1
     cbc:	95 87       	std	Z+13, r25	; 0x0d
     cbe:	84 87       	std	Z+12, r24	; 0x0c
     cc0:	b3 8a       	std	Z+19, r11	; 0x13
     cc2:	a2 8a       	std	Z+18, r10	; 0x12
     cc4:	13 a2       	std	Z+35, r1	; 0x23
     cc6:	14 a2       	std	Z+36, r1	; 0x24
     cc8:	15 a2       	std	Z+37, r1	; 0x25
     cca:	16 a2       	std	Z+38, r1	; 0x26
     ccc:	17 a2       	std	Z+39, r1	; 0x27
     cce:	a8 01       	movw	r20, r16
     cd0:	b4 01       	movw	r22, r8
     cd2:	c3 01       	movw	r24, r6
     cd4:	0e 94 99 04 	call	0x932	; 0x932 <pxPortInitialiseStack>
     cd8:	f5 01       	movw	r30, r10
     cda:	91 83       	std	Z+1, r25	; 0x01
     cdc:	80 83       	st	Z, r24
     cde:	c1 14       	cp	r12, r1
     ce0:	d1 04       	cpc	r13, r1
     ce2:	19 f0       	breq	.+6      	; 0xcea <prvInitialiseNewTask+0xba>
     ce4:	f6 01       	movw	r30, r12
     ce6:	b1 82       	std	Z+1, r11	; 0x01
     ce8:	a0 82       	st	Z, r10
     cea:	df 91       	pop	r29
     cec:	cf 91       	pop	r28
     cee:	1f 91       	pop	r17
     cf0:	0f 91       	pop	r16
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	af 90       	pop	r10
     cfc:	9f 90       	pop	r9
     cfe:	8f 90       	pop	r8
     d00:	7f 90       	pop	r7
     d02:	6f 90       	pop	r6
     d04:	08 95       	ret

00000d06 <prvInitialiseTaskLists>:
     d06:	cf 93       	push	r28
     d08:	c0 e0       	ldi	r28, 0x00	; 0
     d0a:	10 c0       	rjmp	.+32     	; 0xd2c <prvInitialiseTaskLists+0x26>
     d0c:	8c 2f       	mov	r24, r28
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	9c 01       	movw	r18, r24
     d12:	22 0f       	add	r18, r18
     d14:	33 1f       	adc	r19, r19
     d16:	22 0f       	add	r18, r18
     d18:	33 1f       	adc	r19, r19
     d1a:	22 0f       	add	r18, r18
     d1c:	33 1f       	adc	r19, r19
     d1e:	82 0f       	add	r24, r18
     d20:	93 1f       	adc	r25, r19
     d22:	80 56       	subi	r24, 0x60	; 96
     d24:	9b 4f       	sbci	r25, 0xFB	; 251
     d26:	0e 94 06 04 	call	0x80c	; 0x80c <vListInitialise>
     d2a:	cf 5f       	subi	r28, 0xFF	; 255
     d2c:	c9 30       	cpi	r28, 0x09	; 9
     d2e:	70 f3       	brcs	.-36     	; 0xd0c <prvInitialiseTaskLists+0x6>
     d30:	87 e9       	ldi	r24, 0x97	; 151
     d32:	94 e0       	ldi	r25, 0x04	; 4
     d34:	0e 94 06 04 	call	0x80c	; 0x80c <vListInitialise>
     d38:	8e e8       	ldi	r24, 0x8E	; 142
     d3a:	94 e0       	ldi	r25, 0x04	; 4
     d3c:	0e 94 06 04 	call	0x80c	; 0x80c <vListInitialise>
     d40:	81 e8       	ldi	r24, 0x81	; 129
     d42:	94 e0       	ldi	r25, 0x04	; 4
     d44:	0e 94 06 04 	call	0x80c	; 0x80c <vListInitialise>
     d48:	88 e7       	ldi	r24, 0x78	; 120
     d4a:	94 e0       	ldi	r25, 0x04	; 4
     d4c:	0e 94 06 04 	call	0x80c	; 0x80c <vListInitialise>
     d50:	87 e9       	ldi	r24, 0x97	; 151
     d52:	94 e0       	ldi	r25, 0x04	; 4
     d54:	90 93 8d 04 	sts	0x048D, r25	; 0x80048d <pxDelayedTaskList+0x1>
     d58:	80 93 8c 04 	sts	0x048C, r24	; 0x80048c <pxDelayedTaskList>
     d5c:	8e e8       	ldi	r24, 0x8E	; 142
     d5e:	94 e0       	ldi	r25, 0x04	; 4
     d60:	90 93 8b 04 	sts	0x048B, r25	; 0x80048b <pxOverflowDelayedTaskList+0x1>
     d64:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <pxOverflowDelayedTaskList>
     d68:	cf 91       	pop	r28
     d6a:	08 95       	ret

00000d6c <prvAddNewTaskToReadyList>:
     d6c:	cf 93       	push	r28
     d6e:	df 93       	push	r29
     d70:	ec 01       	movw	r28, r24
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	f8 94       	cli
     d76:	0f 92       	push	r0
     d78:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <uxCurrentNumberOfTasks>
     d7c:	8f 5f       	subi	r24, 0xFF	; 255
     d7e:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <uxCurrentNumberOfTasks>
     d82:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     d86:	90 91 f2 04 	lds	r25, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     d8a:	89 2b       	or	r24, r25
     d8c:	59 f4       	brne	.+22     	; 0xda4 <prvAddNewTaskToReadyList+0x38>
     d8e:	d0 93 f2 04 	sts	0x04F2, r29	; 0x8004f2 <pxCurrentTCB+0x1>
     d92:	c0 93 f1 04 	sts	0x04F1, r28	; 0x8004f1 <pxCurrentTCB>
     d96:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <uxCurrentNumberOfTasks>
     d9a:	81 30       	cpi	r24, 0x01	; 1
     d9c:	99 f4       	brne	.+38     	; 0xdc4 <prvAddNewTaskToReadyList+0x58>
     d9e:	0e 94 83 06 	call	0xd06	; 0xd06 <prvInitialiseTaskLists>
     da2:	10 c0       	rjmp	.+32     	; 0xdc4 <prvAddNewTaskToReadyList+0x58>
     da4:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <xSchedulerRunning>
     da8:	81 11       	cpse	r24, r1
     daa:	0c c0       	rjmp	.+24     	; 0xdc4 <prvAddNewTaskToReadyList+0x58>
     dac:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     db0:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     db4:	96 89       	ldd	r25, Z+22	; 0x16
     db6:	8e 89       	ldd	r24, Y+22	; 0x16
     db8:	89 17       	cp	r24, r25
     dba:	20 f0       	brcs	.+8      	; 0xdc4 <prvAddNewTaskToReadyList+0x58>
     dbc:	d0 93 f2 04 	sts	0x04F2, r29	; 0x8004f2 <pxCurrentTCB+0x1>
     dc0:	c0 93 f1 04 	sts	0x04F1, r28	; 0x8004f1 <pxCurrentTCB>
     dc4:	80 91 6e 04 	lds	r24, 0x046E	; 0x80046e <uxTaskNumber>
     dc8:	8f 5f       	subi	r24, 0xFF	; 255
     dca:	80 93 6e 04 	sts	0x046E, r24	; 0x80046e <uxTaskNumber>
     dce:	8e 89       	ldd	r24, Y+22	; 0x16
     dd0:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <uxTopReadyPriority>
     dd4:	98 17       	cp	r25, r24
     dd6:	10 f4       	brcc	.+4      	; 0xddc <prvAddNewTaskToReadyList+0x70>
     dd8:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <uxTopReadyPriority>
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	9c 01       	movw	r18, r24
     de0:	22 0f       	add	r18, r18
     de2:	33 1f       	adc	r19, r19
     de4:	22 0f       	add	r18, r18
     de6:	33 1f       	adc	r19, r19
     de8:	22 0f       	add	r18, r18
     dea:	33 1f       	adc	r19, r19
     dec:	82 0f       	add	r24, r18
     dee:	93 1f       	adc	r25, r19
     df0:	be 01       	movw	r22, r28
     df2:	6e 5f       	subi	r22, 0xFE	; 254
     df4:	7f 4f       	sbci	r23, 0xFF	; 255
     df6:	80 56       	subi	r24, 0x60	; 96
     df8:	9b 4f       	sbci	r25, 0xFB	; 251
     dfa:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
     dfe:	0f 90       	pop	r0
     e00:	0f be       	out	0x3f, r0	; 63
     e02:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <xSchedulerRunning>
     e06:	88 23       	and	r24, r24
     e08:	51 f0       	breq	.+20     	; 0xe1e <prvAddNewTaskToReadyList+0xb2>
     e0a:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     e0e:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     e12:	96 89       	ldd	r25, Z+22	; 0x16
     e14:	8e 89       	ldd	r24, Y+22	; 0x16
     e16:	98 17       	cp	r25, r24
     e18:	10 f4       	brcc	.+4      	; 0xe1e <prvAddNewTaskToReadyList+0xb2>
     e1a:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
     e1e:	df 91       	pop	r29
     e20:	cf 91       	pop	r28
     e22:	08 95       	ret

00000e24 <prvAddCurrentTaskToDelayedList>:
     e24:	0f 93       	push	r16
     e26:	1f 93       	push	r17
     e28:	cf 93       	push	r28
     e2a:	df 93       	push	r29
     e2c:	ec 01       	movw	r28, r24
     e2e:	00 91 74 04 	lds	r16, 0x0474	; 0x800474 <xTickCount>
     e32:	10 91 75 04 	lds	r17, 0x0475	; 0x800475 <xTickCount+0x1>
     e36:	80 91 f1 04 	lds	r24, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     e3a:	90 91 f2 04 	lds	r25, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     e3e:	02 96       	adiw	r24, 0x02	; 2
     e40:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
     e44:	c0 0f       	add	r28, r16
     e46:	d1 1f       	adc	r29, r17
     e48:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     e4c:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     e50:	d3 83       	std	Z+3, r29	; 0x03
     e52:	c2 83       	std	Z+2, r28	; 0x02
     e54:	c0 17       	cp	r28, r16
     e56:	d1 07       	cpc	r29, r17
     e58:	68 f4       	brcc	.+26     	; 0xe74 <prvAddCurrentTaskToDelayedList+0x50>
     e5a:	60 91 f1 04 	lds	r22, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     e5e:	70 91 f2 04 	lds	r23, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     e62:	80 91 8a 04 	lds	r24, 0x048A	; 0x80048a <pxOverflowDelayedTaskList>
     e66:	90 91 8b 04 	lds	r25, 0x048B	; 0x80048b <pxOverflowDelayedTaskList+0x1>
     e6a:	6e 5f       	subi	r22, 0xFE	; 254
     e6c:	7f 4f       	sbci	r23, 0xFF	; 255
     e6e:	0e 94 39 04 	call	0x872	; 0x872 <vListInsert>
     e72:	17 c0       	rjmp	.+46     	; 0xea2 <prvAddCurrentTaskToDelayedList+0x7e>
     e74:	60 91 f1 04 	lds	r22, 0x04F1	; 0x8004f1 <pxCurrentTCB>
     e78:	70 91 f2 04 	lds	r23, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
     e7c:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <pxDelayedTaskList>
     e80:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
     e84:	6e 5f       	subi	r22, 0xFE	; 254
     e86:	7f 4f       	sbci	r23, 0xFF	; 255
     e88:	0e 94 39 04 	call	0x872	; 0x872 <vListInsert>
     e8c:	80 91 6c 04 	lds	r24, 0x046C	; 0x80046c <xNextTaskUnblockTime>
     e90:	90 91 6d 04 	lds	r25, 0x046D	; 0x80046d <xNextTaskUnblockTime+0x1>
     e94:	c8 17       	cp	r28, r24
     e96:	d9 07       	cpc	r29, r25
     e98:	20 f4       	brcc	.+8      	; 0xea2 <prvAddCurrentTaskToDelayedList+0x7e>
     e9a:	d0 93 6d 04 	sts	0x046D, r29	; 0x80046d <xNextTaskUnblockTime+0x1>
     e9e:	c0 93 6c 04 	sts	0x046C, r28	; 0x80046c <xNextTaskUnblockTime>
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	08 95       	ret

00000eac <xTaskCreate>:
     eac:	2f 92       	push	r2
     eae:	3f 92       	push	r3
     eb0:	4f 92       	push	r4
     eb2:	5f 92       	push	r5
     eb4:	6f 92       	push	r6
     eb6:	7f 92       	push	r7
     eb8:	8f 92       	push	r8
     eba:	9f 92       	push	r9
     ebc:	af 92       	push	r10
     ebe:	bf 92       	push	r11
     ec0:	cf 92       	push	r12
     ec2:	df 92       	push	r13
     ec4:	ef 92       	push	r14
     ec6:	ff 92       	push	r15
     ec8:	0f 93       	push	r16
     eca:	1f 93       	push	r17
     ecc:	cf 93       	push	r28
     ece:	df 93       	push	r29
     ed0:	3c 01       	movw	r6, r24
     ed2:	1b 01       	movw	r2, r22
     ed4:	5a 01       	movw	r10, r20
     ed6:	29 01       	movw	r4, r18
     ed8:	ca 01       	movw	r24, r20
     eda:	0e 94 57 03 	call	0x6ae	; 0x6ae <pvPortMalloc>
     ede:	6c 01       	movw	r12, r24
     ee0:	89 2b       	or	r24, r25
     ee2:	71 f0       	breq	.+28     	; 0xf00 <xTaskCreate+0x54>
     ee4:	88 e2       	ldi	r24, 0x28	; 40
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	0e 94 57 03 	call	0x6ae	; 0x6ae <pvPortMalloc>
     eec:	ec 01       	movw	r28, r24
     eee:	89 2b       	or	r24, r25
     ef0:	19 f0       	breq	.+6      	; 0xef8 <xTaskCreate+0x4c>
     ef2:	d8 8e       	std	Y+24, r13	; 0x18
     ef4:	cf 8a       	std	Y+23, r12	; 0x17
     ef6:	06 c0       	rjmp	.+12     	; 0xf04 <xTaskCreate+0x58>
     ef8:	c6 01       	movw	r24, r12
     efa:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <vPortFree>
     efe:	02 c0       	rjmp	.+4      	; 0xf04 <xTaskCreate+0x58>
     f00:	c0 e0       	ldi	r28, 0x00	; 0
     f02:	d0 e0       	ldi	r29, 0x00	; 0
     f04:	20 97       	sbiw	r28, 0x00	; 0
     f06:	91 f0       	breq	.+36     	; 0xf2c <xTaskCreate+0x80>
     f08:	95 01       	movw	r18, r10
     f0a:	40 e0       	ldi	r20, 0x00	; 0
     f0c:	50 e0       	ldi	r21, 0x00	; 0
     f0e:	81 2c       	mov	r8, r1
     f10:	91 2c       	mov	r9, r1
     f12:	5e 01       	movw	r10, r28
     f14:	67 01       	movw	r12, r14
     f16:	e0 2e       	mov	r14, r16
     f18:	82 01       	movw	r16, r4
     f1a:	b1 01       	movw	r22, r2
     f1c:	c3 01       	movw	r24, r6
     f1e:	0e 94 18 06 	call	0xc30	; 0xc30 <prvInitialiseNewTask>
     f22:	ce 01       	movw	r24, r28
     f24:	0e 94 b6 06 	call	0xd6c	; 0xd6c <prvAddNewTaskToReadyList>
     f28:	81 e0       	ldi	r24, 0x01	; 1
     f2a:	01 c0       	rjmp	.+2      	; 0xf2e <xTaskCreate+0x82>
     f2c:	8f ef       	ldi	r24, 0xFF	; 255
     f2e:	df 91       	pop	r29
     f30:	cf 91       	pop	r28
     f32:	1f 91       	pop	r17
     f34:	0f 91       	pop	r16
     f36:	ff 90       	pop	r15
     f38:	ef 90       	pop	r14
     f3a:	df 90       	pop	r13
     f3c:	cf 90       	pop	r12
     f3e:	bf 90       	pop	r11
     f40:	af 90       	pop	r10
     f42:	9f 90       	pop	r9
     f44:	8f 90       	pop	r8
     f46:	7f 90       	pop	r7
     f48:	6f 90       	pop	r6
     f4a:	5f 90       	pop	r5
     f4c:	4f 90       	pop	r4
     f4e:	3f 90       	pop	r3
     f50:	2f 90       	pop	r2
     f52:	08 95       	ret

00000f54 <vTaskStartScheduler>:
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	0f 2e       	mov	r0, r31
     f5c:	fa e6       	ldi	r31, 0x6A	; 106
     f5e:	ef 2e       	mov	r14, r31
     f60:	f4 e0       	ldi	r31, 0x04	; 4
     f62:	ff 2e       	mov	r15, r31
     f64:	f0 2d       	mov	r31, r0
     f66:	00 e0       	ldi	r16, 0x00	; 0
     f68:	20 e0       	ldi	r18, 0x00	; 0
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	40 e5       	ldi	r20, 0x50	; 80
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	6b e6       	ldi	r22, 0x6B	; 107
     f72:	70 e0       	ldi	r23, 0x00	; 0
     f74:	8a e4       	ldi	r24, 0x4A	; 74
     f76:	99 e0       	ldi	r25, 0x09	; 9
     f78:	0e 94 56 07 	call	0xeac	; 0xeac <xTaskCreate>
     f7c:	81 30       	cpi	r24, 0x01	; 1
     f7e:	81 f4       	brne	.+32     	; 0xfa0 <vTaskStartScheduler+0x4c>
     f80:	f8 94       	cli
     f82:	8f ef       	ldi	r24, 0xFF	; 255
     f84:	9f ef       	ldi	r25, 0xFF	; 255
     f86:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextTaskUnblockTime+0x1>
     f8a:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextTaskUnblockTime>
     f8e:	81 e0       	ldi	r24, 0x01	; 1
     f90:	80 93 72 04 	sts	0x0472, r24	; 0x800472 <xSchedulerRunning>
     f94:	10 92 75 04 	sts	0x0475, r1	; 0x800475 <xTickCount+0x1>
     f98:	10 92 74 04 	sts	0x0474, r1	; 0x800474 <xTickCount>
     f9c:	0e 94 05 05 	call	0xa0a	; 0xa0a <xPortStartScheduler>
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	08 95       	ret

00000fa8 <vTaskSuspendAll>:
     fa8:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <uxSchedulerSuspended>
     fac:	8f 5f       	subi	r24, 0xFF	; 255
     fae:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <uxSchedulerSuspended>
     fb2:	08 95       	ret

00000fb4 <xTaskIncrementTick>:
     fb4:	df 92       	push	r13
     fb6:	ef 92       	push	r14
     fb8:	ff 92       	push	r15
     fba:	0f 93       	push	r16
     fbc:	1f 93       	push	r17
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
     fc2:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <uxSchedulerSuspended>
     fc6:	81 11       	cpse	r24, r1
     fc8:	97 c0       	rjmp	.+302    	; 0x10f8 <xTaskIncrementTick+0x144>
     fca:	e0 90 74 04 	lds	r14, 0x0474	; 0x800474 <xTickCount>
     fce:	f0 90 75 04 	lds	r15, 0x0475	; 0x800475 <xTickCount+0x1>
     fd2:	8f ef       	ldi	r24, 0xFF	; 255
     fd4:	e8 1a       	sub	r14, r24
     fd6:	f8 0a       	sbc	r15, r24
     fd8:	f0 92 75 04 	sts	0x0475, r15	; 0x800475 <xTickCount+0x1>
     fdc:	e0 92 74 04 	sts	0x0474, r14	; 0x800474 <xTickCount>
     fe0:	e1 14       	cp	r14, r1
     fe2:	f1 04       	cpc	r15, r1
     fe4:	b9 f4       	brne	.+46     	; 0x1014 <xTaskIncrementTick+0x60>
     fe6:	80 91 8c 04 	lds	r24, 0x048C	; 0x80048c <pxDelayedTaskList>
     fea:	90 91 8d 04 	lds	r25, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
     fee:	20 91 8a 04 	lds	r18, 0x048A	; 0x80048a <pxOverflowDelayedTaskList>
     ff2:	30 91 8b 04 	lds	r19, 0x048B	; 0x80048b <pxOverflowDelayedTaskList+0x1>
     ff6:	30 93 8d 04 	sts	0x048D, r19	; 0x80048d <pxDelayedTaskList+0x1>
     ffa:	20 93 8c 04 	sts	0x048C, r18	; 0x80048c <pxDelayedTaskList>
     ffe:	90 93 8b 04 	sts	0x048B, r25	; 0x80048b <pxOverflowDelayedTaskList+0x1>
    1002:	80 93 8a 04 	sts	0x048A, r24	; 0x80048a <pxOverflowDelayedTaskList>
    1006:	80 91 6f 04 	lds	r24, 0x046F	; 0x80046f <xNumOfOverflows>
    100a:	8f 5f       	subi	r24, 0xFF	; 255
    100c:	80 93 6f 04 	sts	0x046F, r24	; 0x80046f <xNumOfOverflows>
    1010:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <prvResetNextTaskUnblockTime>
    1014:	80 91 6c 04 	lds	r24, 0x046C	; 0x80046c <xNextTaskUnblockTime>
    1018:	90 91 6d 04 	lds	r25, 0x046D	; 0x80046d <xNextTaskUnblockTime+0x1>
    101c:	e8 16       	cp	r14, r24
    101e:	f9 06       	cpc	r15, r25
    1020:	28 f4       	brcc	.+10     	; 0x102c <xTaskIncrementTick+0x78>
    1022:	d1 2c       	mov	r13, r1
    1024:	53 c0       	rjmp	.+166    	; 0x10cc <xTaskIncrementTick+0x118>
    1026:	dd 24       	eor	r13, r13
    1028:	d3 94       	inc	r13
    102a:	01 c0       	rjmp	.+2      	; 0x102e <xTaskIncrementTick+0x7a>
    102c:	d1 2c       	mov	r13, r1
    102e:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <pxDelayedTaskList>
    1032:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
    1036:	80 81       	ld	r24, Z
    1038:	81 11       	cpse	r24, r1
    103a:	07 c0       	rjmp	.+14     	; 0x104a <xTaskIncrementTick+0x96>
    103c:	8f ef       	ldi	r24, 0xFF	; 255
    103e:	9f ef       	ldi	r25, 0xFF	; 255
    1040:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextTaskUnblockTime+0x1>
    1044:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextTaskUnblockTime>
    1048:	41 c0       	rjmp	.+130    	; 0x10cc <xTaskIncrementTick+0x118>
    104a:	e0 91 8c 04 	lds	r30, 0x048C	; 0x80048c <pxDelayedTaskList>
    104e:	f0 91 8d 04 	lds	r31, 0x048D	; 0x80048d <pxDelayedTaskList+0x1>
    1052:	05 80       	ldd	r0, Z+5	; 0x05
    1054:	f6 81       	ldd	r31, Z+6	; 0x06
    1056:	e0 2d       	mov	r30, r0
    1058:	c6 81       	ldd	r28, Z+6	; 0x06
    105a:	d7 81       	ldd	r29, Z+7	; 0x07
    105c:	8a 81       	ldd	r24, Y+2	; 0x02
    105e:	9b 81       	ldd	r25, Y+3	; 0x03
    1060:	e8 16       	cp	r14, r24
    1062:	f9 06       	cpc	r15, r25
    1064:	28 f4       	brcc	.+10     	; 0x1070 <xTaskIncrementTick+0xbc>
    1066:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextTaskUnblockTime+0x1>
    106a:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextTaskUnblockTime>
    106e:	2e c0       	rjmp	.+92     	; 0x10cc <xTaskIncrementTick+0x118>
    1070:	8e 01       	movw	r16, r28
    1072:	0e 5f       	subi	r16, 0xFE	; 254
    1074:	1f 4f       	sbci	r17, 0xFF	; 255
    1076:	c8 01       	movw	r24, r16
    1078:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
    107c:	8c 89       	ldd	r24, Y+20	; 0x14
    107e:	9d 89       	ldd	r25, Y+21	; 0x15
    1080:	89 2b       	or	r24, r25
    1082:	21 f0       	breq	.+8      	; 0x108c <xTaskIncrementTick+0xd8>
    1084:	ce 01       	movw	r24, r28
    1086:	0c 96       	adiw	r24, 0x0c	; 12
    1088:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
    108c:	8e 89       	ldd	r24, Y+22	; 0x16
    108e:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <uxTopReadyPriority>
    1092:	98 17       	cp	r25, r24
    1094:	10 f4       	brcc	.+4      	; 0x109a <xTaskIncrementTick+0xe6>
    1096:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <uxTopReadyPriority>
    109a:	90 e0       	ldi	r25, 0x00	; 0
    109c:	9c 01       	movw	r18, r24
    109e:	22 0f       	add	r18, r18
    10a0:	33 1f       	adc	r19, r19
    10a2:	22 0f       	add	r18, r18
    10a4:	33 1f       	adc	r19, r19
    10a6:	22 0f       	add	r18, r18
    10a8:	33 1f       	adc	r19, r19
    10aa:	82 0f       	add	r24, r18
    10ac:	93 1f       	adc	r25, r19
    10ae:	b8 01       	movw	r22, r16
    10b0:	80 56       	subi	r24, 0x60	; 96
    10b2:	9b 4f       	sbci	r25, 0xFB	; 251
    10b4:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
    10b8:	9e 89       	ldd	r25, Y+22	; 0x16
    10ba:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
    10be:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
    10c2:	86 89       	ldd	r24, Z+22	; 0x16
    10c4:	98 17       	cp	r25, r24
    10c6:	08 f0       	brcs	.+2      	; 0x10ca <xTaskIncrementTick+0x116>
    10c8:	ae cf       	rjmp	.-164    	; 0x1026 <xTaskIncrementTick+0x72>
    10ca:	b1 cf       	rjmp	.-158    	; 0x102e <xTaskIncrementTick+0x7a>
    10cc:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
    10d0:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
    10d4:	86 89       	ldd	r24, Z+22	; 0x16
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	fc 01       	movw	r30, r24
    10da:	ee 0f       	add	r30, r30
    10dc:	ff 1f       	adc	r31, r31
    10de:	ee 0f       	add	r30, r30
    10e0:	ff 1f       	adc	r31, r31
    10e2:	ee 0f       	add	r30, r30
    10e4:	ff 1f       	adc	r31, r31
    10e6:	8e 0f       	add	r24, r30
    10e8:	9f 1f       	adc	r25, r31
    10ea:	fc 01       	movw	r30, r24
    10ec:	e0 56       	subi	r30, 0x60	; 96
    10ee:	fb 4f       	sbci	r31, 0xFB	; 251
    10f0:	80 81       	ld	r24, Z
    10f2:	82 30       	cpi	r24, 0x02	; 2
    10f4:	40 f4       	brcc	.+16     	; 0x1106 <xTaskIncrementTick+0x152>
    10f6:	09 c0       	rjmp	.+18     	; 0x110a <xTaskIncrementTick+0x156>
    10f8:	80 91 71 04 	lds	r24, 0x0471	; 0x800471 <uxPendedTicks>
    10fc:	8f 5f       	subi	r24, 0xFF	; 255
    10fe:	80 93 71 04 	sts	0x0471, r24	; 0x800471 <uxPendedTicks>
    1102:	d1 2c       	mov	r13, r1
    1104:	02 c0       	rjmp	.+4      	; 0x110a <xTaskIncrementTick+0x156>
    1106:	dd 24       	eor	r13, r13
    1108:	d3 94       	inc	r13
    110a:	80 91 70 04 	lds	r24, 0x0470	; 0x800470 <xYieldPending>
    110e:	88 23       	and	r24, r24
    1110:	11 f0       	breq	.+4      	; 0x1116 <xTaskIncrementTick+0x162>
    1112:	dd 24       	eor	r13, r13
    1114:	d3 94       	inc	r13
    1116:	8d 2d       	mov	r24, r13
    1118:	df 91       	pop	r29
    111a:	cf 91       	pop	r28
    111c:	1f 91       	pop	r17
    111e:	0f 91       	pop	r16
    1120:	ff 90       	pop	r15
    1122:	ef 90       	pop	r14
    1124:	df 90       	pop	r13
    1126:	08 95       	ret

00001128 <xTaskResumeAll>:
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	0f b6       	in	r0, 0x3f	; 63
    1132:	f8 94       	cli
    1134:	0f 92       	push	r0
    1136:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <uxSchedulerSuspended>
    113a:	81 50       	subi	r24, 0x01	; 1
    113c:	80 93 69 04 	sts	0x0469, r24	; 0x800469 <uxSchedulerSuspended>
    1140:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <uxSchedulerSuspended>
    1144:	81 11       	cpse	r24, r1
    1146:	58 c0       	rjmp	.+176    	; 0x11f8 <xTaskResumeAll+0xd0>
    1148:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <uxCurrentNumberOfTasks>
    114c:	81 11       	cpse	r24, r1
    114e:	33 c0       	rjmp	.+102    	; 0x11b6 <xTaskResumeAll+0x8e>
    1150:	56 c0       	rjmp	.+172    	; 0x11fe <xTaskResumeAll+0xd6>
    1152:	e0 91 86 04 	lds	r30, 0x0486	; 0x800486 <xPendingReadyList+0x5>
    1156:	f0 91 87 04 	lds	r31, 0x0487	; 0x800487 <xPendingReadyList+0x6>
    115a:	c6 81       	ldd	r28, Z+6	; 0x06
    115c:	d7 81       	ldd	r29, Z+7	; 0x07
    115e:	ce 01       	movw	r24, r28
    1160:	0c 96       	adiw	r24, 0x0c	; 12
    1162:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
    1166:	8e 01       	movw	r16, r28
    1168:	0e 5f       	subi	r16, 0xFE	; 254
    116a:	1f 4f       	sbci	r17, 0xFF	; 255
    116c:	c8 01       	movw	r24, r16
    116e:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
    1172:	8e 89       	ldd	r24, Y+22	; 0x16
    1174:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <uxTopReadyPriority>
    1178:	98 17       	cp	r25, r24
    117a:	10 f4       	brcc	.+4      	; 0x1180 <xTaskResumeAll+0x58>
    117c:	80 93 73 04 	sts	0x0473, r24	; 0x800473 <uxTopReadyPriority>
    1180:	90 e0       	ldi	r25, 0x00	; 0
    1182:	9c 01       	movw	r18, r24
    1184:	22 0f       	add	r18, r18
    1186:	33 1f       	adc	r19, r19
    1188:	22 0f       	add	r18, r18
    118a:	33 1f       	adc	r19, r19
    118c:	22 0f       	add	r18, r18
    118e:	33 1f       	adc	r19, r19
    1190:	82 0f       	add	r24, r18
    1192:	93 1f       	adc	r25, r19
    1194:	b8 01       	movw	r22, r16
    1196:	80 56       	subi	r24, 0x60	; 96
    1198:	9b 4f       	sbci	r25, 0xFB	; 251
    119a:	0e 94 18 04 	call	0x830	; 0x830 <vListInsertEnd>
    119e:	9e 89       	ldd	r25, Y+22	; 0x16
    11a0:	e0 91 f1 04 	lds	r30, 0x04F1	; 0x8004f1 <pxCurrentTCB>
    11a4:	f0 91 f2 04 	lds	r31, 0x04F2	; 0x8004f2 <pxCurrentTCB+0x1>
    11a8:	86 89       	ldd	r24, Z+22	; 0x16
    11aa:	98 17       	cp	r25, r24
    11ac:	30 f0       	brcs	.+12     	; 0x11ba <xTaskResumeAll+0x92>
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xYieldPending>
    11b4:	02 c0       	rjmp	.+4      	; 0x11ba <xTaskResumeAll+0x92>
    11b6:	c0 e0       	ldi	r28, 0x00	; 0
    11b8:	d0 e0       	ldi	r29, 0x00	; 0
    11ba:	80 91 81 04 	lds	r24, 0x0481	; 0x800481 <xPendingReadyList>
    11be:	81 11       	cpse	r24, r1
    11c0:	c8 cf       	rjmp	.-112    	; 0x1152 <xTaskResumeAll+0x2a>
    11c2:	cd 2b       	or	r28, r29
    11c4:	11 f0       	breq	.+4      	; 0x11ca <xTaskResumeAll+0xa2>
    11c6:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <prvResetNextTaskUnblockTime>
    11ca:	c0 91 71 04 	lds	r28, 0x0471	; 0x800471 <uxPendedTicks>
    11ce:	cc 23       	and	r28, r28
    11d0:	59 f0       	breq	.+22     	; 0x11e8 <xTaskResumeAll+0xc0>
    11d2:	0e 94 da 07 	call	0xfb4	; 0xfb4 <xTaskIncrementTick>
    11d6:	88 23       	and	r24, r24
    11d8:	19 f0       	breq	.+6      	; 0x11e0 <xTaskResumeAll+0xb8>
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xYieldPending>
    11e0:	c1 50       	subi	r28, 0x01	; 1
    11e2:	b9 f7       	brne	.-18     	; 0x11d2 <xTaskResumeAll+0xaa>
    11e4:	10 92 71 04 	sts	0x0471, r1	; 0x800471 <uxPendedTicks>
    11e8:	80 91 70 04 	lds	r24, 0x0470	; 0x800470 <xYieldPending>
    11ec:	88 23       	and	r24, r24
    11ee:	31 f0       	breq	.+12     	; 0x11fc <xTaskResumeAll+0xd4>
    11f0:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	03 c0       	rjmp	.+6      	; 0x11fe <xTaskResumeAll+0xd6>
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	01 c0       	rjmp	.+2      	; 0x11fe <xTaskResumeAll+0xd6>
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	1f 91       	pop	r17
    1208:	0f 91       	pop	r16
    120a:	08 95       	ret

0000120c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    120c:	cf 93       	push	r28
    120e:	df 93       	push	r29
    1210:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1212:	89 2b       	or	r24, r25
    1214:	49 f0       	breq	.+18     	; 0x1228 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1216:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    121a:	60 e0       	ldi	r22, 0x00	; 0
    121c:	ce 01       	movw	r24, r28
    121e:	0e 94 12 07 	call	0xe24	; 0xe24 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1222:	0e 94 94 08 	call	0x1128	; 0x1128 <xTaskResumeAll>
    1226:	01 c0       	rjmp	.+2      	; 0x122a <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1228:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    122a:	81 11       	cpse	r24, r1
    122c:	02 c0       	rjmp	.+4      	; 0x1232 <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    122e:	0e 94 34 05 	call	0xa68	; 0xa68 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	08 95       	ret

00001238 <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1238:	cf 93       	push	r28
    123a:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    123c:	24 c0       	rjmp	.+72     	; 0x1286 <prvCheckTasksWaitingTermination+0x4e>
		{
			vTaskSuspendAll();
    123e:	0e 94 d4 07 	call	0xfa8	; 0xfa8 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1242:	c0 91 78 04 	lds	r28, 0x0478	; 0x800478 <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
    1246:	0e 94 94 08 	call	0x1128	; 0x1128 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    124a:	cc 23       	and	r28, r28
    124c:	e1 f0       	breq	.+56     	; 0x1286 <prvCheckTasksWaitingTermination+0x4e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    124e:	0f b6       	in	r0, 0x3f	; 63
    1250:	f8 94       	cli
    1252:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1254:	e0 91 7d 04 	lds	r30, 0x047D	; 0x80047d <xTasksWaitingTermination+0x5>
    1258:	f0 91 7e 04 	lds	r31, 0x047E	; 0x80047e <xTasksWaitingTermination+0x6>
    125c:	c6 81       	ldd	r28, Z+6	; 0x06
    125e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1260:	ce 01       	movw	r24, r28
    1262:	02 96       	adiw	r24, 0x02	; 2
    1264:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1268:	80 91 76 04 	lds	r24, 0x0476	; 0x800476 <uxCurrentNumberOfTasks>
    126c:	81 50       	subi	r24, 0x01	; 1
    126e:	80 93 76 04 	sts	0x0476, r24	; 0x800476 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
    1272:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <uxDeletedTasksWaitingCleanUp>
    1276:	81 50       	subi	r24, 0x01	; 1
    1278:	80 93 77 04 	sts	0x0477, r24	; 0x800477 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
    127c:	0f 90       	pop	r0
    127e:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1280:	ce 01       	movw	r24, r28
    1282:	0e 94 0b 06 	call	0xc16	; 0xc16 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1286:	80 91 77 04 	lds	r24, 0x0477	; 0x800477 <uxDeletedTasksWaitingCleanUp>
    128a:	81 11       	cpse	r24, r1
    128c:	d8 cf       	rjmp	.-80     	; 0x123e <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    128e:	df 91       	pop	r29
    1290:	cf 91       	pop	r28
    1292:	08 95       	ret

00001294 <prvIdleTask>:

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    1294:	0e 94 1c 09 	call	0x1238	; 0x1238 <prvCheckTasksWaitingTermination>
    1298:	fd cf       	rjmp	.-6      	; 0x1294 <prvIdleTask>

0000129a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    129a:	80 91 69 04 	lds	r24, 0x0469	; 0x800469 <uxSchedulerSuspended>
    129e:	88 23       	and	r24, r24
    12a0:	21 f0       	breq	.+8      	; 0x12aa <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	80 93 70 04 	sts	0x0470, r24	; 0x800470 <xYieldPending>
    12a8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    12aa:	10 92 70 04 	sts	0x0470, r1	; 0x800470 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    12ae:	20 91 73 04 	lds	r18, 0x0473	; 0x800473 <uxTopReadyPriority>
    12b2:	01 c0       	rjmp	.+2      	; 0x12b6 <vTaskSwitchContext+0x1c>
    12b4:	21 50       	subi	r18, 0x01	; 1
    12b6:	82 2f       	mov	r24, r18
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	fc 01       	movw	r30, r24
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	ee 0f       	add	r30, r30
    12c2:	ff 1f       	adc	r31, r31
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	e8 0f       	add	r30, r24
    12ca:	f9 1f       	adc	r31, r25
    12cc:	e0 56       	subi	r30, 0x60	; 96
    12ce:	fb 4f       	sbci	r31, 0xFB	; 251
    12d0:	30 81       	ld	r19, Z
    12d2:	33 23       	and	r19, r19
    12d4:	79 f3       	breq	.-34     	; 0x12b4 <vTaskSwitchContext+0x1a>
    12d6:	ac 01       	movw	r20, r24
    12d8:	44 0f       	add	r20, r20
    12da:	55 1f       	adc	r21, r21
    12dc:	44 0f       	add	r20, r20
    12de:	55 1f       	adc	r21, r21
    12e0:	44 0f       	add	r20, r20
    12e2:	55 1f       	adc	r21, r21
    12e4:	48 0f       	add	r20, r24
    12e6:	59 1f       	adc	r21, r25
    12e8:	df 01       	movw	r26, r30
    12ea:	01 80       	ldd	r0, Z+1	; 0x01
    12ec:	f2 81       	ldd	r31, Z+2	; 0x02
    12ee:	e0 2d       	mov	r30, r0
    12f0:	02 80       	ldd	r0, Z+2	; 0x02
    12f2:	f3 81       	ldd	r31, Z+3	; 0x03
    12f4:	e0 2d       	mov	r30, r0
    12f6:	12 96       	adiw	r26, 0x02	; 2
    12f8:	fc 93       	st	X, r31
    12fa:	ee 93       	st	-X, r30
    12fc:	11 97       	sbiw	r26, 0x01	; 1
    12fe:	4d 55       	subi	r20, 0x5D	; 93
    1300:	5b 4f       	sbci	r21, 0xFB	; 251
    1302:	e4 17       	cp	r30, r20
    1304:	f5 07       	cpc	r31, r21
    1306:	29 f4       	brne	.+10     	; 0x1312 <vTaskSwitchContext+0x78>
    1308:	42 81       	ldd	r20, Z+2	; 0x02
    130a:	53 81       	ldd	r21, Z+3	; 0x03
    130c:	fd 01       	movw	r30, r26
    130e:	52 83       	std	Z+2, r21	; 0x02
    1310:	41 83       	std	Z+1, r20	; 0x01
    1312:	fc 01       	movw	r30, r24
    1314:	ee 0f       	add	r30, r30
    1316:	ff 1f       	adc	r31, r31
    1318:	ee 0f       	add	r30, r30
    131a:	ff 1f       	adc	r31, r31
    131c:	ee 0f       	add	r30, r30
    131e:	ff 1f       	adc	r31, r31
    1320:	8e 0f       	add	r24, r30
    1322:	9f 1f       	adc	r25, r31
    1324:	fc 01       	movw	r30, r24
    1326:	e0 56       	subi	r30, 0x60	; 96
    1328:	fb 4f       	sbci	r31, 0xFB	; 251
    132a:	01 80       	ldd	r0, Z+1	; 0x01
    132c:	f2 81       	ldd	r31, Z+2	; 0x02
    132e:	e0 2d       	mov	r30, r0
    1330:	86 81       	ldd	r24, Z+6	; 0x06
    1332:	97 81       	ldd	r25, Z+7	; 0x07
    1334:	90 93 f2 04 	sts	0x04F2, r25	; 0x8004f2 <pxCurrentTCB+0x1>
    1338:	80 93 f1 04 	sts	0x04F1, r24	; 0x8004f1 <pxCurrentTCB>
    133c:	20 93 73 04 	sts	0x0473, r18	; 0x800473 <uxTopReadyPriority>
    1340:	08 95       	ret

00001342 <__udivmodsi4>:
    1342:	a1 e2       	ldi	r26, 0x21	; 33
    1344:	1a 2e       	mov	r1, r26
    1346:	aa 1b       	sub	r26, r26
    1348:	bb 1b       	sub	r27, r27
    134a:	fd 01       	movw	r30, r26
    134c:	0d c0       	rjmp	.+26     	; 0x1368 <__udivmodsi4_ep>

0000134e <__udivmodsi4_loop>:
    134e:	aa 1f       	adc	r26, r26
    1350:	bb 1f       	adc	r27, r27
    1352:	ee 1f       	adc	r30, r30
    1354:	ff 1f       	adc	r31, r31
    1356:	a2 17       	cp	r26, r18
    1358:	b3 07       	cpc	r27, r19
    135a:	e4 07       	cpc	r30, r20
    135c:	f5 07       	cpc	r31, r21
    135e:	20 f0       	brcs	.+8      	; 0x1368 <__udivmodsi4_ep>
    1360:	a2 1b       	sub	r26, r18
    1362:	b3 0b       	sbc	r27, r19
    1364:	e4 0b       	sbc	r30, r20
    1366:	f5 0b       	sbc	r31, r21

00001368 <__udivmodsi4_ep>:
    1368:	66 1f       	adc	r22, r22
    136a:	77 1f       	adc	r23, r23
    136c:	88 1f       	adc	r24, r24
    136e:	99 1f       	adc	r25, r25
    1370:	1a 94       	dec	r1
    1372:	69 f7       	brne	.-38     	; 0x134e <__udivmodsi4_loop>
    1374:	60 95       	com	r22
    1376:	70 95       	com	r23
    1378:	80 95       	com	r24
    137a:	90 95       	com	r25
    137c:	9b 01       	movw	r18, r22
    137e:	ac 01       	movw	r20, r24
    1380:	bd 01       	movw	r22, r26
    1382:	cf 01       	movw	r24, r30
    1384:	08 95       	ret

00001386 <__tablejump2__>:
    1386:	ee 0f       	add	r30, r30
    1388:	ff 1f       	adc	r31, r31
    138a:	05 90       	lpm	r0, Z+
    138c:	f4 91       	lpm	r31, Z
    138e:	e0 2d       	mov	r30, r0
    1390:	09 94       	ijmp

00001392 <_exit>:
    1392:	f8 94       	cli

00001394 <__stop_program>:
    1394:	ff cf       	rjmp	.-2      	; 0x1394 <__stop_program>
