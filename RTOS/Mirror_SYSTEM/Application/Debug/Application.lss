
Application.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001732  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003c  00800060  00001732  000017c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000488  0080009c  0080009c  00001802  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001802  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001834  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000408  00000000  00000000  00001870  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004006  00000000  00000000  00001c78  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001395  00000000  00000000  00005c7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002837  00000000  00000000  00007013  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000c1c  00000000  00000000  0000984c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000150f  00000000  00000000  0000a468  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003950  00000000  00000000  0000b977  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000398  00000000  00000000  0000f2c7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 31 00 	jmp	0x62	; 0x62 <__ctors_end>
       4:	0c 94 28 04 	jmp	0x850	; 0x850 <__vector_1>
       8:	0c 94 4f 04 	jmp	0x89e	; 0x89e <__vector_2>
       c:	0c 94 76 04 	jmp	0x8ec	; 0x8ec <__vector_3>
      10:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      14:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      18:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      1c:	0c 94 98 07 	jmp	0xf30	; 0xf30 <__vector_7>
      20:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      24:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      28:	0c 94 c4 04 	jmp	0x988	; 0x988 <__vector_10>
      2c:	0c 94 9d 04 	jmp	0x93a	; 0x93a <__vector_11>
      30:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      34:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      38:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      3c:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      40:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      44:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      48:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      4c:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      50:	0c 94 4e 00 	jmp	0x9c	; 0x9c <__bad_interrupt>
      54:	c5 02       	muls	r28, r21
      56:	cc 02       	muls	r28, r28
      58:	d3 02       	muls	r29, r19
      5a:	da 02       	muls	r29, r26
      5c:	e1 02       	muls	r30, r17
      5e:	e8 02       	muls	r30, r24
      60:	ef 02       	muls	r30, r31

00000062 <__ctors_end>:
      62:	11 24       	eor	r1, r1
      64:	1f be       	out	0x3f, r1	; 63
      66:	cf e5       	ldi	r28, 0x5F	; 95
      68:	d8 e0       	ldi	r29, 0x08	; 8
      6a:	de bf       	out	0x3e, r29	; 62
      6c:	cd bf       	out	0x3d, r28	; 61

0000006e <__do_copy_data>:
      6e:	10 e0       	ldi	r17, 0x00	; 0
      70:	a0 e6       	ldi	r26, 0x60	; 96
      72:	b0 e0       	ldi	r27, 0x00	; 0
      74:	e2 e3       	ldi	r30, 0x32	; 50
      76:	f7 e1       	ldi	r31, 0x17	; 23
      78:	02 c0       	rjmp	.+4      	; 0x7e <__do_copy_data+0x10>
      7a:	05 90       	lpm	r0, Z+
      7c:	0d 92       	st	X+, r0
      7e:	ac 39       	cpi	r26, 0x9C	; 156
      80:	b1 07       	cpc	r27, r17
      82:	d9 f7       	brne	.-10     	; 0x7a <__do_copy_data+0xc>

00000084 <__do_clear_bss>:
      84:	25 e0       	ldi	r18, 0x05	; 5
      86:	ac e9       	ldi	r26, 0x9C	; 156
      88:	b0 e0       	ldi	r27, 0x00	; 0
      8a:	01 c0       	rjmp	.+2      	; 0x8e <.do_clear_bss_start>

0000008c <.do_clear_bss_loop>:
      8c:	1d 92       	st	X+, r1

0000008e <.do_clear_bss_start>:
      8e:	a4 32       	cpi	r26, 0x24	; 36
      90:	b2 07       	cpc	r27, r18
      92:	e1 f7       	brne	.-8      	; 0x8c <.do_clear_bss_loop>
      94:	0e 94 1e 03 	call	0x63c	; 0x63c <main>
      98:	0c 94 97 0b 	jmp	0x172e	; 0x172e <_exit>

0000009c <__bad_interrupt>:
      9c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a0 <KEYPAD_init>:
* Purpose      : initialize keypad 4x4
* Parameters   : void
* Return value : void
*****************************************************************************/
void KEYPAD_init(){
	INIT_KEYPAD_PINS();
      a0:	84 b3       	in	r24, 0x14	; 20
      a2:	80 62       	ori	r24, 0x20	; 32
      a4:	84 bb       	out	0x14, r24	; 20
      a6:	84 b3       	in	r24, 0x14	; 20
      a8:	80 61       	ori	r24, 0x10	; 16
      aa:	84 bb       	out	0x14, r24	; 20
      ac:	84 b3       	in	r24, 0x14	; 20
      ae:	88 60       	ori	r24, 0x08	; 8
      b0:	84 bb       	out	0x14, r24	; 20
      b2:	84 b3       	in	r24, 0x14	; 20
      b4:	84 60       	ori	r24, 0x04	; 4
      b6:	84 bb       	out	0x14, r24	; 20
      b8:	81 b3       	in	r24, 0x11	; 17
      ba:	8f 77       	andi	r24, 0x7F	; 127
      bc:	81 bb       	out	0x11, r24	; 17
      be:	81 b3       	in	r24, 0x11	; 17
      c0:	8f 7b       	andi	r24, 0xBF	; 191
      c2:	81 bb       	out	0x11, r24	; 17
      c4:	81 b3       	in	r24, 0x11	; 17
      c6:	8f 7d       	andi	r24, 0xDF	; 223
      c8:	81 bb       	out	0x11, r24	; 17
      ca:	81 b3       	in	r24, 0x11	; 17
      cc:	87 7f       	andi	r24, 0xF7	; 247
      ce:	81 bb       	out	0x11, r24	; 17
	SETBIT(PORTD, 7); SETBIT(PORTD, 6); SETBIT(PORTD, 5); SETBIT(PORTD, 3);
      d0:	82 b3       	in	r24, 0x12	; 18
      d2:	80 68       	ori	r24, 0x80	; 128
      d4:	82 bb       	out	0x12, r24	; 18
      d6:	82 b3       	in	r24, 0x12	; 18
      d8:	80 64       	ori	r24, 0x40	; 64
      da:	82 bb       	out	0x12, r24	; 18
      dc:	82 b3       	in	r24, 0x12	; 18
      de:	80 62       	ori	r24, 0x20	; 32
      e0:	82 bb       	out	0x12, r24	; 18
      e2:	82 b3       	in	r24, 0x12	; 18
      e4:	88 60       	ori	r24, 0x08	; 8
      e6:	82 bb       	out	0x12, r24	; 18
      e8:	08 95       	ret

000000ea <KEYPAD_read>:
* Purpose      : Read pins of keypad
* Parameters   : void
* Return value : -1 if no press, value if pressed on of push buttons
*****************************************************************************/
int8 KEYPAD_read(){
	ROW1(0);ROW2(1);ROW3(1);ROW4(1);
      ea:	85 b3       	in	r24, 0x15	; 21
      ec:	8f 7d       	andi	r24, 0xDF	; 223
      ee:	85 bb       	out	0x15, r24	; 21
      f0:	85 b3       	in	r24, 0x15	; 21
      f2:	80 61       	ori	r24, 0x10	; 16
      f4:	85 bb       	out	0x15, r24	; 21
      f6:	85 b3       	in	r24, 0x15	; 21
      f8:	88 60       	ori	r24, 0x08	; 8
      fa:	85 bb       	out	0x15, r24	; 21
      fc:	85 b3       	in	r24, 0x15	; 21
      fe:	84 60       	ori	r24, 0x04	; 4
     100:	85 bb       	out	0x15, r24	; 21
	if(COL1() == 0) return keypad_matrix[0];
     102:	87 9b       	sbis	0x10, 7	; 16
     104:	5c c0       	rjmp	.+184    	; 0x1be <KEYPAD_read+0xd4>
	if(COL2() == 0) return keypad_matrix[1];
     106:	86 9b       	sbis	0x10, 6	; 16
     108:	5c c0       	rjmp	.+184    	; 0x1c2 <KEYPAD_read+0xd8>
	if(COL3() == 0) return keypad_matrix[2];
     10a:	85 9b       	sbis	0x10, 5	; 16
     10c:	5c c0       	rjmp	.+184    	; 0x1c6 <KEYPAD_read+0xdc>
	if(COL4() == 0) return keypad_matrix[3];
     10e:	83 9b       	sbis	0x10, 3	; 16
     110:	5c c0       	rjmp	.+184    	; 0x1ca <KEYPAD_read+0xe0>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     112:	8f e1       	ldi	r24, 0x1F	; 31
     114:	9e e4       	ldi	r25, 0x4E	; 78
     116:	01 97       	sbiw	r24, 0x01	; 1
     118:	f1 f7       	brne	.-4      	; 0x116 <KEYPAD_read+0x2c>
     11a:	00 c0       	rjmp	.+0      	; 0x11c <KEYPAD_read+0x32>
     11c:	00 00       	nop
	_delay_ms(5);
	
	ROW1(1);ROW2(0);ROW3(1);ROW4(1);
     11e:	85 b3       	in	r24, 0x15	; 21
     120:	80 62       	ori	r24, 0x20	; 32
     122:	85 bb       	out	0x15, r24	; 21
     124:	85 b3       	in	r24, 0x15	; 21
     126:	8f 7e       	andi	r24, 0xEF	; 239
     128:	85 bb       	out	0x15, r24	; 21
     12a:	85 b3       	in	r24, 0x15	; 21
     12c:	88 60       	ori	r24, 0x08	; 8
     12e:	85 bb       	out	0x15, r24	; 21
     130:	85 b3       	in	r24, 0x15	; 21
     132:	84 60       	ori	r24, 0x04	; 4
     134:	85 bb       	out	0x15, r24	; 21
	if(COL1() == 0) return keypad_matrix[4];
     136:	87 9b       	sbis	0x10, 7	; 16
     138:	4a c0       	rjmp	.+148    	; 0x1ce <KEYPAD_read+0xe4>
	if(COL2() == 0) return keypad_matrix[5];
     13a:	86 9b       	sbis	0x10, 6	; 16
     13c:	4a c0       	rjmp	.+148    	; 0x1d2 <KEYPAD_read+0xe8>
	if(COL3() == 0) return keypad_matrix[6];
     13e:	85 9b       	sbis	0x10, 5	; 16
     140:	4a c0       	rjmp	.+148    	; 0x1d6 <KEYPAD_read+0xec>
	if(COL4() == 0) return keypad_matrix[7];
     142:	83 9b       	sbis	0x10, 3	; 16
     144:	4a c0       	rjmp	.+148    	; 0x1da <KEYPAD_read+0xf0>
     146:	8f e1       	ldi	r24, 0x1F	; 31
     148:	9e e4       	ldi	r25, 0x4E	; 78
     14a:	01 97       	sbiw	r24, 0x01	; 1
     14c:	f1 f7       	brne	.-4      	; 0x14a <KEYPAD_read+0x60>
     14e:	00 c0       	rjmp	.+0      	; 0x150 <KEYPAD_read+0x66>
     150:	00 00       	nop
	_delay_ms(5);
	
	ROW1(1);ROW2(1);ROW3(0);ROW4(1);
     152:	85 b3       	in	r24, 0x15	; 21
     154:	80 62       	ori	r24, 0x20	; 32
     156:	85 bb       	out	0x15, r24	; 21
     158:	85 b3       	in	r24, 0x15	; 21
     15a:	80 61       	ori	r24, 0x10	; 16
     15c:	85 bb       	out	0x15, r24	; 21
     15e:	85 b3       	in	r24, 0x15	; 21
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	85 bb       	out	0x15, r24	; 21
     164:	85 b3       	in	r24, 0x15	; 21
     166:	84 60       	ori	r24, 0x04	; 4
     168:	85 bb       	out	0x15, r24	; 21
	if(COL1() == 0) return keypad_matrix[8];
     16a:	87 9b       	sbis	0x10, 7	; 16
     16c:	38 c0       	rjmp	.+112    	; 0x1de <KEYPAD_read+0xf4>
	if(COL2() == 0) return keypad_matrix[9];
     16e:	86 9b       	sbis	0x10, 6	; 16
     170:	38 c0       	rjmp	.+112    	; 0x1e2 <KEYPAD_read+0xf8>
	if(COL3() == 0) return keypad_matrix[10];
     172:	85 9b       	sbis	0x10, 5	; 16
     174:	38 c0       	rjmp	.+112    	; 0x1e6 <KEYPAD_read+0xfc>
	if(COL4() == 0) return keypad_matrix[11];
     176:	83 9b       	sbis	0x10, 3	; 16
     178:	38 c0       	rjmp	.+112    	; 0x1ea <KEYPAD_read+0x100>
     17a:	8f e1       	ldi	r24, 0x1F	; 31
     17c:	9e e4       	ldi	r25, 0x4E	; 78
     17e:	01 97       	sbiw	r24, 0x01	; 1
     180:	f1 f7       	brne	.-4      	; 0x17e <KEYPAD_read+0x94>
     182:	00 c0       	rjmp	.+0      	; 0x184 <KEYPAD_read+0x9a>
     184:	00 00       	nop
	_delay_ms(5);
	
	ROW1(1);ROW2(1);ROW3(1);ROW4(0);
     186:	85 b3       	in	r24, 0x15	; 21
     188:	80 62       	ori	r24, 0x20	; 32
     18a:	85 bb       	out	0x15, r24	; 21
     18c:	85 b3       	in	r24, 0x15	; 21
     18e:	80 61       	ori	r24, 0x10	; 16
     190:	85 bb       	out	0x15, r24	; 21
     192:	85 b3       	in	r24, 0x15	; 21
     194:	88 60       	ori	r24, 0x08	; 8
     196:	85 bb       	out	0x15, r24	; 21
     198:	85 b3       	in	r24, 0x15	; 21
     19a:	8b 7f       	andi	r24, 0xFB	; 251
     19c:	85 bb       	out	0x15, r24	; 21
	if(COL1() == 0) return keypad_matrix[12];
     19e:	87 9b       	sbis	0x10, 7	; 16
     1a0:	26 c0       	rjmp	.+76     	; 0x1ee <KEYPAD_read+0x104>
	if(COL2() == 0) return keypad_matrix[13];
     1a2:	86 9b       	sbis	0x10, 6	; 16
     1a4:	26 c0       	rjmp	.+76     	; 0x1f2 <KEYPAD_read+0x108>
	if(COL3() == 0) return keypad_matrix[14];
     1a6:	85 9b       	sbis	0x10, 5	; 16
     1a8:	26 c0       	rjmp	.+76     	; 0x1f6 <KEYPAD_read+0x10c>
	if(COL4() == 0) return keypad_matrix[15];
     1aa:	83 9b       	sbis	0x10, 3	; 16
     1ac:	26 c0       	rjmp	.+76     	; 0x1fa <KEYPAD_read+0x110>
     1ae:	8f e1       	ldi	r24, 0x1F	; 31
     1b0:	9e e4       	ldi	r25, 0x4E	; 78
     1b2:	01 97       	sbiw	r24, 0x01	; 1
     1b4:	f1 f7       	brne	.-4      	; 0x1b2 <KEYPAD_read+0xc8>
     1b6:	00 c0       	rjmp	.+0      	; 0x1b8 <KEYPAD_read+0xce>
     1b8:	00 00       	nop
	_delay_ms(5);
	
	return -1;
     1ba:	8f ef       	ldi	r24, 0xFF	; 255
     1bc:	08 95       	ret
* Parameters   : void
* Return value : -1 if no press, value if pressed on of push buttons
*****************************************************************************/
int8 KEYPAD_read(){
	ROW1(0);ROW2(1);ROW3(1);ROW4(1);
	if(COL1() == 0) return keypad_matrix[0];
     1be:	80 e0       	ldi	r24, 0x00	; 0
     1c0:	08 95       	ret
	if(COL2() == 0) return keypad_matrix[1];
     1c2:	81 e0       	ldi	r24, 0x01	; 1
     1c4:	08 95       	ret
	if(COL3() == 0) return keypad_matrix[2];
     1c6:	80 e0       	ldi	r24, 0x00	; 0
     1c8:	08 95       	ret
	if(COL4() == 0) return keypad_matrix[3];
     1ca:	80 e0       	ldi	r24, 0x00	; 0
     1cc:	08 95       	ret
	_delay_ms(5);
	
	ROW1(1);ROW2(0);ROW3(1);ROW4(1);
	if(COL1() == 0) return keypad_matrix[4];
     1ce:	82 e0       	ldi	r24, 0x02	; 2
     1d0:	08 95       	ret
	if(COL2() == 0) return keypad_matrix[5];
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret
	if(COL3() == 0) return keypad_matrix[6];
     1d6:	83 e0       	ldi	r24, 0x03	; 3
     1d8:	08 95       	ret
	if(COL4() == 0) return keypad_matrix[7];
     1da:	80 e0       	ldi	r24, 0x00	; 0
     1dc:	08 95       	ret
	_delay_ms(5);
	
	ROW1(1);ROW2(1);ROW3(0);ROW4(1);
	if(COL1() == 0) return keypad_matrix[8];
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	08 95       	ret
	if(COL2() == 0) return keypad_matrix[9];
     1e2:	84 e0       	ldi	r24, 0x04	; 4
     1e4:	08 95       	ret
	if(COL3() == 0) return keypad_matrix[10];
     1e6:	80 e0       	ldi	r24, 0x00	; 0
     1e8:	08 95       	ret
	if(COL4() == 0) return keypad_matrix[11];
     1ea:	80 e0       	ldi	r24, 0x00	; 0
     1ec:	08 95       	ret
	_delay_ms(5);
	
	ROW1(1);ROW2(1);ROW3(1);ROW4(0);
	if(COL1() == 0) return keypad_matrix[12];
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	08 95       	ret
	if(COL2() == 0) return keypad_matrix[13];
     1f2:	87 e0       	ldi	r24, 0x07	; 7
     1f4:	08 95       	ret
	if(COL3() == 0) return keypad_matrix[14];
     1f6:	86 e0       	ldi	r24, 0x06	; 6
     1f8:	08 95       	ret
	if(COL4() == 0) return keypad_matrix[15];
     1fa:	85 e0       	ldi	r24, 0x05	; 5
	_delay_ms(5);
	
	return -1;
}
     1fc:	08 95       	ret

000001fe <get_input_from_user>:

uint8 get_input_from_user(){
     1fe:	cf 93       	push	r28
	int8 key;
	
	do{
		key = KEYPAD_read();
     200:	0e 94 75 00 	call	0xea	; 0xea <KEYPAD_read>
     204:	c8 2f       	mov	r28, r24
	}while(key == -1);
     206:	8f 3f       	cpi	r24, 0xFF	; 255
     208:	d9 f3       	breq	.-10     	; 0x200 <get_input_from_user+0x2>
	
	LCD_write_command(0x80);
     20a:	80 e8       	ldi	r24, 0x80	; 128
     20c:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
	LCD_write_number(key);
     210:	6c 2f       	mov	r22, r28
     212:	0c 2e       	mov	r0, r28
     214:	00 0c       	add	r0, r0
     216:	77 0b       	sbc	r23, r23
     218:	88 0b       	sbc	r24, r24
     21a:	99 0b       	sbc	r25, r25
     21c:	0e 94 2b 02 	call	0x456	; 0x456 <LCD_write_number>
	while(KEYPAD_read() != -1);
     220:	0e 94 75 00 	call	0xea	; 0xea <KEYPAD_read>
     224:	8f 3f       	cpi	r24, 0xFF	; 255
     226:	e1 f7       	brne	.-8      	; 0x220 <get_input_from_user+0x22>
	
	return key;
}
     228:	8c 2f       	mov	r24, r28
     22a:	cf 91       	pop	r28
     22c:	08 95       	ret

0000022e <LCD_write_char>:
     22e:	9b b3       	in	r25, 0x1b	; 27
     230:	98 60       	ori	r25, 0x08	; 8
     232:	9b bb       	out	0x1b, r25	; 27
     234:	84 ff       	sbrs	r24, 4
     236:	04 c0       	rjmp	.+8      	; 0x240 <LCD_write_char+0x12>
     238:	98 b3       	in	r25, 0x18	; 24
     23a:	91 60       	ori	r25, 0x01	; 1
     23c:	98 bb       	out	0x18, r25	; 24
     23e:	03 c0       	rjmp	.+6      	; 0x246 <LCD_write_char+0x18>
     240:	98 b3       	in	r25, 0x18	; 24
     242:	9e 7f       	andi	r25, 0xFE	; 254
     244:	98 bb       	out	0x18, r25	; 24
     246:	85 ff       	sbrs	r24, 5
     248:	04 c0       	rjmp	.+8      	; 0x252 <LCD_write_char+0x24>
     24a:	98 b3       	in	r25, 0x18	; 24
     24c:	92 60       	ori	r25, 0x02	; 2
     24e:	98 bb       	out	0x18, r25	; 24
     250:	03 c0       	rjmp	.+6      	; 0x258 <LCD_write_char+0x2a>
     252:	98 b3       	in	r25, 0x18	; 24
     254:	9d 7f       	andi	r25, 0xFD	; 253
     256:	98 bb       	out	0x18, r25	; 24
     258:	86 ff       	sbrs	r24, 6
     25a:	04 c0       	rjmp	.+8      	; 0x264 <LCD_write_char+0x36>
     25c:	98 b3       	in	r25, 0x18	; 24
     25e:	94 60       	ori	r25, 0x04	; 4
     260:	98 bb       	out	0x18, r25	; 24
     262:	03 c0       	rjmp	.+6      	; 0x26a <LCD_write_char+0x3c>
     264:	98 b3       	in	r25, 0x18	; 24
     266:	9b 7f       	andi	r25, 0xFB	; 251
     268:	98 bb       	out	0x18, r25	; 24
     26a:	88 23       	and	r24, r24
     26c:	24 f4       	brge	.+8      	; 0x276 <LCD_write_char+0x48>
     26e:	98 b3       	in	r25, 0x18	; 24
     270:	90 61       	ori	r25, 0x10	; 16
     272:	98 bb       	out	0x18, r25	; 24
     274:	03 c0       	rjmp	.+6      	; 0x27c <LCD_write_char+0x4e>
     276:	98 b3       	in	r25, 0x18	; 24
     278:	9f 7e       	andi	r25, 0xEF	; 239
     27a:	98 bb       	out	0x18, r25	; 24
     27c:	9b b3       	in	r25, 0x1b	; 27
     27e:	94 60       	ori	r25, 0x04	; 4
     280:	9b bb       	out	0x1b, r25	; 27
     282:	ef e9       	ldi	r30, 0x9F	; 159
     284:	ff e0       	ldi	r31, 0x0F	; 15
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	f1 f7       	brne	.-4      	; 0x286 <LCD_write_char+0x58>
     28a:	00 c0       	rjmp	.+0      	; 0x28c <LCD_write_char+0x5e>
     28c:	00 00       	nop
     28e:	9b b3       	in	r25, 0x1b	; 27
     290:	9b 7f       	andi	r25, 0xFB	; 251
     292:	9b bb       	out	0x1b, r25	; 27
     294:	ef e9       	ldi	r30, 0x9F	; 159
     296:	ff e0       	ldi	r31, 0x0F	; 15
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	f1 f7       	brne	.-4      	; 0x298 <LCD_write_char+0x6a>
     29c:	00 c0       	rjmp	.+0      	; 0x29e <LCD_write_char+0x70>
     29e:	00 00       	nop
     2a0:	80 ff       	sbrs	r24, 0
     2a2:	04 c0       	rjmp	.+8      	; 0x2ac <LCD_write_char+0x7e>
     2a4:	98 b3       	in	r25, 0x18	; 24
     2a6:	91 60       	ori	r25, 0x01	; 1
     2a8:	98 bb       	out	0x18, r25	; 24
     2aa:	03 c0       	rjmp	.+6      	; 0x2b2 <LCD_write_char+0x84>
     2ac:	98 b3       	in	r25, 0x18	; 24
     2ae:	9e 7f       	andi	r25, 0xFE	; 254
     2b0:	98 bb       	out	0x18, r25	; 24
     2b2:	81 ff       	sbrs	r24, 1
     2b4:	04 c0       	rjmp	.+8      	; 0x2be <LCD_write_char+0x90>
     2b6:	98 b3       	in	r25, 0x18	; 24
     2b8:	92 60       	ori	r25, 0x02	; 2
     2ba:	98 bb       	out	0x18, r25	; 24
     2bc:	03 c0       	rjmp	.+6      	; 0x2c4 <LCD_write_char+0x96>
     2be:	98 b3       	in	r25, 0x18	; 24
     2c0:	9d 7f       	andi	r25, 0xFD	; 253
     2c2:	98 bb       	out	0x18, r25	; 24
     2c4:	82 ff       	sbrs	r24, 2
     2c6:	04 c0       	rjmp	.+8      	; 0x2d0 <LCD_write_char+0xa2>
     2c8:	98 b3       	in	r25, 0x18	; 24
     2ca:	94 60       	ori	r25, 0x04	; 4
     2cc:	98 bb       	out	0x18, r25	; 24
     2ce:	03 c0       	rjmp	.+6      	; 0x2d6 <LCD_write_char+0xa8>
     2d0:	98 b3       	in	r25, 0x18	; 24
     2d2:	9b 7f       	andi	r25, 0xFB	; 251
     2d4:	98 bb       	out	0x18, r25	; 24
     2d6:	83 ff       	sbrs	r24, 3
     2d8:	04 c0       	rjmp	.+8      	; 0x2e2 <LCD_write_char+0xb4>
     2da:	88 b3       	in	r24, 0x18	; 24
     2dc:	80 61       	ori	r24, 0x10	; 16
     2de:	88 bb       	out	0x18, r24	; 24
     2e0:	03 c0       	rjmp	.+6      	; 0x2e8 <LCD_write_char+0xba>
     2e2:	88 b3       	in	r24, 0x18	; 24
     2e4:	8f 7e       	andi	r24, 0xEF	; 239
     2e6:	88 bb       	out	0x18, r24	; 24
     2e8:	8b b3       	in	r24, 0x1b	; 27
     2ea:	84 60       	ori	r24, 0x04	; 4
     2ec:	8b bb       	out	0x1b, r24	; 27
     2ee:	8f e9       	ldi	r24, 0x9F	; 159
     2f0:	9f e0       	ldi	r25, 0x0F	; 15
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	f1 f7       	brne	.-4      	; 0x2f2 <LCD_write_char+0xc4>
     2f6:	00 c0       	rjmp	.+0      	; 0x2f8 <LCD_write_char+0xca>
     2f8:	00 00       	nop
     2fa:	8b b3       	in	r24, 0x1b	; 27
     2fc:	8b 7f       	andi	r24, 0xFB	; 251
     2fe:	8b bb       	out	0x1b, r24	; 27
     300:	ef e9       	ldi	r30, 0x9F	; 159
     302:	ff e0       	ldi	r31, 0x0F	; 15
     304:	31 97       	sbiw	r30, 0x01	; 1
     306:	f1 f7       	brne	.-4      	; 0x304 <LCD_write_char+0xd6>
     308:	00 c0       	rjmp	.+0      	; 0x30a <LCD_write_char+0xdc>
     30a:	00 00       	nop
     30c:	08 95       	ret

0000030e <LCD_write_command>:
     30e:	9b b3       	in	r25, 0x1b	; 27
     310:	97 7f       	andi	r25, 0xF7	; 247
     312:	9b bb       	out	0x1b, r25	; 27
     314:	84 ff       	sbrs	r24, 4
     316:	04 c0       	rjmp	.+8      	; 0x320 <LCD_write_command+0x12>
     318:	98 b3       	in	r25, 0x18	; 24
     31a:	91 60       	ori	r25, 0x01	; 1
     31c:	98 bb       	out	0x18, r25	; 24
     31e:	03 c0       	rjmp	.+6      	; 0x326 <LCD_write_command+0x18>
     320:	98 b3       	in	r25, 0x18	; 24
     322:	9e 7f       	andi	r25, 0xFE	; 254
     324:	98 bb       	out	0x18, r25	; 24
     326:	85 ff       	sbrs	r24, 5
     328:	04 c0       	rjmp	.+8      	; 0x332 <LCD_write_command+0x24>
     32a:	98 b3       	in	r25, 0x18	; 24
     32c:	92 60       	ori	r25, 0x02	; 2
     32e:	98 bb       	out	0x18, r25	; 24
     330:	03 c0       	rjmp	.+6      	; 0x338 <LCD_write_command+0x2a>
     332:	98 b3       	in	r25, 0x18	; 24
     334:	9d 7f       	andi	r25, 0xFD	; 253
     336:	98 bb       	out	0x18, r25	; 24
     338:	86 ff       	sbrs	r24, 6
     33a:	04 c0       	rjmp	.+8      	; 0x344 <LCD_write_command+0x36>
     33c:	98 b3       	in	r25, 0x18	; 24
     33e:	94 60       	ori	r25, 0x04	; 4
     340:	98 bb       	out	0x18, r25	; 24
     342:	03 c0       	rjmp	.+6      	; 0x34a <LCD_write_command+0x3c>
     344:	98 b3       	in	r25, 0x18	; 24
     346:	9b 7f       	andi	r25, 0xFB	; 251
     348:	98 bb       	out	0x18, r25	; 24
     34a:	88 23       	and	r24, r24
     34c:	24 f4       	brge	.+8      	; 0x356 <LCD_write_command+0x48>
     34e:	98 b3       	in	r25, 0x18	; 24
     350:	90 61       	ori	r25, 0x10	; 16
     352:	98 bb       	out	0x18, r25	; 24
     354:	03 c0       	rjmp	.+6      	; 0x35c <LCD_write_command+0x4e>
     356:	98 b3       	in	r25, 0x18	; 24
     358:	9f 7e       	andi	r25, 0xEF	; 239
     35a:	98 bb       	out	0x18, r25	; 24
     35c:	9b b3       	in	r25, 0x1b	; 27
     35e:	94 60       	ori	r25, 0x04	; 4
     360:	9b bb       	out	0x1b, r25	; 27
     362:	ef e9       	ldi	r30, 0x9F	; 159
     364:	ff e0       	ldi	r31, 0x0F	; 15
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	f1 f7       	brne	.-4      	; 0x366 <LCD_write_command+0x58>
     36a:	00 c0       	rjmp	.+0      	; 0x36c <LCD_write_command+0x5e>
     36c:	00 00       	nop
     36e:	9b b3       	in	r25, 0x1b	; 27
     370:	9b 7f       	andi	r25, 0xFB	; 251
     372:	9b bb       	out	0x1b, r25	; 27
     374:	ef e9       	ldi	r30, 0x9F	; 159
     376:	ff e0       	ldi	r31, 0x0F	; 15
     378:	31 97       	sbiw	r30, 0x01	; 1
     37a:	f1 f7       	brne	.-4      	; 0x378 <LCD_write_command+0x6a>
     37c:	00 c0       	rjmp	.+0      	; 0x37e <LCD_write_command+0x70>
     37e:	00 00       	nop
     380:	80 ff       	sbrs	r24, 0
     382:	04 c0       	rjmp	.+8      	; 0x38c <LCD_write_command+0x7e>
     384:	98 b3       	in	r25, 0x18	; 24
     386:	91 60       	ori	r25, 0x01	; 1
     388:	98 bb       	out	0x18, r25	; 24
     38a:	03 c0       	rjmp	.+6      	; 0x392 <LCD_write_command+0x84>
     38c:	98 b3       	in	r25, 0x18	; 24
     38e:	9e 7f       	andi	r25, 0xFE	; 254
     390:	98 bb       	out	0x18, r25	; 24
     392:	81 ff       	sbrs	r24, 1
     394:	04 c0       	rjmp	.+8      	; 0x39e <LCD_write_command+0x90>
     396:	98 b3       	in	r25, 0x18	; 24
     398:	92 60       	ori	r25, 0x02	; 2
     39a:	98 bb       	out	0x18, r25	; 24
     39c:	03 c0       	rjmp	.+6      	; 0x3a4 <LCD_write_command+0x96>
     39e:	98 b3       	in	r25, 0x18	; 24
     3a0:	9d 7f       	andi	r25, 0xFD	; 253
     3a2:	98 bb       	out	0x18, r25	; 24
     3a4:	82 ff       	sbrs	r24, 2
     3a6:	04 c0       	rjmp	.+8      	; 0x3b0 <LCD_write_command+0xa2>
     3a8:	98 b3       	in	r25, 0x18	; 24
     3aa:	94 60       	ori	r25, 0x04	; 4
     3ac:	98 bb       	out	0x18, r25	; 24
     3ae:	03 c0       	rjmp	.+6      	; 0x3b6 <LCD_write_command+0xa8>
     3b0:	98 b3       	in	r25, 0x18	; 24
     3b2:	9b 7f       	andi	r25, 0xFB	; 251
     3b4:	98 bb       	out	0x18, r25	; 24
     3b6:	83 ff       	sbrs	r24, 3
     3b8:	04 c0       	rjmp	.+8      	; 0x3c2 <LCD_write_command+0xb4>
     3ba:	88 b3       	in	r24, 0x18	; 24
     3bc:	80 61       	ori	r24, 0x10	; 16
     3be:	88 bb       	out	0x18, r24	; 24
     3c0:	03 c0       	rjmp	.+6      	; 0x3c8 <LCD_write_command+0xba>
     3c2:	88 b3       	in	r24, 0x18	; 24
     3c4:	8f 7e       	andi	r24, 0xEF	; 239
     3c6:	88 bb       	out	0x18, r24	; 24
     3c8:	8b b3       	in	r24, 0x1b	; 27
     3ca:	84 60       	ori	r24, 0x04	; 4
     3cc:	8b bb       	out	0x1b, r24	; 27
     3ce:	8f e9       	ldi	r24, 0x9F	; 159
     3d0:	9f e0       	ldi	r25, 0x0F	; 15
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	f1 f7       	brne	.-4      	; 0x3d2 <LCD_write_command+0xc4>
     3d6:	00 c0       	rjmp	.+0      	; 0x3d8 <LCD_write_command+0xca>
     3d8:	00 00       	nop
     3da:	8b b3       	in	r24, 0x1b	; 27
     3dc:	8b 7f       	andi	r24, 0xFB	; 251
     3de:	8b bb       	out	0x1b, r24	; 27
     3e0:	ef e9       	ldi	r30, 0x9F	; 159
     3e2:	ff e0       	ldi	r31, 0x0F	; 15
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	f1 f7       	brne	.-4      	; 0x3e4 <LCD_write_command+0xd6>
     3e8:	00 c0       	rjmp	.+0      	; 0x3ea <LCD_write_command+0xdc>
     3ea:	00 00       	nop
     3ec:	08 95       	ret

000003ee <LCD_init>:
     3ee:	8a b3       	in	r24, 0x1a	; 26
     3f0:	88 60       	ori	r24, 0x08	; 8
     3f2:	8a bb       	out	0x1a, r24	; 26
     3f4:	8a b3       	in	r24, 0x1a	; 26
     3f6:	84 60       	ori	r24, 0x04	; 4
     3f8:	8a bb       	out	0x1a, r24	; 26
     3fa:	87 b3       	in	r24, 0x17	; 23
     3fc:	81 60       	ori	r24, 0x01	; 1
     3fe:	87 bb       	out	0x17, r24	; 23
     400:	87 b3       	in	r24, 0x17	; 23
     402:	82 60       	ori	r24, 0x02	; 2
     404:	87 bb       	out	0x17, r24	; 23
     406:	87 b3       	in	r24, 0x17	; 23
     408:	84 60       	ori	r24, 0x04	; 4
     40a:	87 bb       	out	0x17, r24	; 23
     40c:	87 b3       	in	r24, 0x17	; 23
     40e:	80 61       	ori	r24, 0x10	; 16
     410:	87 bb       	out	0x17, r24	; 23
     412:	2f ef       	ldi	r18, 0xFF	; 255
     414:	89 ef       	ldi	r24, 0xF9	; 249
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	21 50       	subi	r18, 0x01	; 1
     41a:	80 40       	sbci	r24, 0x00	; 0
     41c:	90 40       	sbci	r25, 0x00	; 0
     41e:	e1 f7       	brne	.-8      	; 0x418 <__EEPROM_REGION_LENGTH__+0x18>
     420:	00 c0       	rjmp	.+0      	; 0x422 <__EEPROM_REGION_LENGTH__+0x22>
     422:	00 00       	nop
     424:	82 e0       	ldi	r24, 0x02	; 2
     426:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
     42a:	88 e2       	ldi	r24, 0x28	; 40
     42c:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
     430:	8c e0       	ldi	r24, 0x0C	; 12
     432:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
     436:	86 e0       	ldi	r24, 0x06	; 6
     438:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
     43c:	81 e0       	ldi	r24, 0x01	; 1
     43e:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
     442:	2f ef       	ldi	r18, 0xFF	; 255
     444:	86 e7       	ldi	r24, 0x76	; 118
     446:	91 e0       	ldi	r25, 0x01	; 1
     448:	21 50       	subi	r18, 0x01	; 1
     44a:	80 40       	sbci	r24, 0x00	; 0
     44c:	90 40       	sbci	r25, 0x00	; 0
     44e:	e1 f7       	brne	.-8      	; 0x448 <__EEPROM_REGION_LENGTH__+0x48>
     450:	00 c0       	rjmp	.+0      	; 0x452 <__EEPROM_REGION_LENGTH__+0x52>
     452:	00 00       	nop
     454:	08 95       	ret

00000456 <LCD_write_number>:
     456:	0f 93       	push	r16
     458:	1f 93       	push	r17
     45a:	cf 93       	push	r28
     45c:	df 93       	push	r29
     45e:	cd b7       	in	r28, 0x3d	; 61
     460:	de b7       	in	r29, 0x3e	; 62
     462:	2a 97       	sbiw	r28, 0x0a	; 10
     464:	0f b6       	in	r0, 0x3f	; 63
     466:	f8 94       	cli
     468:	de bf       	out	0x3e, r29	; 62
     46a:	0f be       	out	0x3f, r0	; 63
     46c:	cd bf       	out	0x3d, r28	; 61
     46e:	99 23       	and	r25, r25
     470:	4c f4       	brge	.+18     	; 0x484 <LCD_write_number+0x2e>
     472:	90 95       	com	r25
     474:	80 95       	com	r24
     476:	70 95       	com	r23
     478:	61 95       	neg	r22
     47a:	7f 4f       	sbci	r23, 0xFF	; 255
     47c:	8f 4f       	sbci	r24, 0xFF	; 255
     47e:	9f 4f       	sbci	r25, 0xFF	; 255
     480:	01 e0       	ldi	r16, 0x01	; 1
     482:	01 c0       	rjmp	.+2      	; 0x486 <LCD_write_number+0x30>
     484:	00 e0       	ldi	r16, 0x00	; 0
     486:	61 15       	cp	r22, r1
     488:	71 05       	cpc	r23, r1
     48a:	81 05       	cpc	r24, r1
     48c:	91 05       	cpc	r25, r1
     48e:	d1 f4       	brne	.+52     	; 0x4c4 <LCD_write_number+0x6e>
     490:	80 e3       	ldi	r24, 0x30	; 48
     492:	0e 94 17 01 	call	0x22e	; 0x22e <LCD_write_char>
     496:	31 c0       	rjmp	.+98     	; 0x4fa <LCD_write_number+0xa4>
     498:	2a e0       	ldi	r18, 0x0A	; 10
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	40 e0       	ldi	r20, 0x00	; 0
     49e:	50 e0       	ldi	r21, 0x00	; 0
     4a0:	0e 94 72 0b 	call	0x16e4	; 0x16e4 <__divmodsi4>
     4a4:	e1 e0       	ldi	r30, 0x01	; 1
     4a6:	f0 e0       	ldi	r31, 0x00	; 0
     4a8:	ec 0f       	add	r30, r28
     4aa:	fd 1f       	adc	r31, r29
     4ac:	e1 0f       	add	r30, r17
     4ae:	f1 1d       	adc	r31, r1
     4b0:	17 fd       	sbrc	r17, 7
     4b2:	fa 95       	dec	r31
     4b4:	60 5d       	subi	r22, 0xD0	; 208
     4b6:	60 83       	st	Z, r22
     4b8:	62 2f       	mov	r22, r18
     4ba:	73 2f       	mov	r23, r19
     4bc:	84 2f       	mov	r24, r20
     4be:	95 2f       	mov	r25, r21
     4c0:	1f 5f       	subi	r17, 0xFF	; 255
     4c2:	01 c0       	rjmp	.+2      	; 0x4c6 <LCD_write_number+0x70>
     4c4:	10 e0       	ldi	r17, 0x00	; 0
     4c6:	61 15       	cp	r22, r1
     4c8:	71 05       	cpc	r23, r1
     4ca:	81 05       	cpc	r24, r1
     4cc:	91 05       	cpc	r25, r1
     4ce:	21 f7       	brne	.-56     	; 0x498 <LCD_write_number+0x42>
     4d0:	11 50       	subi	r17, 0x01	; 1
     4d2:	01 30       	cpi	r16, 0x01	; 1
     4d4:	81 f4       	brne	.+32     	; 0x4f6 <LCD_write_number+0xa0>
     4d6:	8d e2       	ldi	r24, 0x2D	; 45
     4d8:	0e 94 17 01 	call	0x22e	; 0x22e <LCD_write_char>
     4dc:	0c c0       	rjmp	.+24     	; 0x4f6 <LCD_write_number+0xa0>
     4de:	e1 e0       	ldi	r30, 0x01	; 1
     4e0:	f0 e0       	ldi	r31, 0x00	; 0
     4e2:	ec 0f       	add	r30, r28
     4e4:	fd 1f       	adc	r31, r29
     4e6:	e1 0f       	add	r30, r17
     4e8:	f1 1d       	adc	r31, r1
     4ea:	17 fd       	sbrc	r17, 7
     4ec:	fa 95       	dec	r31
     4ee:	80 81       	ld	r24, Z
     4f0:	0e 94 17 01 	call	0x22e	; 0x22e <LCD_write_char>
     4f4:	11 50       	subi	r17, 0x01	; 1
     4f6:	11 23       	and	r17, r17
     4f8:	94 f7       	brge	.-28     	; 0x4de <LCD_write_number+0x88>
     4fa:	2a 96       	adiw	r28, 0x0a	; 10
     4fc:	0f b6       	in	r0, 0x3f	; 63
     4fe:	f8 94       	cli
     500:	de bf       	out	0x3e, r29	; 62
     502:	0f be       	out	0x3f, r0	; 63
     504:	cd bf       	out	0x3d, r28	; 61
     506:	df 91       	pop	r29
     508:	cf 91       	pop	r28
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	08 95       	ret

00000510 <LCD_write_string>:
     510:	0f 93       	push	r16
     512:	1f 93       	push	r17
     514:	cf 93       	push	r28
     516:	8c 01       	movw	r16, r24
     518:	c0 e0       	ldi	r28, 0x00	; 0
     51a:	03 c0       	rjmp	.+6      	; 0x522 <LCD_write_string+0x12>
     51c:	0e 94 17 01 	call	0x22e	; 0x22e <LCD_write_char>
     520:	cf 5f       	subi	r28, 0xFF	; 255
     522:	f8 01       	movw	r30, r16
     524:	ec 0f       	add	r30, r28
     526:	f1 1d       	adc	r31, r1
     528:	80 81       	ld	r24, Z
     52a:	81 11       	cpse	r24, r1
     52c:	f7 cf       	rjmp	.-18     	; 0x51c <LCD_write_string+0xc>
     52e:	cf 91       	pop	r28
     530:	1f 91       	pop	r17
     532:	0f 91       	pop	r16
     534:	08 95       	ret

00000536 <led_init>:
     536:	41 e0       	ldi	r20, 0x01	; 1
     538:	0e 94 40 03 	call	0x680	; 0x680 <DIO_voidSetPinDirection>
     53c:	08 95       	ret

0000053e <led_on>:
     53e:	41 e0       	ldi	r20, 0x01	; 1
     540:	0e 94 b4 03 	call	0x768	; 0x768 <DIO_voidSetPinValue>
     544:	08 95       	ret

00000546 <led_off>:
     546:	40 e0       	ldi	r20, 0x00	; 0
     548:	0e 94 b4 03 	call	0x768	; 0x768 <DIO_voidSetPinValue>
     54c:	08 95       	ret

0000054e <Task_Keypad>:
uint8 volatile SENSOR_PUSH_BUTTON = 0;



void Task_Keypad(void){
	KEYPAD_init();
     54e:	0e 94 50 00 	call	0xa0	; 0xa0 <KEYPAD_init>
	LCD_init();
     552:	0e 94 f7 01 	call	0x3ee	; 0x3ee <LCD_init>
	uint8 temp;
	
	while (1)
	{
		
		temp = get_input_from_user();
     556:	0e 94 ff 00 	call	0x1fe	; 0x1fe <get_input_from_user>
     55a:	c8 2f       	mov	r28, r24
		SENSOR_PUSH_BUTTON = temp;
     55c:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <SENSOR_PUSH_BUTTON>
		LCD_write_command(0xc0);
     560:	80 ec       	ldi	r24, 0xC0	; 192
     562:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
		LCD_write_string("      ");
     566:	82 e6       	ldi	r24, 0x62	; 98
     568:	90 e0       	ldi	r25, 0x00	; 0
     56a:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
		LCD_write_command(0xc0);
     56e:	80 ec       	ldi	r24, 0xC0	; 192
     570:	0e 94 87 01 	call	0x30e	; 0x30e <LCD_write_command>
		switch(temp){
     574:	8c 2f       	mov	r24, r28
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	fc 01       	movw	r30, r24
     57a:	31 97       	sbiw	r30, 0x01	; 1
     57c:	e7 30       	cpi	r30, 0x07	; 7
     57e:	f1 05       	cpc	r31, r1
     580:	a0 f5       	brcc	.+104    	; 0x5ea <Task_Keypad+0x9c>
     582:	e6 5d       	subi	r30, 0xD6	; 214
     584:	ff 4f       	sbci	r31, 0xFF	; 255
     586:	0c 94 91 0b 	jmp	0x1722	; 0x1722 <__tablejump2__>
			case 1: Direction = temp; LCD_write_string("Up"); break;
     58a:	c0 93 a0 00 	sts	0x00A0, r28	; 0x8000a0 <Direction>
     58e:	89 e6       	ldi	r24, 0x69	; 105
     590:	90 e0       	ldi	r25, 0x00	; 0
     592:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     596:	29 c0       	rjmp	.+82     	; 0x5ea <Task_Keypad+0x9c>
			case 2: Direction = temp; LCD_write_string("LL"); break;
     598:	c0 93 a0 00 	sts	0x00A0, r28	; 0x8000a0 <Direction>
     59c:	8c e6       	ldi	r24, 0x6C	; 108
     59e:	90 e0       	ldi	r25, 0x00	; 0
     5a0:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     5a4:	22 c0       	rjmp	.+68     	; 0x5ea <Task_Keypad+0x9c>
			case 3: Direction = temp; LCD_write_string("RR"); break;
     5a6:	c0 93 a0 00 	sts	0x00A0, r28	; 0x8000a0 <Direction>
     5aa:	8f e6       	ldi	r24, 0x6F	; 111
     5ac:	90 e0       	ldi	r25, 0x00	; 0
     5ae:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     5b2:	1b c0       	rjmp	.+54     	; 0x5ea <Task_Keypad+0x9c>
			case 4: Direction = temp; LCD_write_string("down"); break;
     5b4:	c0 93 a0 00 	sts	0x00A0, r28	; 0x8000a0 <Direction>
     5b8:	82 e7       	ldi	r24, 0x72	; 114
     5ba:	90 e0       	ldi	r25, 0x00	; 0
     5bc:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     5c0:	14 c0       	rjmp	.+40     	; 0x5ea <Task_Keypad+0x9c>
			case 5: State = temp; LCD_write_string("Left"); break;
     5c2:	c0 93 9f 00 	sts	0x009F, r28	; 0x80009f <State>
     5c6:	87 e7       	ldi	r24, 0x77	; 119
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     5ce:	0d c0       	rjmp	.+26     	; 0x5ea <Task_Keypad+0x9c>
			case 6: State = temp; LCD_write_string("Right"); break;
     5d0:	c0 93 9f 00 	sts	0x009F, r28	; 0x80009f <State>
     5d4:	8c e7       	ldi	r24, 0x7C	; 124
     5d6:	90 e0       	ldi	r25, 0x00	; 0
     5d8:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>
     5dc:	06 c0       	rjmp	.+12     	; 0x5ea <Task_Keypad+0x9c>
			case 7: State = temp; LCD_write_string("Main"); break;
     5de:	c0 93 9f 00 	sts	0x009F, r28	; 0x80009f <State>
     5e2:	82 e8       	ldi	r24, 0x82	; 130
     5e4:	90 e0       	ldi	r25, 0x00	; 0
     5e6:	0e 94 88 02 	call	0x510	; 0x510 <LCD_write_string>

		}
		
		vTaskDelay(1);
     5ea:	81 e0       	ldi	r24, 0x01	; 1
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	0e 94 b5 0a 	call	0x156a	; 0x156a <vTaskDelay>
	}
     5f2:	b1 cf       	rjmp	.-158    	; 0x556 <Task_Keypad+0x8>

000005f4 <Task_Measure>:
*/

void Task_Measure(void){

	static uint8 flag = 0;
	led_init(portA, 5);
     5f4:	65 e0       	ldi	r22, 0x05	; 5
     5f6:	81 e4       	ldi	r24, 0x41	; 65
     5f8:	0e 94 9b 02 	call	0x536	; 0x536 <led_init>

	while (1)
	{
		if (SENSOR_PUSH_BUTTON == 7)
     5fc:	80 91 9d 00 	lds	r24, 0x009D	; 0x80009d <SENSOR_PUSH_BUTTON>
     600:	87 30       	cpi	r24, 0x07	; 7
     602:	b9 f4       	brne	.+46     	; 0x632 <Task_Measure+0x3e>
		{
			if(flag==0)
     604:	80 91 9c 00 	lds	r24, 0x009C	; 0x80009c <__data_end>
     608:	81 11       	cpse	r24, r1
     60a:	0a c0       	rjmp	.+20     	; 0x620 <Task_Measure+0x2c>
			{
				Message= MAIN_MOTOR_ON;
     60c:	10 92 9e 00 	sts	0x009E, r1	; 0x80009e <Message>
				flag=1;
     610:	81 e0       	ldi	r24, 0x01	; 1
     612:	80 93 9c 00 	sts	0x009C, r24	; 0x80009c <__data_end>
				led_on(portA, 5);
     616:	65 e0       	ldi	r22, 0x05	; 5
     618:	81 e4       	ldi	r24, 0x41	; 65
     61a:	0e 94 9f 02 	call	0x53e	; 0x53e <led_on>
     61e:	09 c0       	rjmp	.+18     	; 0x632 <Task_Measure+0x3e>
			}
			else
			{
				Message= 1;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	80 93 9e 00 	sts	0x009E, r24	; 0x80009e <Message>
				flag=0;
     626:	10 92 9c 00 	sts	0x009C, r1	; 0x80009c <__data_end>
				led_off(portA, 5);
     62a:	65 e0       	ldi	r22, 0x05	; 5
     62c:	81 e4       	ldi	r24, 0x41	; 65
     62e:	0e 94 a3 02 	call	0x546	; 0x546 <led_off>
			}

		}

		vTaskDelay(1000);
     632:	88 ee       	ldi	r24, 0xE8	; 232
     634:	93 e0       	ldi	r25, 0x03	; 3
     636:	0e 94 b5 0a 	call	0x156a	; 0x156a <vTaskDelay>
	}
     63a:	e0 cf       	rjmp	.-64     	; 0x5fc <Task_Measure+0x8>

0000063c <main>:


}


int main(void){
     63c:	ef 92       	push	r14
     63e:	ff 92       	push	r15
     640:	0f 93       	push	r16
	
	/* Task creation and scheduling*/
	xTaskCreate(Task_Keypad, "Keypad"		, 150, NULL, 1, NULL);
     642:	e1 2c       	mov	r14, r1
     644:	f1 2c       	mov	r15, r1
     646:	01 e0       	ldi	r16, 0x01	; 1
     648:	20 e0       	ldi	r18, 0x00	; 0
     64a:	30 e0       	ldi	r19, 0x00	; 0
     64c:	46 e9       	ldi	r20, 0x96	; 150
     64e:	50 e0       	ldi	r21, 0x00	; 0
     650:	67 e8       	ldi	r22, 0x87	; 135
     652:	70 e0       	ldi	r23, 0x00	; 0
     654:	87 ea       	ldi	r24, 0xA7	; 167
     656:	92 e0       	ldi	r25, 0x02	; 2
     658:	0e 94 05 09 	call	0x120a	; 0x120a <xTaskCreate>
// 	xTaskCreate(Task_Communication, "Send"	, 100, NULL, 2, NULL);
	xTaskCreate(Task_Measure, "Measure"		, 100, NULL, 1, NULL);
     65c:	20 e0       	ldi	r18, 0x00	; 0
     65e:	30 e0       	ldi	r19, 0x00	; 0
     660:	44 e6       	ldi	r20, 0x64	; 100
     662:	50 e0       	ldi	r21, 0x00	; 0
     664:	6e e8       	ldi	r22, 0x8E	; 142
     666:	70 e0       	ldi	r23, 0x00	; 0
     668:	8a ef       	ldi	r24, 0xFA	; 250
     66a:	92 e0       	ldi	r25, 0x02	; 2
     66c:	0e 94 05 09 	call	0x120a	; 0x120a <xTaskCreate>
// 	xTaskCreate(Task_App, "Background"		, 100, NULL, 1, NULL);
	vTaskStartScheduler();
     670:	0e 94 59 09 	call	0x12b2	; 0x12b2 <vTaskStartScheduler>
	
     674:	80 e0       	ldi	r24, 0x00	; 0
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0f 91       	pop	r16
     67a:	ff 90       	pop	r15
     67c:	ef 90       	pop	r14
     67e:	08 95       	ret

00000680 <DIO_voidSetPinDirection>:
     680:	41 11       	cpse	r20, r1
     682:	3b c0       	rjmp	.+118    	; 0x6fa <DIO_voidSetPinDirection+0x7a>
     684:	82 34       	cpi	r24, 0x42	; 66
     686:	a9 f0       	breq	.+42     	; 0x6b2 <DIO_voidSetPinDirection+0x32>
     688:	18 f4       	brcc	.+6      	; 0x690 <DIO_voidSetPinDirection+0x10>
     68a:	81 34       	cpi	r24, 0x41	; 65
     68c:	31 f0       	breq	.+12     	; 0x69a <DIO_voidSetPinDirection+0x1a>
     68e:	08 95       	ret
     690:	83 34       	cpi	r24, 0x43	; 67
     692:	d9 f0       	breq	.+54     	; 0x6ca <DIO_voidSetPinDirection+0x4a>
     694:	84 34       	cpi	r24, 0x44	; 68
     696:	29 f1       	breq	.+74     	; 0x6e2 <DIO_voidSetPinDirection+0x62>
     698:	08 95       	ret
     69a:	2a b3       	in	r18, 0x1a	; 26
     69c:	81 e0       	ldi	r24, 0x01	; 1
     69e:	90 e0       	ldi	r25, 0x00	; 0
     6a0:	02 c0       	rjmp	.+4      	; 0x6a6 <DIO_voidSetPinDirection+0x26>
     6a2:	88 0f       	add	r24, r24
     6a4:	99 1f       	adc	r25, r25
     6a6:	6a 95       	dec	r22
     6a8:	e2 f7       	brpl	.-8      	; 0x6a2 <DIO_voidSetPinDirection+0x22>
     6aa:	80 95       	com	r24
     6ac:	82 23       	and	r24, r18
     6ae:	8a bb       	out	0x1a, r24	; 26
     6b0:	08 95       	ret
     6b2:	27 b3       	in	r18, 0x17	; 23
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	90 e0       	ldi	r25, 0x00	; 0
     6b8:	02 c0       	rjmp	.+4      	; 0x6be <DIO_voidSetPinDirection+0x3e>
     6ba:	88 0f       	add	r24, r24
     6bc:	99 1f       	adc	r25, r25
     6be:	6a 95       	dec	r22
     6c0:	e2 f7       	brpl	.-8      	; 0x6ba <DIO_voidSetPinDirection+0x3a>
     6c2:	80 95       	com	r24
     6c4:	82 23       	and	r24, r18
     6c6:	87 bb       	out	0x17, r24	; 23
     6c8:	08 95       	ret
     6ca:	24 b3       	in	r18, 0x14	; 20
     6cc:	81 e0       	ldi	r24, 0x01	; 1
     6ce:	90 e0       	ldi	r25, 0x00	; 0
     6d0:	02 c0       	rjmp	.+4      	; 0x6d6 <DIO_voidSetPinDirection+0x56>
     6d2:	88 0f       	add	r24, r24
     6d4:	99 1f       	adc	r25, r25
     6d6:	6a 95       	dec	r22
     6d8:	e2 f7       	brpl	.-8      	; 0x6d2 <DIO_voidSetPinDirection+0x52>
     6da:	80 95       	com	r24
     6dc:	82 23       	and	r24, r18
     6de:	84 bb       	out	0x14, r24	; 20
     6e0:	08 95       	ret
     6e2:	21 b3       	in	r18, 0x11	; 17
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	02 c0       	rjmp	.+4      	; 0x6ee <DIO_voidSetPinDirection+0x6e>
     6ea:	88 0f       	add	r24, r24
     6ec:	99 1f       	adc	r25, r25
     6ee:	6a 95       	dec	r22
     6f0:	e2 f7       	brpl	.-8      	; 0x6ea <DIO_voidSetPinDirection+0x6a>
     6f2:	80 95       	com	r24
     6f4:	82 23       	and	r24, r18
     6f6:	81 bb       	out	0x11, r24	; 17
     6f8:	08 95       	ret
     6fa:	82 34       	cpi	r24, 0x42	; 66
     6fc:	a1 f0       	breq	.+40     	; 0x726 <DIO_voidSetPinDirection+0xa6>
     6fe:	18 f4       	brcc	.+6      	; 0x706 <DIO_voidSetPinDirection+0x86>
     700:	81 34       	cpi	r24, 0x41	; 65
     702:	31 f0       	breq	.+12     	; 0x710 <DIO_voidSetPinDirection+0x90>
     704:	08 95       	ret
     706:	83 34       	cpi	r24, 0x43	; 67
     708:	c9 f0       	breq	.+50     	; 0x73c <DIO_voidSetPinDirection+0xbc>
     70a:	84 34       	cpi	r24, 0x44	; 68
     70c:	11 f1       	breq	.+68     	; 0x752 <DIO_voidSetPinDirection+0xd2>
     70e:	08 95       	ret
     710:	2a b3       	in	r18, 0x1a	; 26
     712:	81 e0       	ldi	r24, 0x01	; 1
     714:	90 e0       	ldi	r25, 0x00	; 0
     716:	02 c0       	rjmp	.+4      	; 0x71c <DIO_voidSetPinDirection+0x9c>
     718:	88 0f       	add	r24, r24
     71a:	99 1f       	adc	r25, r25
     71c:	6a 95       	dec	r22
     71e:	e2 f7       	brpl	.-8      	; 0x718 <DIO_voidSetPinDirection+0x98>
     720:	82 2b       	or	r24, r18
     722:	8a bb       	out	0x1a, r24	; 26
     724:	08 95       	ret
     726:	27 b3       	in	r18, 0x17	; 23
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	02 c0       	rjmp	.+4      	; 0x732 <DIO_voidSetPinDirection+0xb2>
     72e:	88 0f       	add	r24, r24
     730:	99 1f       	adc	r25, r25
     732:	6a 95       	dec	r22
     734:	e2 f7       	brpl	.-8      	; 0x72e <DIO_voidSetPinDirection+0xae>
     736:	82 2b       	or	r24, r18
     738:	87 bb       	out	0x17, r24	; 23
     73a:	08 95       	ret
     73c:	24 b3       	in	r18, 0x14	; 20
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	90 e0       	ldi	r25, 0x00	; 0
     742:	02 c0       	rjmp	.+4      	; 0x748 <DIO_voidSetPinDirection+0xc8>
     744:	88 0f       	add	r24, r24
     746:	99 1f       	adc	r25, r25
     748:	6a 95       	dec	r22
     74a:	e2 f7       	brpl	.-8      	; 0x744 <DIO_voidSetPinDirection+0xc4>
     74c:	82 2b       	or	r24, r18
     74e:	84 bb       	out	0x14, r24	; 20
     750:	08 95       	ret
     752:	21 b3       	in	r18, 0x11	; 17
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	02 c0       	rjmp	.+4      	; 0x75e <DIO_voidSetPinDirection+0xde>
     75a:	88 0f       	add	r24, r24
     75c:	99 1f       	adc	r25, r25
     75e:	6a 95       	dec	r22
     760:	e2 f7       	brpl	.-8      	; 0x75a <DIO_voidSetPinDirection+0xda>
     762:	82 2b       	or	r24, r18
     764:	81 bb       	out	0x11, r24	; 17
     766:	08 95       	ret

00000768 <DIO_voidSetPinValue>:
     768:	41 11       	cpse	r20, r1
     76a:	3b c0       	rjmp	.+118    	; 0x7e2 <DIO_voidSetPinValue+0x7a>
     76c:	82 34       	cpi	r24, 0x42	; 66
     76e:	a9 f0       	breq	.+42     	; 0x79a <DIO_voidSetPinValue+0x32>
     770:	18 f4       	brcc	.+6      	; 0x778 <DIO_voidSetPinValue+0x10>
     772:	81 34       	cpi	r24, 0x41	; 65
     774:	31 f0       	breq	.+12     	; 0x782 <DIO_voidSetPinValue+0x1a>
     776:	08 95       	ret
     778:	83 34       	cpi	r24, 0x43	; 67
     77a:	d9 f0       	breq	.+54     	; 0x7b2 <DIO_voidSetPinValue+0x4a>
     77c:	84 34       	cpi	r24, 0x44	; 68
     77e:	29 f1       	breq	.+74     	; 0x7ca <DIO_voidSetPinValue+0x62>
     780:	08 95       	ret
     782:	2b b3       	in	r18, 0x1b	; 27
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	90 e0       	ldi	r25, 0x00	; 0
     788:	02 c0       	rjmp	.+4      	; 0x78e <DIO_voidSetPinValue+0x26>
     78a:	88 0f       	add	r24, r24
     78c:	99 1f       	adc	r25, r25
     78e:	6a 95       	dec	r22
     790:	e2 f7       	brpl	.-8      	; 0x78a <DIO_voidSetPinValue+0x22>
     792:	80 95       	com	r24
     794:	82 23       	and	r24, r18
     796:	8b bb       	out	0x1b, r24	; 27
     798:	08 95       	ret
     79a:	28 b3       	in	r18, 0x18	; 24
     79c:	81 e0       	ldi	r24, 0x01	; 1
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	02 c0       	rjmp	.+4      	; 0x7a6 <DIO_voidSetPinValue+0x3e>
     7a2:	88 0f       	add	r24, r24
     7a4:	99 1f       	adc	r25, r25
     7a6:	6a 95       	dec	r22
     7a8:	e2 f7       	brpl	.-8      	; 0x7a2 <DIO_voidSetPinValue+0x3a>
     7aa:	80 95       	com	r24
     7ac:	82 23       	and	r24, r18
     7ae:	88 bb       	out	0x18, r24	; 24
     7b0:	08 95       	ret
     7b2:	25 b3       	in	r18, 0x15	; 21
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	02 c0       	rjmp	.+4      	; 0x7be <DIO_voidSetPinValue+0x56>
     7ba:	88 0f       	add	r24, r24
     7bc:	99 1f       	adc	r25, r25
     7be:	6a 95       	dec	r22
     7c0:	e2 f7       	brpl	.-8      	; 0x7ba <DIO_voidSetPinValue+0x52>
     7c2:	80 95       	com	r24
     7c4:	82 23       	and	r24, r18
     7c6:	85 bb       	out	0x15, r24	; 21
     7c8:	08 95       	ret
     7ca:	22 b3       	in	r18, 0x12	; 18
     7cc:	81 e0       	ldi	r24, 0x01	; 1
     7ce:	90 e0       	ldi	r25, 0x00	; 0
     7d0:	02 c0       	rjmp	.+4      	; 0x7d6 <DIO_voidSetPinValue+0x6e>
     7d2:	88 0f       	add	r24, r24
     7d4:	99 1f       	adc	r25, r25
     7d6:	6a 95       	dec	r22
     7d8:	e2 f7       	brpl	.-8      	; 0x7d2 <DIO_voidSetPinValue+0x6a>
     7da:	80 95       	com	r24
     7dc:	82 23       	and	r24, r18
     7de:	82 bb       	out	0x12, r24	; 18
     7e0:	08 95       	ret
     7e2:	82 34       	cpi	r24, 0x42	; 66
     7e4:	a1 f0       	breq	.+40     	; 0x80e <__DATA_REGION_LENGTH__+0xe>
     7e6:	18 f4       	brcc	.+6      	; 0x7ee <DIO_voidSetPinValue+0x86>
     7e8:	81 34       	cpi	r24, 0x41	; 65
     7ea:	31 f0       	breq	.+12     	; 0x7f8 <DIO_voidSetPinValue+0x90>
     7ec:	08 95       	ret
     7ee:	83 34       	cpi	r24, 0x43	; 67
     7f0:	c9 f0       	breq	.+50     	; 0x824 <__DATA_REGION_LENGTH__+0x24>
     7f2:	84 34       	cpi	r24, 0x44	; 68
     7f4:	11 f1       	breq	.+68     	; 0x83a <__DATA_REGION_LENGTH__+0x3a>
     7f6:	08 95       	ret
     7f8:	2b b3       	in	r18, 0x1b	; 27
     7fa:	81 e0       	ldi	r24, 0x01	; 1
     7fc:	90 e0       	ldi	r25, 0x00	; 0
     7fe:	02 c0       	rjmp	.+4      	; 0x804 <__DATA_REGION_LENGTH__+0x4>
     800:	88 0f       	add	r24, r24
     802:	99 1f       	adc	r25, r25
     804:	6a 95       	dec	r22
     806:	e2 f7       	brpl	.-8      	; 0x800 <__DATA_REGION_LENGTH__>
     808:	82 2b       	or	r24, r18
     80a:	8b bb       	out	0x1b, r24	; 27
     80c:	08 95       	ret
     80e:	28 b3       	in	r18, 0x18	; 24
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	90 e0       	ldi	r25, 0x00	; 0
     814:	02 c0       	rjmp	.+4      	; 0x81a <__DATA_REGION_LENGTH__+0x1a>
     816:	88 0f       	add	r24, r24
     818:	99 1f       	adc	r25, r25
     81a:	6a 95       	dec	r22
     81c:	e2 f7       	brpl	.-8      	; 0x816 <__DATA_REGION_LENGTH__+0x16>
     81e:	82 2b       	or	r24, r18
     820:	88 bb       	out	0x18, r24	; 24
     822:	08 95       	ret
     824:	25 b3       	in	r18, 0x15	; 21
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	02 c0       	rjmp	.+4      	; 0x830 <__DATA_REGION_LENGTH__+0x30>
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	6a 95       	dec	r22
     832:	e2 f7       	brpl	.-8      	; 0x82c <__DATA_REGION_LENGTH__+0x2c>
     834:	82 2b       	or	r24, r18
     836:	85 bb       	out	0x15, r24	; 21
     838:	08 95       	ret
     83a:	22 b3       	in	r18, 0x12	; 18
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	90 e0       	ldi	r25, 0x00	; 0
     840:	02 c0       	rjmp	.+4      	; 0x846 <__DATA_REGION_LENGTH__+0x46>
     842:	88 0f       	add	r24, r24
     844:	99 1f       	adc	r25, r25
     846:	6a 95       	dec	r22
     848:	e2 f7       	brpl	.-8      	; 0x842 <__DATA_REGION_LENGTH__+0x42>
     84a:	82 2b       	or	r24, r18
     84c:	82 bb       	out	0x12, r24	; 18
     84e:	08 95       	ret

00000850 <__vector_1>:
     850:	1f 92       	push	r1
     852:	0f 92       	push	r0
     854:	0f b6       	in	r0, 0x3f	; 63
     856:	0f 92       	push	r0
     858:	11 24       	eor	r1, r1
     85a:	2f 93       	push	r18
     85c:	3f 93       	push	r19
     85e:	4f 93       	push	r20
     860:	5f 93       	push	r21
     862:	6f 93       	push	r22
     864:	7f 93       	push	r23
     866:	8f 93       	push	r24
     868:	9f 93       	push	r25
     86a:	af 93       	push	r26
     86c:	bf 93       	push	r27
     86e:	ef 93       	push	r30
     870:	ff 93       	push	r31
     872:	e0 91 a5 00 	lds	r30, 0x00A5	; 0x8000a5 <ptr_EXT1>
     876:	f0 91 a6 00 	lds	r31, 0x00A6	; 0x8000a6 <ptr_EXT1+0x1>
     87a:	09 95       	icall
     87c:	ff 91       	pop	r31
     87e:	ef 91       	pop	r30
     880:	bf 91       	pop	r27
     882:	af 91       	pop	r26
     884:	9f 91       	pop	r25
     886:	8f 91       	pop	r24
     888:	7f 91       	pop	r23
     88a:	6f 91       	pop	r22
     88c:	5f 91       	pop	r21
     88e:	4f 91       	pop	r20
     890:	3f 91       	pop	r19
     892:	2f 91       	pop	r18
     894:	0f 90       	pop	r0
     896:	0f be       	out	0x3f, r0	; 63
     898:	0f 90       	pop	r0
     89a:	1f 90       	pop	r1
     89c:	18 95       	reti

0000089e <__vector_2>:
     89e:	1f 92       	push	r1
     8a0:	0f 92       	push	r0
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	0f 92       	push	r0
     8a6:	11 24       	eor	r1, r1
     8a8:	2f 93       	push	r18
     8aa:	3f 93       	push	r19
     8ac:	4f 93       	push	r20
     8ae:	5f 93       	push	r21
     8b0:	6f 93       	push	r22
     8b2:	7f 93       	push	r23
     8b4:	8f 93       	push	r24
     8b6:	9f 93       	push	r25
     8b8:	af 93       	push	r26
     8ba:	bf 93       	push	r27
     8bc:	ef 93       	push	r30
     8be:	ff 93       	push	r31
     8c0:	e0 91 a3 00 	lds	r30, 0x00A3	; 0x8000a3 <ptr_EXT2>
     8c4:	f0 91 a4 00 	lds	r31, 0x00A4	; 0x8000a4 <ptr_EXT2+0x1>
     8c8:	09 95       	icall
     8ca:	ff 91       	pop	r31
     8cc:	ef 91       	pop	r30
     8ce:	bf 91       	pop	r27
     8d0:	af 91       	pop	r26
     8d2:	9f 91       	pop	r25
     8d4:	8f 91       	pop	r24
     8d6:	7f 91       	pop	r23
     8d8:	6f 91       	pop	r22
     8da:	5f 91       	pop	r21
     8dc:	4f 91       	pop	r20
     8de:	3f 91       	pop	r19
     8e0:	2f 91       	pop	r18
     8e2:	0f 90       	pop	r0
     8e4:	0f be       	out	0x3f, r0	; 63
     8e6:	0f 90       	pop	r0
     8e8:	1f 90       	pop	r1
     8ea:	18 95       	reti

000008ec <__vector_3>:
     8ec:	1f 92       	push	r1
     8ee:	0f 92       	push	r0
     8f0:	0f b6       	in	r0, 0x3f	; 63
     8f2:	0f 92       	push	r0
     8f4:	11 24       	eor	r1, r1
     8f6:	2f 93       	push	r18
     8f8:	3f 93       	push	r19
     8fa:	4f 93       	push	r20
     8fc:	5f 93       	push	r21
     8fe:	6f 93       	push	r22
     900:	7f 93       	push	r23
     902:	8f 93       	push	r24
     904:	9f 93       	push	r25
     906:	af 93       	push	r26
     908:	bf 93       	push	r27
     90a:	ef 93       	push	r30
     90c:	ff 93       	push	r31
     90e:	e0 91 a1 00 	lds	r30, 0x00A1	; 0x8000a1 <ptr_EXT3>
     912:	f0 91 a2 00 	lds	r31, 0x00A2	; 0x8000a2 <ptr_EXT3+0x1>
     916:	09 95       	icall
     918:	ff 91       	pop	r31
     91a:	ef 91       	pop	r30
     91c:	bf 91       	pop	r27
     91e:	af 91       	pop	r26
     920:	9f 91       	pop	r25
     922:	8f 91       	pop	r24
     924:	7f 91       	pop	r23
     926:	6f 91       	pop	r22
     928:	5f 91       	pop	r21
     92a:	4f 91       	pop	r20
     92c:	3f 91       	pop	r19
     92e:	2f 91       	pop	r18
     930:	0f 90       	pop	r0
     932:	0f be       	out	0x3f, r0	; 63
     934:	0f 90       	pop	r0
     936:	1f 90       	pop	r1
     938:	18 95       	reti

0000093a <__vector_11>:
     93a:	1f 92       	push	r1
     93c:	0f 92       	push	r0
     93e:	0f b6       	in	r0, 0x3f	; 63
     940:	0f 92       	push	r0
     942:	11 24       	eor	r1, r1
     944:	2f 93       	push	r18
     946:	3f 93       	push	r19
     948:	4f 93       	push	r20
     94a:	5f 93       	push	r21
     94c:	6f 93       	push	r22
     94e:	7f 93       	push	r23
     950:	8f 93       	push	r24
     952:	9f 93       	push	r25
     954:	af 93       	push	r26
     956:	bf 93       	push	r27
     958:	ef 93       	push	r30
     95a:	ff 93       	push	r31
     95c:	e0 91 a7 00 	lds	r30, 0x00A7	; 0x8000a7 <ptr_t0>
     960:	f0 91 a8 00 	lds	r31, 0x00A8	; 0x8000a8 <ptr_t0+0x1>
     964:	09 95       	icall
     966:	ff 91       	pop	r31
     968:	ef 91       	pop	r30
     96a:	bf 91       	pop	r27
     96c:	af 91       	pop	r26
     96e:	9f 91       	pop	r25
     970:	8f 91       	pop	r24
     972:	7f 91       	pop	r23
     974:	6f 91       	pop	r22
     976:	5f 91       	pop	r21
     978:	4f 91       	pop	r20
     97a:	3f 91       	pop	r19
     97c:	2f 91       	pop	r18
     97e:	0f 90       	pop	r0
     980:	0f be       	out	0x3f, r0	; 63
     982:	0f 90       	pop	r0
     984:	1f 90       	pop	r1
     986:	18 95       	reti

00000988 <__vector_10>:
     988:	1f 92       	push	r1
     98a:	0f 92       	push	r0
     98c:	0f b6       	in	r0, 0x3f	; 63
     98e:	0f 92       	push	r0
     990:	11 24       	eor	r1, r1
     992:	2f 93       	push	r18
     994:	3f 93       	push	r19
     996:	4f 93       	push	r20
     998:	5f 93       	push	r21
     99a:	6f 93       	push	r22
     99c:	7f 93       	push	r23
     99e:	8f 93       	push	r24
     9a0:	9f 93       	push	r25
     9a2:	af 93       	push	r26
     9a4:	bf 93       	push	r27
     9a6:	ef 93       	push	r30
     9a8:	ff 93       	push	r31
     9aa:	e0 91 a7 00 	lds	r30, 0x00A7	; 0x8000a7 <ptr_t0>
     9ae:	f0 91 a8 00 	lds	r31, 0x00A8	; 0x8000a8 <ptr_t0+0x1>
     9b2:	09 95       	icall
     9b4:	ff 91       	pop	r31
     9b6:	ef 91       	pop	r30
     9b8:	bf 91       	pop	r27
     9ba:	af 91       	pop	r26
     9bc:	9f 91       	pop	r25
     9be:	8f 91       	pop	r24
     9c0:	7f 91       	pop	r23
     9c2:	6f 91       	pop	r22
     9c4:	5f 91       	pop	r21
     9c6:	4f 91       	pop	r20
     9c8:	3f 91       	pop	r19
     9ca:	2f 91       	pop	r18
     9cc:	0f 90       	pop	r0
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	0f 90       	pop	r0
     9d2:	1f 90       	pop	r1
     9d4:	18 95       	reti

000009d6 <prvHeapInit>:
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     9d6:	ee ea       	ldi	r30, 0xAE	; 174
     9d8:	f0 e0       	ldi	r31, 0x00	; 0
     9da:	83 eb       	ldi	r24, 0xB3	; 179
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	91 83       	std	Z+1, r25	; 0x01
     9e0:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     9e2:	13 82       	std	Z+3, r1	; 0x03
     9e4:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     9e6:	ea ea       	ldi	r30, 0xAA	; 170
     9e8:	f0 e0       	ldi	r31, 0x00	; 0
     9ea:	87 ee       	ldi	r24, 0xE7	; 231
     9ec:	93 e0       	ldi	r25, 0x03	; 3
     9ee:	93 83       	std	Z+3, r25	; 0x03
     9f0:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     9f2:	11 82       	std	Z+1, r1	; 0x01
     9f4:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     9f6:	a2 eb       	ldi	r26, 0xB2	; 178
     9f8:	b0 e0       	ldi	r27, 0x00	; 0
     9fa:	14 96       	adiw	r26, 0x04	; 4
     9fc:	9c 93       	st	X, r25
     9fe:	8e 93       	st	-X, r24
     a00:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     a02:	12 96       	adiw	r26, 0x02	; 2
     a04:	fc 93       	st	X, r31
     a06:	ee 93       	st	-X, r30
     a08:	11 97       	sbiw	r26, 0x01	; 1
     a0a:	08 95       	ret

00000a0c <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     a0c:	0f 93       	push	r16
     a0e:	1f 93       	push	r17
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
     a14:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     a16:	0e 94 83 09 	call	0x1306	; 0x1306 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     a1a:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <xHeapHasBeenInitialised.2079>
     a1e:	81 11       	cpse	r24, r1
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <pvPortMalloc+0x20>
		{
			prvHeapInit();
     a22:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <xHeapHasBeenInitialised.2079>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     a2c:	20 97       	sbiw	r28, 0x00	; 0
     a2e:	09 f0       	breq	.+2      	; 0xa32 <pvPortMalloc+0x26>
		{
			xWantedSize += heapSTRUCT_SIZE;
     a30:	24 96       	adiw	r28, 0x04	; 4
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     a32:	ce 01       	movw	r24, r28
     a34:	01 97       	sbiw	r24, 0x01	; 1
     a36:	86 3e       	cpi	r24, 0xE6	; 230
     a38:	93 40       	sbci	r25, 0x03	; 3
     a3a:	08 f0       	brcs	.+2      	; 0xa3e <pvPortMalloc+0x32>
     a3c:	56 c0       	rjmp	.+172    	; 0xaea <pvPortMalloc+0xde>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     a3e:	e0 91 ae 00 	lds	r30, 0x00AE	; 0x8000ae <xStart>
     a42:	f0 91 af 00 	lds	r31, 0x00AF	; 0x8000af <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     a46:	ae ea       	ldi	r26, 0xAE	; 174
     a48:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a4a:	02 c0       	rjmp	.+4      	; 0xa50 <pvPortMalloc+0x44>
			{
				pxPreviousBlock = pxBlock;
     a4c:	df 01       	movw	r26, r30
				pxBlock = pxBlock->pxNextFreeBlock;
     a4e:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a50:	82 81       	ldd	r24, Z+2	; 0x02
     a52:	93 81       	ldd	r25, Z+3	; 0x03
     a54:	8c 17       	cp	r24, r28
     a56:	9d 07       	cpc	r25, r29
     a58:	20 f4       	brcc	.+8      	; 0xa62 <pvPortMalloc+0x56>
     a5a:	80 81       	ld	r24, Z
     a5c:	91 81       	ldd	r25, Z+1	; 0x01
     a5e:	00 97       	sbiw	r24, 0x00	; 0
     a60:	a9 f7       	brne	.-22     	; 0xa4c <pvPortMalloc+0x40>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     a62:	80 e0       	ldi	r24, 0x00	; 0
     a64:	ea 3a       	cpi	r30, 0xAA	; 170
     a66:	f8 07       	cpc	r31, r24
     a68:	09 f4       	brne	.+2      	; 0xa6c <pvPortMalloc+0x60>
     a6a:	42 c0       	rjmp	.+132    	; 0xaf0 <pvPortMalloc+0xe4>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     a6c:	0d 91       	ld	r16, X+
     a6e:	1c 91       	ld	r17, X
     a70:	11 97       	sbiw	r26, 0x01	; 1
     a72:	0c 5f       	subi	r16, 0xFC	; 252
     a74:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     a76:	80 81       	ld	r24, Z
     a78:	91 81       	ldd	r25, Z+1	; 0x01
     a7a:	8d 93       	st	X+, r24
     a7c:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     a7e:	82 81       	ldd	r24, Z+2	; 0x02
     a80:	93 81       	ldd	r25, Z+3	; 0x03
     a82:	8c 1b       	sub	r24, r28
     a84:	9d 0b       	sbc	r25, r29
     a86:	89 30       	cpi	r24, 0x09	; 9
     a88:	91 05       	cpc	r25, r1
     a8a:	10 f1       	brcs	.+68     	; 0xad0 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     a8c:	af 01       	movw	r20, r30
     a8e:	4c 0f       	add	r20, r28
     a90:	5d 1f       	adc	r21, r29

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     a92:	da 01       	movw	r26, r20
     a94:	13 96       	adiw	r26, 0x03	; 3
     a96:	9c 93       	st	X, r25
     a98:	8e 93       	st	-X, r24
     a9a:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     a9c:	d3 83       	std	Z+3, r29	; 0x03
     a9e:	c2 83       	std	Z+2, r28	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     aa0:	12 96       	adiw	r26, 0x02	; 2
     aa2:	2d 91       	ld	r18, X+
     aa4:	3c 91       	ld	r19, X
     aa6:	13 97       	sbiw	r26, 0x03	; 3
     aa8:	6e ea       	ldi	r22, 0xAE	; 174
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	01 c0       	rjmp	.+2      	; 0xab0 <pvPortMalloc+0xa4>
     aae:	bd 01       	movw	r22, r26
     ab0:	eb 01       	movw	r28, r22
     ab2:	a8 81       	ld	r26, Y
     ab4:	b9 81       	ldd	r27, Y+1	; 0x01
     ab6:	12 96       	adiw	r26, 0x02	; 2
     ab8:	8d 91       	ld	r24, X+
     aba:	9c 91       	ld	r25, X
     abc:	13 97       	sbiw	r26, 0x03	; 3
     abe:	82 17       	cp	r24, r18
     ac0:	93 07       	cpc	r25, r19
     ac2:	a8 f3       	brcs	.-22     	; 0xaae <pvPortMalloc+0xa2>
     ac4:	ea 01       	movw	r28, r20
     ac6:	b9 83       	std	Y+1, r27	; 0x01
     ac8:	a8 83       	st	Y, r26
     aca:	db 01       	movw	r26, r22
     acc:	4d 93       	st	X+, r20
     ace:	5c 93       	st	X, r21
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     ad0:	22 81       	ldd	r18, Z+2	; 0x02
     ad2:	33 81       	ldd	r19, Z+3	; 0x03
     ad4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     ad8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     adc:	82 1b       	sub	r24, r18
     ade:	93 0b       	sbc	r25, r19
     ae0:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     ae4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     ae8:	05 c0       	rjmp	.+10     	; 0xaf4 <pvPortMalloc+0xe8>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     aea:	00 e0       	ldi	r16, 0x00	; 0
     aec:	10 e0       	ldi	r17, 0x00	; 0
     aee:	02 c0       	rjmp	.+4      	; 0xaf4 <pvPortMalloc+0xe8>
     af0:	00 e0       	ldi	r16, 0x00	; 0
     af2:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     af4:	0e 94 43 0a 	call	0x1486	; 0x1486 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     af8:	c8 01       	movw	r24, r16
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	08 95       	ret

00000b04 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     b04:	0f 93       	push	r16
     b06:	1f 93       	push	r17
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     b0c:	00 97       	sbiw	r24, 0x00	; 0
     b0e:	41 f1       	breq	.+80     	; 0xb60 <vPortFree+0x5c>
     b10:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     b12:	8c 01       	movw	r16, r24
     b14:	04 50       	subi	r16, 0x04	; 4
     b16:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     b18:	0e 94 83 09 	call	0x1306	; 0x1306 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     b1c:	f8 01       	movw	r30, r16
     b1e:	42 81       	ldd	r20, Z+2	; 0x02
     b20:	53 81       	ldd	r21, Z+3	; 0x03
     b22:	ae ea       	ldi	r26, 0xAE	; 174
     b24:	b0 e0       	ldi	r27, 0x00	; 0
     b26:	01 c0       	rjmp	.+2      	; 0xb2a <vPortFree+0x26>
     b28:	df 01       	movw	r26, r30
     b2a:	ed 91       	ld	r30, X+
     b2c:	fc 91       	ld	r31, X
     b2e:	11 97       	sbiw	r26, 0x01	; 1
     b30:	22 81       	ldd	r18, Z+2	; 0x02
     b32:	33 81       	ldd	r19, Z+3	; 0x03
     b34:	24 17       	cp	r18, r20
     b36:	35 07       	cpc	r19, r21
     b38:	b8 f3       	brcs	.-18     	; 0xb28 <vPortFree+0x24>
     b3a:	24 97       	sbiw	r28, 0x04	; 4
     b3c:	f9 83       	std	Y+1, r31	; 0x01
     b3e:	e8 83       	st	Y, r30
     b40:	0d 93       	st	X+, r16
     b42:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     b44:	8a 81       	ldd	r24, Y+2	; 0x02
     b46:	9b 81       	ldd	r25, Y+3	; 0x03
     b48:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     b4c:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     b50:	82 0f       	add	r24, r18
     b52:	93 1f       	adc	r25, r19
     b54:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     b58:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     b5c:	0e 94 43 0a 	call	0x1486	; 0x1486 <xTaskResumeAll>
	}
}
     b60:	df 91       	pop	r29
     b62:	cf 91       	pop	r28
     b64:	1f 91       	pop	r17
     b66:	0f 91       	pop	r16
     b68:	08 95       	ret

00000b6a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     b6a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b6c:	03 96       	adiw	r24, 0x03	; 3
     b6e:	92 83       	std	Z+2, r25	; 0x02
     b70:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     b72:	2f ef       	ldi	r18, 0xFF	; 255
     b74:	3f ef       	ldi	r19, 0xFF	; 255
     b76:	34 83       	std	Z+4, r19	; 0x04
     b78:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b7a:	96 83       	std	Z+6, r25	; 0x06
     b7c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     b7e:	90 87       	std	Z+8, r25	; 0x08
     b80:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     b82:	10 82       	st	Z, r1
     b84:	08 95       	ret

00000b86 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     b86:	fc 01       	movw	r30, r24
     b88:	11 86       	std	Z+9, r1	; 0x09
     b8a:	10 86       	std	Z+8, r1	; 0x08
     b8c:	08 95       	ret

00000b8e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     b8e:	cf 93       	push	r28
     b90:	df 93       	push	r29
     b92:	9c 01       	movw	r18, r24
     b94:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     b96:	dc 01       	movw	r26, r24
     b98:	11 96       	adiw	r26, 0x01	; 1
     b9a:	cd 91       	ld	r28, X+
     b9c:	dc 91       	ld	r29, X
     b9e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     ba0:	d3 83       	std	Z+3, r29	; 0x03
     ba2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     ba4:	8c 81       	ldd	r24, Y+4	; 0x04
     ba6:	9d 81       	ldd	r25, Y+5	; 0x05
     ba8:	95 83       	std	Z+5, r25	; 0x05
     baa:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     bac:	8c 81       	ldd	r24, Y+4	; 0x04
     bae:	9d 81       	ldd	r25, Y+5	; 0x05
     bb0:	dc 01       	movw	r26, r24
     bb2:	13 96       	adiw	r26, 0x03	; 3
     bb4:	7c 93       	st	X, r23
     bb6:	6e 93       	st	-X, r22
     bb8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     bba:	7d 83       	std	Y+5, r23	; 0x05
     bbc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     bbe:	31 87       	std	Z+9, r19	; 0x09
     bc0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     bc2:	f9 01       	movw	r30, r18
     bc4:	80 81       	ld	r24, Z
     bc6:	8f 5f       	subi	r24, 0xFF	; 255
     bc8:	80 83       	st	Z, r24
}
     bca:	df 91       	pop	r29
     bcc:	cf 91       	pop	r28
     bce:	08 95       	ret

00000bd0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     bd0:	cf 93       	push	r28
     bd2:	df 93       	push	r29
     bd4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     bd6:	48 81       	ld	r20, Y
     bd8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     bda:	4f 3f       	cpi	r20, 0xFF	; 255
     bdc:	2f ef       	ldi	r18, 0xFF	; 255
     bde:	52 07       	cpc	r21, r18
     be0:	21 f4       	brne	.+8      	; 0xbea <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     be2:	fc 01       	movw	r30, r24
     be4:	a7 81       	ldd	r26, Z+7	; 0x07
     be6:	b0 85       	ldd	r27, Z+8	; 0x08
     be8:	0d c0       	rjmp	.+26     	; 0xc04 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     bea:	dc 01       	movw	r26, r24
     bec:	13 96       	adiw	r26, 0x03	; 3
     bee:	01 c0       	rjmp	.+2      	; 0xbf2 <vListInsert+0x22>
     bf0:	df 01       	movw	r26, r30
     bf2:	12 96       	adiw	r26, 0x02	; 2
     bf4:	ed 91       	ld	r30, X+
     bf6:	fc 91       	ld	r31, X
     bf8:	13 97       	sbiw	r26, 0x03	; 3
     bfa:	20 81       	ld	r18, Z
     bfc:	31 81       	ldd	r19, Z+1	; 0x01
     bfe:	42 17       	cp	r20, r18
     c00:	53 07       	cpc	r21, r19
     c02:	b0 f7       	brcc	.-20     	; 0xbf0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     c04:	12 96       	adiw	r26, 0x02	; 2
     c06:	ed 91       	ld	r30, X+
     c08:	fc 91       	ld	r31, X
     c0a:	13 97       	sbiw	r26, 0x03	; 3
     c0c:	fb 83       	std	Y+3, r31	; 0x03
     c0e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     c10:	d5 83       	std	Z+5, r29	; 0x05
     c12:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     c14:	bd 83       	std	Y+5, r27	; 0x05
     c16:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     c18:	13 96       	adiw	r26, 0x03	; 3
     c1a:	dc 93       	st	X, r29
     c1c:	ce 93       	st	-X, r28
     c1e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c20:	99 87       	std	Y+9, r25	; 0x09
     c22:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     c24:	fc 01       	movw	r30, r24
     c26:	20 81       	ld	r18, Z
     c28:	2f 5f       	subi	r18, 0xFF	; 255
     c2a:	20 83       	st	Z, r18
}
     c2c:	df 91       	pop	r29
     c2e:	cf 91       	pop	r28
     c30:	08 95       	ret

00000c32 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     c38:	a0 85       	ldd	r26, Z+8	; 0x08
     c3a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     c3c:	c2 81       	ldd	r28, Z+2	; 0x02
     c3e:	d3 81       	ldd	r29, Z+3	; 0x03
     c40:	84 81       	ldd	r24, Z+4	; 0x04
     c42:	95 81       	ldd	r25, Z+5	; 0x05
     c44:	9d 83       	std	Y+5, r25	; 0x05
     c46:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     c48:	c4 81       	ldd	r28, Z+4	; 0x04
     c4a:	d5 81       	ldd	r29, Z+5	; 0x05
     c4c:	82 81       	ldd	r24, Z+2	; 0x02
     c4e:	93 81       	ldd	r25, Z+3	; 0x03
     c50:	9b 83       	std	Y+3, r25	; 0x03
     c52:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     c54:	11 96       	adiw	r26, 0x01	; 1
     c56:	8d 91       	ld	r24, X+
     c58:	9c 91       	ld	r25, X
     c5a:	12 97       	sbiw	r26, 0x02	; 2
     c5c:	e8 17       	cp	r30, r24
     c5e:	f9 07       	cpc	r31, r25
     c60:	31 f4       	brne	.+12     	; 0xc6e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     c62:	84 81       	ldd	r24, Z+4	; 0x04
     c64:	95 81       	ldd	r25, Z+5	; 0x05
     c66:	12 96       	adiw	r26, 0x02	; 2
     c68:	9c 93       	st	X, r25
     c6a:	8e 93       	st	-X, r24
     c6c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     c6e:	11 86       	std	Z+9, r1	; 0x09
     c70:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     c72:	8c 91       	ld	r24, X
     c74:	81 50       	subi	r24, 0x01	; 1
     c76:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     c78:	df 91       	pop	r29
     c7a:	cf 91       	pop	r28
     c7c:	08 95       	ret

00000c7e <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     c7e:	1b bc       	out	0x2b, r1	; 43
     c80:	89 ef       	ldi	r24, 0xF9	; 249
     c82:	8a bd       	out	0x2a, r24	; 42
     c84:	8b e0       	ldi	r24, 0x0B	; 11
     c86:	8e bd       	out	0x2e, r24	; 46
     c88:	89 b7       	in	r24, 0x39	; 57
     c8a:	80 61       	ori	r24, 0x10	; 16
     c8c:	89 bf       	out	0x39, r24	; 57
     c8e:	08 95       	ret

00000c90 <pxPortInitialiseStack>:
     c90:	31 e1       	ldi	r19, 0x11	; 17
     c92:	fc 01       	movw	r30, r24
     c94:	30 83       	st	Z, r19
     c96:	31 97       	sbiw	r30, 0x01	; 1
     c98:	22 e2       	ldi	r18, 0x22	; 34
     c9a:	20 83       	st	Z, r18
     c9c:	31 97       	sbiw	r30, 0x01	; 1
     c9e:	a3 e3       	ldi	r26, 0x33	; 51
     ca0:	a0 83       	st	Z, r26
     ca2:	31 97       	sbiw	r30, 0x01	; 1
     ca4:	60 83       	st	Z, r22
     ca6:	31 97       	sbiw	r30, 0x01	; 1
     ca8:	70 83       	st	Z, r23
     caa:	31 97       	sbiw	r30, 0x01	; 1
     cac:	10 82       	st	Z, r1
     cae:	31 97       	sbiw	r30, 0x01	; 1
     cb0:	60 e8       	ldi	r22, 0x80	; 128
     cb2:	60 83       	st	Z, r22
     cb4:	31 97       	sbiw	r30, 0x01	; 1
     cb6:	10 82       	st	Z, r1
     cb8:	31 97       	sbiw	r30, 0x01	; 1
     cba:	62 e0       	ldi	r22, 0x02	; 2
     cbc:	60 83       	st	Z, r22
     cbe:	31 97       	sbiw	r30, 0x01	; 1
     cc0:	63 e0       	ldi	r22, 0x03	; 3
     cc2:	60 83       	st	Z, r22
     cc4:	31 97       	sbiw	r30, 0x01	; 1
     cc6:	64 e0       	ldi	r22, 0x04	; 4
     cc8:	60 83       	st	Z, r22
     cca:	31 97       	sbiw	r30, 0x01	; 1
     ccc:	65 e0       	ldi	r22, 0x05	; 5
     cce:	60 83       	st	Z, r22
     cd0:	31 97       	sbiw	r30, 0x01	; 1
     cd2:	66 e0       	ldi	r22, 0x06	; 6
     cd4:	60 83       	st	Z, r22
     cd6:	31 97       	sbiw	r30, 0x01	; 1
     cd8:	67 e0       	ldi	r22, 0x07	; 7
     cda:	60 83       	st	Z, r22
     cdc:	31 97       	sbiw	r30, 0x01	; 1
     cde:	68 e0       	ldi	r22, 0x08	; 8
     ce0:	60 83       	st	Z, r22
     ce2:	31 97       	sbiw	r30, 0x01	; 1
     ce4:	69 e0       	ldi	r22, 0x09	; 9
     ce6:	60 83       	st	Z, r22
     ce8:	31 97       	sbiw	r30, 0x01	; 1
     cea:	60 e1       	ldi	r22, 0x10	; 16
     cec:	60 83       	st	Z, r22
     cee:	31 97       	sbiw	r30, 0x01	; 1
     cf0:	30 83       	st	Z, r19
     cf2:	31 97       	sbiw	r30, 0x01	; 1
     cf4:	32 e1       	ldi	r19, 0x12	; 18
     cf6:	30 83       	st	Z, r19
     cf8:	31 97       	sbiw	r30, 0x01	; 1
     cfa:	33 e1       	ldi	r19, 0x13	; 19
     cfc:	30 83       	st	Z, r19
     cfe:	31 97       	sbiw	r30, 0x01	; 1
     d00:	34 e1       	ldi	r19, 0x14	; 20
     d02:	30 83       	st	Z, r19
     d04:	31 97       	sbiw	r30, 0x01	; 1
     d06:	35 e1       	ldi	r19, 0x15	; 21
     d08:	30 83       	st	Z, r19
     d0a:	31 97       	sbiw	r30, 0x01	; 1
     d0c:	36 e1       	ldi	r19, 0x16	; 22
     d0e:	30 83       	st	Z, r19
     d10:	31 97       	sbiw	r30, 0x01	; 1
     d12:	37 e1       	ldi	r19, 0x17	; 23
     d14:	30 83       	st	Z, r19
     d16:	31 97       	sbiw	r30, 0x01	; 1
     d18:	38 e1       	ldi	r19, 0x18	; 24
     d1a:	30 83       	st	Z, r19
     d1c:	31 97       	sbiw	r30, 0x01	; 1
     d1e:	39 e1       	ldi	r19, 0x19	; 25
     d20:	30 83       	st	Z, r19
     d22:	31 97       	sbiw	r30, 0x01	; 1
     d24:	30 e2       	ldi	r19, 0x20	; 32
     d26:	30 83       	st	Z, r19
     d28:	31 97       	sbiw	r30, 0x01	; 1
     d2a:	31 e2       	ldi	r19, 0x21	; 33
     d2c:	30 83       	st	Z, r19
     d2e:	31 97       	sbiw	r30, 0x01	; 1
     d30:	20 83       	st	Z, r18
     d32:	31 97       	sbiw	r30, 0x01	; 1
     d34:	23 e2       	ldi	r18, 0x23	; 35
     d36:	20 83       	st	Z, r18
     d38:	31 97       	sbiw	r30, 0x01	; 1
     d3a:	40 83       	st	Z, r20
     d3c:	31 97       	sbiw	r30, 0x01	; 1
     d3e:	50 83       	st	Z, r21
     d40:	31 97       	sbiw	r30, 0x01	; 1
     d42:	26 e2       	ldi	r18, 0x26	; 38
     d44:	20 83       	st	Z, r18
     d46:	31 97       	sbiw	r30, 0x01	; 1
     d48:	27 e2       	ldi	r18, 0x27	; 39
     d4a:	20 83       	st	Z, r18
     d4c:	31 97       	sbiw	r30, 0x01	; 1
     d4e:	28 e2       	ldi	r18, 0x28	; 40
     d50:	20 83       	st	Z, r18
     d52:	31 97       	sbiw	r30, 0x01	; 1
     d54:	29 e2       	ldi	r18, 0x29	; 41
     d56:	20 83       	st	Z, r18
     d58:	31 97       	sbiw	r30, 0x01	; 1
     d5a:	20 e3       	ldi	r18, 0x30	; 48
     d5c:	20 83       	st	Z, r18
     d5e:	31 97       	sbiw	r30, 0x01	; 1
     d60:	21 e3       	ldi	r18, 0x31	; 49
     d62:	20 83       	st	Z, r18
     d64:	86 97       	sbiw	r24, 0x26	; 38
     d66:	08 95       	ret

00000d68 <xPortStartScheduler>:
     d68:	0e 94 3f 06 	call	0xc7e	; 0xc7e <prvSetupTimerInterrupt>
     d6c:	a0 91 22 05 	lds	r26, 0x0522	; 0x800522 <pxCurrentTCB>
     d70:	b0 91 23 05 	lds	r27, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
     d74:	cd 91       	ld	r28, X+
     d76:	cd bf       	out	0x3d, r28	; 61
     d78:	dd 91       	ld	r29, X+
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	ff 91       	pop	r31
     d7e:	ef 91       	pop	r30
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	bf 91       	pop	r27
     d86:	af 91       	pop	r26
     d88:	9f 91       	pop	r25
     d8a:	8f 91       	pop	r24
     d8c:	7f 91       	pop	r23
     d8e:	6f 91       	pop	r22
     d90:	5f 91       	pop	r21
     d92:	4f 91       	pop	r20
     d94:	3f 91       	pop	r19
     d96:	2f 91       	pop	r18
     d98:	1f 91       	pop	r17
     d9a:	0f 91       	pop	r16
     d9c:	ff 90       	pop	r15
     d9e:	ef 90       	pop	r14
     da0:	df 90       	pop	r13
     da2:	cf 90       	pop	r12
     da4:	bf 90       	pop	r11
     da6:	af 90       	pop	r10
     da8:	9f 90       	pop	r9
     daa:	8f 90       	pop	r8
     dac:	7f 90       	pop	r7
     dae:	6f 90       	pop	r6
     db0:	5f 90       	pop	r5
     db2:	4f 90       	pop	r4
     db4:	3f 90       	pop	r3
     db6:	2f 90       	pop	r2
     db8:	1f 90       	pop	r1
     dba:	0f 90       	pop	r0
     dbc:	0f be       	out	0x3f, r0	; 63
     dbe:	0f 90       	pop	r0
     dc0:	08 95       	ret
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	08 95       	ret

00000dc6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dc6:	0f 92       	push	r0
     dc8:	0f b6       	in	r0, 0x3f	; 63
     dca:	f8 94       	cli
     dcc:	0f 92       	push	r0
     dce:	1f 92       	push	r1
     dd0:	11 24       	eor	r1, r1
     dd2:	2f 92       	push	r2
     dd4:	3f 92       	push	r3
     dd6:	4f 92       	push	r4
     dd8:	5f 92       	push	r5
     dda:	6f 92       	push	r6
     ddc:	7f 92       	push	r7
     dde:	8f 92       	push	r8
     de0:	9f 92       	push	r9
     de2:	af 92       	push	r10
     de4:	bf 92       	push	r11
     de6:	cf 92       	push	r12
     de8:	df 92       	push	r13
     dea:	ef 92       	push	r14
     dec:	ff 92       	push	r15
     dee:	0f 93       	push	r16
     df0:	1f 93       	push	r17
     df2:	2f 93       	push	r18
     df4:	3f 93       	push	r19
     df6:	4f 93       	push	r20
     df8:	5f 93       	push	r21
     dfa:	6f 93       	push	r22
     dfc:	7f 93       	push	r23
     dfe:	8f 93       	push	r24
     e00:	9f 93       	push	r25
     e02:	af 93       	push	r26
     e04:	bf 93       	push	r27
     e06:	cf 93       	push	r28
     e08:	df 93       	push	r29
     e0a:	ef 93       	push	r30
     e0c:	ff 93       	push	r31
     e0e:	a0 91 22 05 	lds	r26, 0x0522	; 0x800522 <pxCurrentTCB>
     e12:	b0 91 23 05 	lds	r27, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
     e16:	0d b6       	in	r0, 0x3d	; 61
     e18:	0d 92       	st	X+, r0
     e1a:	0e b6       	in	r0, 0x3e	; 62
     e1c:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e1e:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e22:	a0 91 22 05 	lds	r26, 0x0522	; 0x800522 <pxCurrentTCB>
     e26:	b0 91 23 05 	lds	r27, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
     e2a:	cd 91       	ld	r28, X+
     e2c:	cd bf       	out	0x3d, r28	; 61
     e2e:	dd 91       	ld	r29, X+
     e30:	de bf       	out	0x3e, r29	; 62
     e32:	ff 91       	pop	r31
     e34:	ef 91       	pop	r30
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	bf 91       	pop	r27
     e3c:	af 91       	pop	r26
     e3e:	9f 91       	pop	r25
     e40:	8f 91       	pop	r24
     e42:	7f 91       	pop	r23
     e44:	6f 91       	pop	r22
     e46:	5f 91       	pop	r21
     e48:	4f 91       	pop	r20
     e4a:	3f 91       	pop	r19
     e4c:	2f 91       	pop	r18
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	ff 90       	pop	r15
     e54:	ef 90       	pop	r14
     e56:	df 90       	pop	r13
     e58:	cf 90       	pop	r12
     e5a:	bf 90       	pop	r11
     e5c:	af 90       	pop	r10
     e5e:	9f 90       	pop	r9
     e60:	8f 90       	pop	r8
     e62:	7f 90       	pop	r7
     e64:	6f 90       	pop	r6
     e66:	5f 90       	pop	r5
     e68:	4f 90       	pop	r4
     e6a:	3f 90       	pop	r3
     e6c:	2f 90       	pop	r2
     e6e:	1f 90       	pop	r1
     e70:	0f 90       	pop	r0
     e72:	0f be       	out	0x3f, r0	; 63
     e74:	0f 90       	pop	r0

	asm volatile ( "ret" );
     e76:	08 95       	ret

00000e78 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     e78:	0f 92       	push	r0
     e7a:	0f b6       	in	r0, 0x3f	; 63
     e7c:	f8 94       	cli
     e7e:	0f 92       	push	r0
     e80:	1f 92       	push	r1
     e82:	11 24       	eor	r1, r1
     e84:	2f 92       	push	r2
     e86:	3f 92       	push	r3
     e88:	4f 92       	push	r4
     e8a:	5f 92       	push	r5
     e8c:	6f 92       	push	r6
     e8e:	7f 92       	push	r7
     e90:	8f 92       	push	r8
     e92:	9f 92       	push	r9
     e94:	af 92       	push	r10
     e96:	bf 92       	push	r11
     e98:	cf 92       	push	r12
     e9a:	df 92       	push	r13
     e9c:	ef 92       	push	r14
     e9e:	ff 92       	push	r15
     ea0:	0f 93       	push	r16
     ea2:	1f 93       	push	r17
     ea4:	2f 93       	push	r18
     ea6:	3f 93       	push	r19
     ea8:	4f 93       	push	r20
     eaa:	5f 93       	push	r21
     eac:	6f 93       	push	r22
     eae:	7f 93       	push	r23
     eb0:	8f 93       	push	r24
     eb2:	9f 93       	push	r25
     eb4:	af 93       	push	r26
     eb6:	bf 93       	push	r27
     eb8:	cf 93       	push	r28
     eba:	df 93       	push	r29
     ebc:	ef 93       	push	r30
     ebe:	ff 93       	push	r31
     ec0:	a0 91 22 05 	lds	r26, 0x0522	; 0x800522 <pxCurrentTCB>
     ec4:	b0 91 23 05 	lds	r27, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
     ec8:	0d b6       	in	r0, 0x3d	; 61
     eca:	0d 92       	st	X+, r0
     ecc:	0e b6       	in	r0, 0x3e	; 62
     ece:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     ed0:	0e 94 89 09 	call	0x1312	; 0x1312 <xTaskIncrementTick>
     ed4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     ed6:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     eda:	a0 91 22 05 	lds	r26, 0x0522	; 0x800522 <pxCurrentTCB>
     ede:	b0 91 23 05 	lds	r27, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
     ee2:	cd 91       	ld	r28, X+
     ee4:	cd bf       	out	0x3d, r28	; 61
     ee6:	dd 91       	ld	r29, X+
     ee8:	de bf       	out	0x3e, r29	; 62
     eea:	ff 91       	pop	r31
     eec:	ef 91       	pop	r30
     eee:	df 91       	pop	r29
     ef0:	cf 91       	pop	r28
     ef2:	bf 91       	pop	r27
     ef4:	af 91       	pop	r26
     ef6:	9f 91       	pop	r25
     ef8:	8f 91       	pop	r24
     efa:	7f 91       	pop	r23
     efc:	6f 91       	pop	r22
     efe:	5f 91       	pop	r21
     f00:	4f 91       	pop	r20
     f02:	3f 91       	pop	r19
     f04:	2f 91       	pop	r18
     f06:	1f 91       	pop	r17
     f08:	0f 91       	pop	r16
     f0a:	ff 90       	pop	r15
     f0c:	ef 90       	pop	r14
     f0e:	df 90       	pop	r13
     f10:	cf 90       	pop	r12
     f12:	bf 90       	pop	r11
     f14:	af 90       	pop	r10
     f16:	9f 90       	pop	r9
     f18:	8f 90       	pop	r8
     f1a:	7f 90       	pop	r7
     f1c:	6f 90       	pop	r6
     f1e:	5f 90       	pop	r5
     f20:	4f 90       	pop	r4
     f22:	3f 90       	pop	r3
     f24:	2f 90       	pop	r2
     f26:	1f 90       	pop	r1
     f28:	0f 90       	pop	r0
     f2a:	0f be       	out	0x3f, r0	; 63
     f2c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f2e:	08 95       	ret

00000f30 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     f30:	0e 94 3c 07 	call	0xe78	; 0xe78 <vPortYieldFromTick>
		asm volatile ( "reti" );
     f34:	18 95       	reti

00000f36 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     f36:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <pxDelayedTaskList>
     f3a:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
     f3e:	80 81       	ld	r24, Z
     f40:	81 11       	cpse	r24, r1
     f42:	07 c0       	rjmp	.+14     	; 0xf52 <prvResetNextTaskUnblockTime+0x1c>
     f44:	8f ef       	ldi	r24, 0xFF	; 255
     f46:	9f ef       	ldi	r25, 0xFF	; 255
     f48:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <xNextTaskUnblockTime+0x1>
     f4c:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <xNextTaskUnblockTime>
     f50:	08 95       	ret
     f52:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <pxDelayedTaskList>
     f56:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
     f5a:	05 80       	ldd	r0, Z+5	; 0x05
     f5c:	f6 81       	ldd	r31, Z+6	; 0x06
     f5e:	e0 2d       	mov	r30, r0
     f60:	06 80       	ldd	r0, Z+6	; 0x06
     f62:	f7 81       	ldd	r31, Z+7	; 0x07
     f64:	e0 2d       	mov	r30, r0
     f66:	82 81       	ldd	r24, Z+2	; 0x02
     f68:	93 81       	ldd	r25, Z+3	; 0x03
     f6a:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <xNextTaskUnblockTime+0x1>
     f6e:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <xNextTaskUnblockTime>
     f72:	08 95       	ret

00000f74 <prvDeleteTCB>:
     f74:	cf 93       	push	r28
     f76:	df 93       	push	r29
     f78:	ec 01       	movw	r28, r24
     f7a:	8f 89       	ldd	r24, Y+23	; 0x17
     f7c:	98 8d       	ldd	r25, Y+24	; 0x18
     f7e:	0e 94 82 05 	call	0xb04	; 0xb04 <vPortFree>
     f82:	ce 01       	movw	r24, r28
     f84:	0e 94 82 05 	call	0xb04	; 0xb04 <vPortFree>
     f88:	df 91       	pop	r29
     f8a:	cf 91       	pop	r28
     f8c:	08 95       	ret

00000f8e <prvInitialiseNewTask>:
     f8e:	6f 92       	push	r6
     f90:	7f 92       	push	r7
     f92:	8f 92       	push	r8
     f94:	9f 92       	push	r9
     f96:	af 92       	push	r10
     f98:	bf 92       	push	r11
     f9a:	cf 92       	push	r12
     f9c:	df 92       	push	r13
     f9e:	ef 92       	push	r14
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	cd b7       	in	r28, 0x3d	; 61
     faa:	de b7       	in	r29, 0x3e	; 62
     fac:	4c 01       	movw	r8, r24
     fae:	f5 01       	movw	r30, r10
     fb0:	87 89       	ldd	r24, Z+23	; 0x17
     fb2:	90 8d       	ldd	r25, Z+24	; 0x18
     fb4:	21 50       	subi	r18, 0x01	; 1
     fb6:	31 09       	sbc	r19, r1
     fb8:	3c 01       	movw	r6, r24
     fba:	62 0e       	add	r6, r18
     fbc:	73 1e       	adc	r7, r19
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	0f c0       	rjmp	.+30     	; 0xfe0 <prvInitialiseNewTask+0x52>
     fc2:	82 2f       	mov	r24, r18
     fc4:	90 e0       	ldi	r25, 0x00	; 0
     fc6:	fb 01       	movw	r30, r22
     fc8:	e8 0f       	add	r30, r24
     fca:	f9 1f       	adc	r31, r25
     fcc:	30 81       	ld	r19, Z
     fce:	d5 01       	movw	r26, r10
     fd0:	a8 0f       	add	r26, r24
     fd2:	b9 1f       	adc	r27, r25
     fd4:	59 96       	adiw	r26, 0x19	; 25
     fd6:	3c 93       	st	X, r19
     fd8:	80 81       	ld	r24, Z
     fda:	88 23       	and	r24, r24
     fdc:	19 f0       	breq	.+6      	; 0xfe4 <prvInitialiseNewTask+0x56>
     fde:	2f 5f       	subi	r18, 0xFF	; 255
     fe0:	28 30       	cpi	r18, 0x08	; 8
     fe2:	78 f3       	brcs	.-34     	; 0xfc2 <prvInitialiseNewTask+0x34>
     fe4:	f5 01       	movw	r30, r10
     fe6:	10 a2       	std	Z+32, r1	; 0x20
     fe8:	f8 e0       	ldi	r31, 0x08	; 8
     fea:	fe 15       	cp	r31, r14
     fec:	18 f4       	brcc	.+6      	; 0xff4 <prvInitialiseNewTask+0x66>
     fee:	68 94       	set
     ff0:	ee 24       	eor	r14, r14
     ff2:	e3 f8       	bld	r14, 3
     ff4:	f5 01       	movw	r30, r10
     ff6:	e6 8a       	std	Z+22, r14	; 0x16
     ff8:	e1 a2       	std	Z+33, r14	; 0x21
     ffa:	12 a2       	std	Z+34, r1	; 0x22
     ffc:	c5 01       	movw	r24, r10
     ffe:	02 96       	adiw	r24, 0x02	; 2
    1000:	0e 94 c3 05 	call	0xb86	; 0xb86 <vListInitialiseItem>
    1004:	c5 01       	movw	r24, r10
    1006:	0c 96       	adiw	r24, 0x0c	; 12
    1008:	0e 94 c3 05 	call	0xb86	; 0xb86 <vListInitialiseItem>
    100c:	f5 01       	movw	r30, r10
    100e:	b1 86       	std	Z+9, r11	; 0x09
    1010:	a0 86       	std	Z+8, r10	; 0x08
    1012:	89 e0       	ldi	r24, 0x09	; 9
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	8e 19       	sub	r24, r14
    1018:	91 09       	sbc	r25, r1
    101a:	95 87       	std	Z+13, r25	; 0x0d
    101c:	84 87       	std	Z+12, r24	; 0x0c
    101e:	b3 8a       	std	Z+19, r11	; 0x13
    1020:	a2 8a       	std	Z+18, r10	; 0x12
    1022:	13 a2       	std	Z+35, r1	; 0x23
    1024:	14 a2       	std	Z+36, r1	; 0x24
    1026:	15 a2       	std	Z+37, r1	; 0x25
    1028:	16 a2       	std	Z+38, r1	; 0x26
    102a:	17 a2       	std	Z+39, r1	; 0x27
    102c:	a8 01       	movw	r20, r16
    102e:	b4 01       	movw	r22, r8
    1030:	c3 01       	movw	r24, r6
    1032:	0e 94 48 06 	call	0xc90	; 0xc90 <pxPortInitialiseStack>
    1036:	f5 01       	movw	r30, r10
    1038:	91 83       	std	Z+1, r25	; 0x01
    103a:	80 83       	st	Z, r24
    103c:	c1 14       	cp	r12, r1
    103e:	d1 04       	cpc	r13, r1
    1040:	19 f0       	breq	.+6      	; 0x1048 <prvInitialiseNewTask+0xba>
    1042:	f6 01       	movw	r30, r12
    1044:	b1 82       	std	Z+1, r11	; 0x01
    1046:	a0 82       	st	Z, r10
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	1f 91       	pop	r17
    104e:	0f 91       	pop	r16
    1050:	ef 90       	pop	r14
    1052:	df 90       	pop	r13
    1054:	cf 90       	pop	r12
    1056:	bf 90       	pop	r11
    1058:	af 90       	pop	r10
    105a:	9f 90       	pop	r9
    105c:	8f 90       	pop	r8
    105e:	7f 90       	pop	r7
    1060:	6f 90       	pop	r6
    1062:	08 95       	ret

00001064 <prvInitialiseTaskLists>:
    1064:	cf 93       	push	r28
    1066:	c0 e0       	ldi	r28, 0x00	; 0
    1068:	10 c0       	rjmp	.+32     	; 0x108a <prvInitialiseTaskLists+0x26>
    106a:	8c 2f       	mov	r24, r28
    106c:	90 e0       	ldi	r25, 0x00	; 0
    106e:	9c 01       	movw	r18, r24
    1070:	22 0f       	add	r18, r18
    1072:	33 1f       	adc	r19, r19
    1074:	22 0f       	add	r18, r18
    1076:	33 1f       	adc	r19, r19
    1078:	22 0f       	add	r18, r18
    107a:	33 1f       	adc	r19, r19
    107c:	82 0f       	add	r24, r18
    107e:	93 1f       	adc	r25, r19
    1080:	8f 52       	subi	r24, 0x2F	; 47
    1082:	9b 4f       	sbci	r25, 0xFB	; 251
    1084:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInitialise>
    1088:	cf 5f       	subi	r28, 0xFF	; 255
    108a:	c9 30       	cpi	r28, 0x09	; 9
    108c:	70 f3       	brcs	.-36     	; 0x106a <prvInitialiseTaskLists+0x6>
    108e:	88 ec       	ldi	r24, 0xC8	; 200
    1090:	94 e0       	ldi	r25, 0x04	; 4
    1092:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInitialise>
    1096:	8f eb       	ldi	r24, 0xBF	; 191
    1098:	94 e0       	ldi	r25, 0x04	; 4
    109a:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInitialise>
    109e:	82 eb       	ldi	r24, 0xB2	; 178
    10a0:	94 e0       	ldi	r25, 0x04	; 4
    10a2:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInitialise>
    10a6:	89 ea       	ldi	r24, 0xA9	; 169
    10a8:	94 e0       	ldi	r25, 0x04	; 4
    10aa:	0e 94 b5 05 	call	0xb6a	; 0xb6a <vListInitialise>
    10ae:	88 ec       	ldi	r24, 0xC8	; 200
    10b0:	94 e0       	ldi	r25, 0x04	; 4
    10b2:	90 93 be 04 	sts	0x04BE, r25	; 0x8004be <pxDelayedTaskList+0x1>
    10b6:	80 93 bd 04 	sts	0x04BD, r24	; 0x8004bd <pxDelayedTaskList>
    10ba:	8f eb       	ldi	r24, 0xBF	; 191
    10bc:	94 e0       	ldi	r25, 0x04	; 4
    10be:	90 93 bc 04 	sts	0x04BC, r25	; 0x8004bc <pxOverflowDelayedTaskList+0x1>
    10c2:	80 93 bb 04 	sts	0x04BB, r24	; 0x8004bb <pxOverflowDelayedTaskList>
    10c6:	cf 91       	pop	r28
    10c8:	08 95       	ret

000010ca <prvAddNewTaskToReadyList>:
    10ca:	cf 93       	push	r28
    10cc:	df 93       	push	r29
    10ce:	ec 01       	movw	r28, r24
    10d0:	0f b6       	in	r0, 0x3f	; 63
    10d2:	f8 94       	cli
    10d4:	0f 92       	push	r0
    10d6:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxCurrentNumberOfTasks>
    10da:	8f 5f       	subi	r24, 0xFF	; 255
    10dc:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <uxCurrentNumberOfTasks>
    10e0:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <pxCurrentTCB>
    10e4:	90 91 23 05 	lds	r25, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    10e8:	89 2b       	or	r24, r25
    10ea:	59 f4       	brne	.+22     	; 0x1102 <prvAddNewTaskToReadyList+0x38>
    10ec:	d0 93 23 05 	sts	0x0523, r29	; 0x800523 <pxCurrentTCB+0x1>
    10f0:	c0 93 22 05 	sts	0x0522, r28	; 0x800522 <pxCurrentTCB>
    10f4:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxCurrentNumberOfTasks>
    10f8:	81 30       	cpi	r24, 0x01	; 1
    10fa:	99 f4       	brne	.+38     	; 0x1122 <prvAddNewTaskToReadyList+0x58>
    10fc:	0e 94 32 08 	call	0x1064	; 0x1064 <prvInitialiseTaskLists>
    1100:	10 c0       	rjmp	.+32     	; 0x1122 <prvAddNewTaskToReadyList+0x58>
    1102:	80 91 a3 04 	lds	r24, 0x04A3	; 0x8004a3 <xSchedulerRunning>
    1106:	81 11       	cpse	r24, r1
    1108:	0c c0       	rjmp	.+24     	; 0x1122 <prvAddNewTaskToReadyList+0x58>
    110a:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    110e:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    1112:	96 89       	ldd	r25, Z+22	; 0x16
    1114:	8e 89       	ldd	r24, Y+22	; 0x16
    1116:	89 17       	cp	r24, r25
    1118:	20 f0       	brcs	.+8      	; 0x1122 <prvAddNewTaskToReadyList+0x58>
    111a:	d0 93 23 05 	sts	0x0523, r29	; 0x800523 <pxCurrentTCB+0x1>
    111e:	c0 93 22 05 	sts	0x0522, r28	; 0x800522 <pxCurrentTCB>
    1122:	80 91 9f 04 	lds	r24, 0x049F	; 0x80049f <uxTaskNumber>
    1126:	8f 5f       	subi	r24, 0xFF	; 255
    1128:	80 93 9f 04 	sts	0x049F, r24	; 0x80049f <uxTaskNumber>
    112c:	8e 89       	ldd	r24, Y+22	; 0x16
    112e:	90 91 a4 04 	lds	r25, 0x04A4	; 0x8004a4 <uxTopReadyPriority>
    1132:	98 17       	cp	r25, r24
    1134:	10 f4       	brcc	.+4      	; 0x113a <prvAddNewTaskToReadyList+0x70>
    1136:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <uxTopReadyPriority>
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	9c 01       	movw	r18, r24
    113e:	22 0f       	add	r18, r18
    1140:	33 1f       	adc	r19, r19
    1142:	22 0f       	add	r18, r18
    1144:	33 1f       	adc	r19, r19
    1146:	22 0f       	add	r18, r18
    1148:	33 1f       	adc	r19, r19
    114a:	82 0f       	add	r24, r18
    114c:	93 1f       	adc	r25, r19
    114e:	be 01       	movw	r22, r28
    1150:	6e 5f       	subi	r22, 0xFE	; 254
    1152:	7f 4f       	sbci	r23, 0xFF	; 255
    1154:	8f 52       	subi	r24, 0x2F	; 47
    1156:	9b 4f       	sbci	r25, 0xFB	; 251
    1158:	0e 94 c7 05 	call	0xb8e	; 0xb8e <vListInsertEnd>
    115c:	0f 90       	pop	r0
    115e:	0f be       	out	0x3f, r0	; 63
    1160:	80 91 a3 04 	lds	r24, 0x04A3	; 0x8004a3 <xSchedulerRunning>
    1164:	88 23       	and	r24, r24
    1166:	51 f0       	breq	.+20     	; 0x117c <prvAddNewTaskToReadyList+0xb2>
    1168:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    116c:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    1170:	96 89       	ldd	r25, Z+22	; 0x16
    1172:	8e 89       	ldd	r24, Y+22	; 0x16
    1174:	98 17       	cp	r25, r24
    1176:	10 f4       	brcc	.+4      	; 0x117c <prvAddNewTaskToReadyList+0xb2>
    1178:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <vPortYield>
    117c:	df 91       	pop	r29
    117e:	cf 91       	pop	r28
    1180:	08 95       	ret

00001182 <prvAddCurrentTaskToDelayedList>:
    1182:	0f 93       	push	r16
    1184:	1f 93       	push	r17
    1186:	cf 93       	push	r28
    1188:	df 93       	push	r29
    118a:	ec 01       	movw	r28, r24
    118c:	00 91 a5 04 	lds	r16, 0x04A5	; 0x8004a5 <xTickCount>
    1190:	10 91 a6 04 	lds	r17, 0x04A6	; 0x8004a6 <xTickCount+0x1>
    1194:	80 91 22 05 	lds	r24, 0x0522	; 0x800522 <pxCurrentTCB>
    1198:	90 91 23 05 	lds	r25, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    119c:	02 96       	adiw	r24, 0x02	; 2
    119e:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
    11a2:	c0 0f       	add	r28, r16
    11a4:	d1 1f       	adc	r29, r17
    11a6:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    11aa:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    11ae:	d3 83       	std	Z+3, r29	; 0x03
    11b0:	c2 83       	std	Z+2, r28	; 0x02
    11b2:	c0 17       	cp	r28, r16
    11b4:	d1 07       	cpc	r29, r17
    11b6:	68 f4       	brcc	.+26     	; 0x11d2 <prvAddCurrentTaskToDelayedList+0x50>
    11b8:	60 91 22 05 	lds	r22, 0x0522	; 0x800522 <pxCurrentTCB>
    11bc:	70 91 23 05 	lds	r23, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    11c0:	80 91 bb 04 	lds	r24, 0x04BB	; 0x8004bb <pxOverflowDelayedTaskList>
    11c4:	90 91 bc 04 	lds	r25, 0x04BC	; 0x8004bc <pxOverflowDelayedTaskList+0x1>
    11c8:	6e 5f       	subi	r22, 0xFE	; 254
    11ca:	7f 4f       	sbci	r23, 0xFF	; 255
    11cc:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <vListInsert>
    11d0:	17 c0       	rjmp	.+46     	; 0x1200 <prvAddCurrentTaskToDelayedList+0x7e>
    11d2:	60 91 22 05 	lds	r22, 0x0522	; 0x800522 <pxCurrentTCB>
    11d6:	70 91 23 05 	lds	r23, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    11da:	80 91 bd 04 	lds	r24, 0x04BD	; 0x8004bd <pxDelayedTaskList>
    11de:	90 91 be 04 	lds	r25, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
    11e2:	6e 5f       	subi	r22, 0xFE	; 254
    11e4:	7f 4f       	sbci	r23, 0xFF	; 255
    11e6:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <vListInsert>
    11ea:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <xNextTaskUnblockTime>
    11ee:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <xNextTaskUnblockTime+0x1>
    11f2:	c8 17       	cp	r28, r24
    11f4:	d9 07       	cpc	r29, r25
    11f6:	20 f4       	brcc	.+8      	; 0x1200 <prvAddCurrentTaskToDelayedList+0x7e>
    11f8:	d0 93 9e 04 	sts	0x049E, r29	; 0x80049e <xNextTaskUnblockTime+0x1>
    11fc:	c0 93 9d 04 	sts	0x049D, r28	; 0x80049d <xNextTaskUnblockTime>
    1200:	df 91       	pop	r29
    1202:	cf 91       	pop	r28
    1204:	1f 91       	pop	r17
    1206:	0f 91       	pop	r16
    1208:	08 95       	ret

0000120a <xTaskCreate>:
    120a:	2f 92       	push	r2
    120c:	3f 92       	push	r3
    120e:	4f 92       	push	r4
    1210:	5f 92       	push	r5
    1212:	6f 92       	push	r6
    1214:	7f 92       	push	r7
    1216:	8f 92       	push	r8
    1218:	9f 92       	push	r9
    121a:	af 92       	push	r10
    121c:	bf 92       	push	r11
    121e:	cf 92       	push	r12
    1220:	df 92       	push	r13
    1222:	ef 92       	push	r14
    1224:	ff 92       	push	r15
    1226:	0f 93       	push	r16
    1228:	1f 93       	push	r17
    122a:	cf 93       	push	r28
    122c:	df 93       	push	r29
    122e:	3c 01       	movw	r6, r24
    1230:	1b 01       	movw	r2, r22
    1232:	5a 01       	movw	r10, r20
    1234:	29 01       	movw	r4, r18
    1236:	ca 01       	movw	r24, r20
    1238:	0e 94 06 05 	call	0xa0c	; 0xa0c <pvPortMalloc>
    123c:	6c 01       	movw	r12, r24
    123e:	89 2b       	or	r24, r25
    1240:	71 f0       	breq	.+28     	; 0x125e <xTaskCreate+0x54>
    1242:	88 e2       	ldi	r24, 0x28	; 40
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	0e 94 06 05 	call	0xa0c	; 0xa0c <pvPortMalloc>
    124a:	ec 01       	movw	r28, r24
    124c:	89 2b       	or	r24, r25
    124e:	19 f0       	breq	.+6      	; 0x1256 <xTaskCreate+0x4c>
    1250:	d8 8e       	std	Y+24, r13	; 0x18
    1252:	cf 8a       	std	Y+23, r12	; 0x17
    1254:	06 c0       	rjmp	.+12     	; 0x1262 <xTaskCreate+0x58>
    1256:	c6 01       	movw	r24, r12
    1258:	0e 94 82 05 	call	0xb04	; 0xb04 <vPortFree>
    125c:	02 c0       	rjmp	.+4      	; 0x1262 <xTaskCreate+0x58>
    125e:	c0 e0       	ldi	r28, 0x00	; 0
    1260:	d0 e0       	ldi	r29, 0x00	; 0
    1262:	20 97       	sbiw	r28, 0x00	; 0
    1264:	91 f0       	breq	.+36     	; 0x128a <xTaskCreate+0x80>
    1266:	95 01       	movw	r18, r10
    1268:	40 e0       	ldi	r20, 0x00	; 0
    126a:	50 e0       	ldi	r21, 0x00	; 0
    126c:	81 2c       	mov	r8, r1
    126e:	91 2c       	mov	r9, r1
    1270:	5e 01       	movw	r10, r28
    1272:	67 01       	movw	r12, r14
    1274:	e0 2e       	mov	r14, r16
    1276:	82 01       	movw	r16, r4
    1278:	b1 01       	movw	r22, r2
    127a:	c3 01       	movw	r24, r6
    127c:	0e 94 c7 07 	call	0xf8e	; 0xf8e <prvInitialiseNewTask>
    1280:	ce 01       	movw	r24, r28
    1282:	0e 94 65 08 	call	0x10ca	; 0x10ca <prvAddNewTaskToReadyList>
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	01 c0       	rjmp	.+2      	; 0x128c <xTaskCreate+0x82>
    128a:	8f ef       	ldi	r24, 0xFF	; 255
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	1f 91       	pop	r17
    1292:	0f 91       	pop	r16
    1294:	ff 90       	pop	r15
    1296:	ef 90       	pop	r14
    1298:	df 90       	pop	r13
    129a:	cf 90       	pop	r12
    129c:	bf 90       	pop	r11
    129e:	af 90       	pop	r10
    12a0:	9f 90       	pop	r9
    12a2:	8f 90       	pop	r8
    12a4:	7f 90       	pop	r7
    12a6:	6f 90       	pop	r6
    12a8:	5f 90       	pop	r5
    12aa:	4f 90       	pop	r4
    12ac:	3f 90       	pop	r3
    12ae:	2f 90       	pop	r2
    12b0:	08 95       	ret

000012b2 <vTaskStartScheduler>:
    12b2:	ef 92       	push	r14
    12b4:	ff 92       	push	r15
    12b6:	0f 93       	push	r16
    12b8:	0f 2e       	mov	r0, r31
    12ba:	fb e9       	ldi	r31, 0x9B	; 155
    12bc:	ef 2e       	mov	r14, r31
    12be:	f4 e0       	ldi	r31, 0x04	; 4
    12c0:	ff 2e       	mov	r15, r31
    12c2:	f0 2d       	mov	r31, r0
    12c4:	00 e0       	ldi	r16, 0x00	; 0
    12c6:	20 e0       	ldi	r18, 0x00	; 0
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	40 e5       	ldi	r20, 0x50	; 80
    12cc:	50 e0       	ldi	r21, 0x00	; 0
    12ce:	66 e9       	ldi	r22, 0x96	; 150
    12d0:	70 e0       	ldi	r23, 0x00	; 0
    12d2:	89 ef       	ldi	r24, 0xF9	; 249
    12d4:	9a e0       	ldi	r25, 0x0A	; 10
    12d6:	0e 94 05 09 	call	0x120a	; 0x120a <xTaskCreate>
    12da:	81 30       	cpi	r24, 0x01	; 1
    12dc:	81 f4       	brne	.+32     	; 0x12fe <vTaskStartScheduler+0x4c>
    12de:	f8 94       	cli
    12e0:	8f ef       	ldi	r24, 0xFF	; 255
    12e2:	9f ef       	ldi	r25, 0xFF	; 255
    12e4:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <xNextTaskUnblockTime+0x1>
    12e8:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <xNextTaskUnblockTime>
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	80 93 a3 04 	sts	0x04A3, r24	; 0x8004a3 <xSchedulerRunning>
    12f2:	10 92 a6 04 	sts	0x04A6, r1	; 0x8004a6 <xTickCount+0x1>
    12f6:	10 92 a5 04 	sts	0x04A5, r1	; 0x8004a5 <xTickCount>
    12fa:	0e 94 b4 06 	call	0xd68	; 0xd68 <xPortStartScheduler>
    12fe:	0f 91       	pop	r16
    1300:	ff 90       	pop	r15
    1302:	ef 90       	pop	r14
    1304:	08 95       	ret

00001306 <vTaskSuspendAll>:
    1306:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <uxSchedulerSuspended>
    130a:	8f 5f       	subi	r24, 0xFF	; 255
    130c:	80 93 9a 04 	sts	0x049A, r24	; 0x80049a <uxSchedulerSuspended>
    1310:	08 95       	ret

00001312 <xTaskIncrementTick>:
    1312:	df 92       	push	r13
    1314:	ef 92       	push	r14
    1316:	ff 92       	push	r15
    1318:	0f 93       	push	r16
    131a:	1f 93       	push	r17
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <uxSchedulerSuspended>
    1324:	81 11       	cpse	r24, r1
    1326:	97 c0       	rjmp	.+302    	; 0x1456 <xTaskIncrementTick+0x144>
    1328:	e0 90 a5 04 	lds	r14, 0x04A5	; 0x8004a5 <xTickCount>
    132c:	f0 90 a6 04 	lds	r15, 0x04A6	; 0x8004a6 <xTickCount+0x1>
    1330:	8f ef       	ldi	r24, 0xFF	; 255
    1332:	e8 1a       	sub	r14, r24
    1334:	f8 0a       	sbc	r15, r24
    1336:	f0 92 a6 04 	sts	0x04A6, r15	; 0x8004a6 <xTickCount+0x1>
    133a:	e0 92 a5 04 	sts	0x04A5, r14	; 0x8004a5 <xTickCount>
    133e:	e1 14       	cp	r14, r1
    1340:	f1 04       	cpc	r15, r1
    1342:	b9 f4       	brne	.+46     	; 0x1372 <xTaskIncrementTick+0x60>
    1344:	80 91 bd 04 	lds	r24, 0x04BD	; 0x8004bd <pxDelayedTaskList>
    1348:	90 91 be 04 	lds	r25, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
    134c:	20 91 bb 04 	lds	r18, 0x04BB	; 0x8004bb <pxOverflowDelayedTaskList>
    1350:	30 91 bc 04 	lds	r19, 0x04BC	; 0x8004bc <pxOverflowDelayedTaskList+0x1>
    1354:	30 93 be 04 	sts	0x04BE, r19	; 0x8004be <pxDelayedTaskList+0x1>
    1358:	20 93 bd 04 	sts	0x04BD, r18	; 0x8004bd <pxDelayedTaskList>
    135c:	90 93 bc 04 	sts	0x04BC, r25	; 0x8004bc <pxOverflowDelayedTaskList+0x1>
    1360:	80 93 bb 04 	sts	0x04BB, r24	; 0x8004bb <pxOverflowDelayedTaskList>
    1364:	80 91 a0 04 	lds	r24, 0x04A0	; 0x8004a0 <xNumOfOverflows>
    1368:	8f 5f       	subi	r24, 0xFF	; 255
    136a:	80 93 a0 04 	sts	0x04A0, r24	; 0x8004a0 <xNumOfOverflows>
    136e:	0e 94 9b 07 	call	0xf36	; 0xf36 <prvResetNextTaskUnblockTime>
    1372:	80 91 9d 04 	lds	r24, 0x049D	; 0x80049d <xNextTaskUnblockTime>
    1376:	90 91 9e 04 	lds	r25, 0x049E	; 0x80049e <xNextTaskUnblockTime+0x1>
    137a:	e8 16       	cp	r14, r24
    137c:	f9 06       	cpc	r15, r25
    137e:	28 f4       	brcc	.+10     	; 0x138a <xTaskIncrementTick+0x78>
    1380:	d1 2c       	mov	r13, r1
    1382:	53 c0       	rjmp	.+166    	; 0x142a <xTaskIncrementTick+0x118>
    1384:	dd 24       	eor	r13, r13
    1386:	d3 94       	inc	r13
    1388:	01 c0       	rjmp	.+2      	; 0x138c <xTaskIncrementTick+0x7a>
    138a:	d1 2c       	mov	r13, r1
    138c:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <pxDelayedTaskList>
    1390:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
    1394:	80 81       	ld	r24, Z
    1396:	81 11       	cpse	r24, r1
    1398:	07 c0       	rjmp	.+14     	; 0x13a8 <xTaskIncrementTick+0x96>
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <xNextTaskUnblockTime+0x1>
    13a2:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <xNextTaskUnblockTime>
    13a6:	41 c0       	rjmp	.+130    	; 0x142a <xTaskIncrementTick+0x118>
    13a8:	e0 91 bd 04 	lds	r30, 0x04BD	; 0x8004bd <pxDelayedTaskList>
    13ac:	f0 91 be 04 	lds	r31, 0x04BE	; 0x8004be <pxDelayedTaskList+0x1>
    13b0:	05 80       	ldd	r0, Z+5	; 0x05
    13b2:	f6 81       	ldd	r31, Z+6	; 0x06
    13b4:	e0 2d       	mov	r30, r0
    13b6:	c6 81       	ldd	r28, Z+6	; 0x06
    13b8:	d7 81       	ldd	r29, Z+7	; 0x07
    13ba:	8a 81       	ldd	r24, Y+2	; 0x02
    13bc:	9b 81       	ldd	r25, Y+3	; 0x03
    13be:	e8 16       	cp	r14, r24
    13c0:	f9 06       	cpc	r15, r25
    13c2:	28 f4       	brcc	.+10     	; 0x13ce <xTaskIncrementTick+0xbc>
    13c4:	90 93 9e 04 	sts	0x049E, r25	; 0x80049e <xNextTaskUnblockTime+0x1>
    13c8:	80 93 9d 04 	sts	0x049D, r24	; 0x80049d <xNextTaskUnblockTime>
    13cc:	2e c0       	rjmp	.+92     	; 0x142a <xTaskIncrementTick+0x118>
    13ce:	8e 01       	movw	r16, r28
    13d0:	0e 5f       	subi	r16, 0xFE	; 254
    13d2:	1f 4f       	sbci	r17, 0xFF	; 255
    13d4:	c8 01       	movw	r24, r16
    13d6:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
    13da:	8c 89       	ldd	r24, Y+20	; 0x14
    13dc:	9d 89       	ldd	r25, Y+21	; 0x15
    13de:	89 2b       	or	r24, r25
    13e0:	21 f0       	breq	.+8      	; 0x13ea <xTaskIncrementTick+0xd8>
    13e2:	ce 01       	movw	r24, r28
    13e4:	0c 96       	adiw	r24, 0x0c	; 12
    13e6:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
    13ea:	8e 89       	ldd	r24, Y+22	; 0x16
    13ec:	90 91 a4 04 	lds	r25, 0x04A4	; 0x8004a4 <uxTopReadyPriority>
    13f0:	98 17       	cp	r25, r24
    13f2:	10 f4       	brcc	.+4      	; 0x13f8 <xTaskIncrementTick+0xe6>
    13f4:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <uxTopReadyPriority>
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	9c 01       	movw	r18, r24
    13fc:	22 0f       	add	r18, r18
    13fe:	33 1f       	adc	r19, r19
    1400:	22 0f       	add	r18, r18
    1402:	33 1f       	adc	r19, r19
    1404:	22 0f       	add	r18, r18
    1406:	33 1f       	adc	r19, r19
    1408:	82 0f       	add	r24, r18
    140a:	93 1f       	adc	r25, r19
    140c:	b8 01       	movw	r22, r16
    140e:	8f 52       	subi	r24, 0x2F	; 47
    1410:	9b 4f       	sbci	r25, 0xFB	; 251
    1412:	0e 94 c7 05 	call	0xb8e	; 0xb8e <vListInsertEnd>
    1416:	9e 89       	ldd	r25, Y+22	; 0x16
    1418:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    141c:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    1420:	86 89       	ldd	r24, Z+22	; 0x16
    1422:	98 17       	cp	r25, r24
    1424:	08 f0       	brcs	.+2      	; 0x1428 <xTaskIncrementTick+0x116>
    1426:	ae cf       	rjmp	.-164    	; 0x1384 <xTaskIncrementTick+0x72>
    1428:	b1 cf       	rjmp	.-158    	; 0x138c <xTaskIncrementTick+0x7a>
    142a:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    142e:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    1432:	86 89       	ldd	r24, Z+22	; 0x16
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	fc 01       	movw	r30, r24
    1438:	ee 0f       	add	r30, r30
    143a:	ff 1f       	adc	r31, r31
    143c:	ee 0f       	add	r30, r30
    143e:	ff 1f       	adc	r31, r31
    1440:	ee 0f       	add	r30, r30
    1442:	ff 1f       	adc	r31, r31
    1444:	8e 0f       	add	r24, r30
    1446:	9f 1f       	adc	r25, r31
    1448:	fc 01       	movw	r30, r24
    144a:	ef 52       	subi	r30, 0x2F	; 47
    144c:	fb 4f       	sbci	r31, 0xFB	; 251
    144e:	80 81       	ld	r24, Z
    1450:	82 30       	cpi	r24, 0x02	; 2
    1452:	40 f4       	brcc	.+16     	; 0x1464 <xTaskIncrementTick+0x152>
    1454:	09 c0       	rjmp	.+18     	; 0x1468 <xTaskIncrementTick+0x156>
    1456:	80 91 a2 04 	lds	r24, 0x04A2	; 0x8004a2 <uxPendedTicks>
    145a:	8f 5f       	subi	r24, 0xFF	; 255
    145c:	80 93 a2 04 	sts	0x04A2, r24	; 0x8004a2 <uxPendedTicks>
    1460:	d1 2c       	mov	r13, r1
    1462:	02 c0       	rjmp	.+4      	; 0x1468 <xTaskIncrementTick+0x156>
    1464:	dd 24       	eor	r13, r13
    1466:	d3 94       	inc	r13
    1468:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <xYieldPending>
    146c:	88 23       	and	r24, r24
    146e:	11 f0       	breq	.+4      	; 0x1474 <xTaskIncrementTick+0x162>
    1470:	dd 24       	eor	r13, r13
    1472:	d3 94       	inc	r13
    1474:	8d 2d       	mov	r24, r13
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	ff 90       	pop	r15
    1480:	ef 90       	pop	r14
    1482:	df 90       	pop	r13
    1484:	08 95       	ret

00001486 <xTaskResumeAll>:
    1486:	0f 93       	push	r16
    1488:	1f 93       	push	r17
    148a:	cf 93       	push	r28
    148c:	df 93       	push	r29
    148e:	0f b6       	in	r0, 0x3f	; 63
    1490:	f8 94       	cli
    1492:	0f 92       	push	r0
    1494:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <uxSchedulerSuspended>
    1498:	81 50       	subi	r24, 0x01	; 1
    149a:	80 93 9a 04 	sts	0x049A, r24	; 0x80049a <uxSchedulerSuspended>
    149e:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <uxSchedulerSuspended>
    14a2:	81 11       	cpse	r24, r1
    14a4:	58 c0       	rjmp	.+176    	; 0x1556 <xTaskResumeAll+0xd0>
    14a6:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxCurrentNumberOfTasks>
    14aa:	81 11       	cpse	r24, r1
    14ac:	33 c0       	rjmp	.+102    	; 0x1514 <xTaskResumeAll+0x8e>
    14ae:	56 c0       	rjmp	.+172    	; 0x155c <xTaskResumeAll+0xd6>
    14b0:	e0 91 b7 04 	lds	r30, 0x04B7	; 0x8004b7 <xPendingReadyList+0x5>
    14b4:	f0 91 b8 04 	lds	r31, 0x04B8	; 0x8004b8 <xPendingReadyList+0x6>
    14b8:	c6 81       	ldd	r28, Z+6	; 0x06
    14ba:	d7 81       	ldd	r29, Z+7	; 0x07
    14bc:	ce 01       	movw	r24, r28
    14be:	0c 96       	adiw	r24, 0x0c	; 12
    14c0:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
    14c4:	8e 01       	movw	r16, r28
    14c6:	0e 5f       	subi	r16, 0xFE	; 254
    14c8:	1f 4f       	sbci	r17, 0xFF	; 255
    14ca:	c8 01       	movw	r24, r16
    14cc:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
    14d0:	8e 89       	ldd	r24, Y+22	; 0x16
    14d2:	90 91 a4 04 	lds	r25, 0x04A4	; 0x8004a4 <uxTopReadyPriority>
    14d6:	98 17       	cp	r25, r24
    14d8:	10 f4       	brcc	.+4      	; 0x14de <xTaskResumeAll+0x58>
    14da:	80 93 a4 04 	sts	0x04A4, r24	; 0x8004a4 <uxTopReadyPriority>
    14de:	90 e0       	ldi	r25, 0x00	; 0
    14e0:	9c 01       	movw	r18, r24
    14e2:	22 0f       	add	r18, r18
    14e4:	33 1f       	adc	r19, r19
    14e6:	22 0f       	add	r18, r18
    14e8:	33 1f       	adc	r19, r19
    14ea:	22 0f       	add	r18, r18
    14ec:	33 1f       	adc	r19, r19
    14ee:	82 0f       	add	r24, r18
    14f0:	93 1f       	adc	r25, r19
    14f2:	b8 01       	movw	r22, r16
    14f4:	8f 52       	subi	r24, 0x2F	; 47
    14f6:	9b 4f       	sbci	r25, 0xFB	; 251
    14f8:	0e 94 c7 05 	call	0xb8e	; 0xb8e <vListInsertEnd>
    14fc:	9e 89       	ldd	r25, Y+22	; 0x16
    14fe:	e0 91 22 05 	lds	r30, 0x0522	; 0x800522 <pxCurrentTCB>
    1502:	f0 91 23 05 	lds	r31, 0x0523	; 0x800523 <pxCurrentTCB+0x1>
    1506:	86 89       	ldd	r24, Z+22	; 0x16
    1508:	98 17       	cp	r25, r24
    150a:	30 f0       	brcs	.+12     	; 0x1518 <xTaskResumeAll+0x92>
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <xYieldPending>
    1512:	02 c0       	rjmp	.+4      	; 0x1518 <xTaskResumeAll+0x92>
    1514:	c0 e0       	ldi	r28, 0x00	; 0
    1516:	d0 e0       	ldi	r29, 0x00	; 0
    1518:	80 91 b2 04 	lds	r24, 0x04B2	; 0x8004b2 <xPendingReadyList>
    151c:	81 11       	cpse	r24, r1
    151e:	c8 cf       	rjmp	.-112    	; 0x14b0 <xTaskResumeAll+0x2a>
    1520:	cd 2b       	or	r28, r29
    1522:	11 f0       	breq	.+4      	; 0x1528 <xTaskResumeAll+0xa2>
    1524:	0e 94 9b 07 	call	0xf36	; 0xf36 <prvResetNextTaskUnblockTime>
    1528:	c0 91 a2 04 	lds	r28, 0x04A2	; 0x8004a2 <uxPendedTicks>
    152c:	cc 23       	and	r28, r28
    152e:	59 f0       	breq	.+22     	; 0x1546 <xTaskResumeAll+0xc0>
    1530:	0e 94 89 09 	call	0x1312	; 0x1312 <xTaskIncrementTick>
    1534:	88 23       	and	r24, r24
    1536:	19 f0       	breq	.+6      	; 0x153e <xTaskResumeAll+0xb8>
    1538:	81 e0       	ldi	r24, 0x01	; 1
    153a:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <xYieldPending>
    153e:	c1 50       	subi	r28, 0x01	; 1
    1540:	b9 f7       	brne	.-18     	; 0x1530 <xTaskResumeAll+0xaa>
    1542:	10 92 a2 04 	sts	0x04A2, r1	; 0x8004a2 <uxPendedTicks>
    1546:	80 91 a1 04 	lds	r24, 0x04A1	; 0x8004a1 <xYieldPending>
    154a:	88 23       	and	r24, r24
    154c:	31 f0       	breq	.+12     	; 0x155a <xTaskResumeAll+0xd4>
    154e:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <vPortYield>
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	03 c0       	rjmp	.+6      	; 0x155c <xTaskResumeAll+0xd6>
    1556:	80 e0       	ldi	r24, 0x00	; 0
    1558:	01 c0       	rjmp	.+2      	; 0x155c <xTaskResumeAll+0xd6>
    155a:	80 e0       	ldi	r24, 0x00	; 0
    155c:	0f 90       	pop	r0
    155e:	0f be       	out	0x3f, r0	; 63
    1560:	df 91       	pop	r29
    1562:	cf 91       	pop	r28
    1564:	1f 91       	pop	r17
    1566:	0f 91       	pop	r16
    1568:	08 95       	ret

0000156a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    156a:	cf 93       	push	r28
    156c:	df 93       	push	r29
    156e:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1570:	89 2b       	or	r24, r25
    1572:	49 f0       	breq	.+18     	; 0x1586 <vTaskDelay+0x1c>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1574:	0e 94 83 09 	call	0x1306	; 0x1306 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1578:	60 e0       	ldi	r22, 0x00	; 0
    157a:	ce 01       	movw	r24, r28
    157c:	0e 94 c1 08 	call	0x1182	; 0x1182 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1580:	0e 94 43 0a 	call	0x1486	; 0x1486 <xTaskResumeAll>
    1584:	01 c0       	rjmp	.+2      	; 0x1588 <vTaskDelay+0x1e>

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;
    1586:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1588:	81 11       	cpse	r24, r1
    158a:	02 c0       	rjmp	.+4      	; 0x1590 <vTaskDelay+0x26>
		{
			portYIELD_WITHIN_API();
    158c:	0e 94 e3 06 	call	0xdc6	; 0xdc6 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1590:	df 91       	pop	r29
    1592:	cf 91       	pop	r28
    1594:	08 95       	ret

00001596 <prvCheckTasksWaitingTermination>:
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
}
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    159a:	24 c0       	rjmp	.+72     	; 0x15e4 <prvCheckTasksWaitingTermination+0x4e>
		{
			vTaskSuspendAll();
    159c:	0e 94 83 09 	call	0x1306	; 0x1306 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    15a0:	c0 91 a9 04 	lds	r28, 0x04A9	; 0x8004a9 <xTasksWaitingTermination>
			}
			( void ) xTaskResumeAll();
    15a4:	0e 94 43 0a 	call	0x1486	; 0x1486 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    15a8:	cc 23       	and	r28, r28
    15aa:	e1 f0       	breq	.+56     	; 0x15e4 <prvCheckTasksWaitingTermination+0x4e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	f8 94       	cli
    15b0:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    15b2:	e0 91 ae 04 	lds	r30, 0x04AE	; 0x8004ae <xTasksWaitingTermination+0x5>
    15b6:	f0 91 af 04 	lds	r31, 0x04AF	; 0x8004af <xTasksWaitingTermination+0x6>
    15ba:	c6 81       	ldd	r28, Z+6	; 0x06
    15bc:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    15be:	ce 01       	movw	r24, r28
    15c0:	02 96       	adiw	r24, 0x02	; 2
    15c2:	0e 94 19 06 	call	0xc32	; 0xc32 <uxListRemove>
					--uxCurrentNumberOfTasks;
    15c6:	80 91 a7 04 	lds	r24, 0x04A7	; 0x8004a7 <uxCurrentNumberOfTasks>
    15ca:	81 50       	subi	r24, 0x01	; 1
    15cc:	80 93 a7 04 	sts	0x04A7, r24	; 0x8004a7 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
    15d0:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <uxDeletedTasksWaitingCleanUp>
    15d4:	81 50       	subi	r24, 0x01	; 1
    15d6:	80 93 a8 04 	sts	0x04A8, r24	; 0x8004a8 <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
    15da:	0f 90       	pop	r0
    15dc:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    15de:	ce 01       	movw	r24, r28
    15e0:	0e 94 ba 07 	call	0xf74	; 0xf74 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    15e4:	80 91 a8 04 	lds	r24, 0x04A8	; 0x8004a8 <uxDeletedTasksWaitingCleanUp>
    15e8:	81 11       	cpse	r24, r1
    15ea:	d8 cf       	rjmp	.-80     	; 0x159c <prvCheckTasksWaitingTermination+0x6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    15ec:	df 91       	pop	r29
    15ee:	cf 91       	pop	r28
    15f0:	08 95       	ret

000015f2 <prvIdleTask>:

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    15f2:	0e 94 cb 0a 	call	0x1596	; 0x1596 <prvCheckTasksWaitingTermination>
    15f6:	fd cf       	rjmp	.-6      	; 0x15f2 <prvIdleTask>

000015f8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    15f8:	80 91 9a 04 	lds	r24, 0x049A	; 0x80049a <uxSchedulerSuspended>
    15fc:	88 23       	and	r24, r24
    15fe:	21 f0       	breq	.+8      	; 0x1608 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	80 93 a1 04 	sts	0x04A1, r24	; 0x8004a1 <xYieldPending>
    1606:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1608:	10 92 a1 04 	sts	0x04A1, r1	; 0x8004a1 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    160c:	20 91 a4 04 	lds	r18, 0x04A4	; 0x8004a4 <uxTopReadyPriority>
    1610:	01 c0       	rjmp	.+2      	; 0x1614 <vTaskSwitchContext+0x1c>
    1612:	21 50       	subi	r18, 0x01	; 1
    1614:	82 2f       	mov	r24, r18
    1616:	90 e0       	ldi	r25, 0x00	; 0
    1618:	fc 01       	movw	r30, r24
    161a:	ee 0f       	add	r30, r30
    161c:	ff 1f       	adc	r31, r31
    161e:	ee 0f       	add	r30, r30
    1620:	ff 1f       	adc	r31, r31
    1622:	ee 0f       	add	r30, r30
    1624:	ff 1f       	adc	r31, r31
    1626:	e8 0f       	add	r30, r24
    1628:	f9 1f       	adc	r31, r25
    162a:	ef 52       	subi	r30, 0x2F	; 47
    162c:	fb 4f       	sbci	r31, 0xFB	; 251
    162e:	30 81       	ld	r19, Z
    1630:	33 23       	and	r19, r19
    1632:	79 f3       	breq	.-34     	; 0x1612 <vTaskSwitchContext+0x1a>
    1634:	ac 01       	movw	r20, r24
    1636:	44 0f       	add	r20, r20
    1638:	55 1f       	adc	r21, r21
    163a:	44 0f       	add	r20, r20
    163c:	55 1f       	adc	r21, r21
    163e:	44 0f       	add	r20, r20
    1640:	55 1f       	adc	r21, r21
    1642:	48 0f       	add	r20, r24
    1644:	59 1f       	adc	r21, r25
    1646:	df 01       	movw	r26, r30
    1648:	01 80       	ldd	r0, Z+1	; 0x01
    164a:	f2 81       	ldd	r31, Z+2	; 0x02
    164c:	e0 2d       	mov	r30, r0
    164e:	02 80       	ldd	r0, Z+2	; 0x02
    1650:	f3 81       	ldd	r31, Z+3	; 0x03
    1652:	e0 2d       	mov	r30, r0
    1654:	12 96       	adiw	r26, 0x02	; 2
    1656:	fc 93       	st	X, r31
    1658:	ee 93       	st	-X, r30
    165a:	11 97       	sbiw	r26, 0x01	; 1
    165c:	4c 52       	subi	r20, 0x2C	; 44
    165e:	5b 4f       	sbci	r21, 0xFB	; 251
    1660:	e4 17       	cp	r30, r20
    1662:	f5 07       	cpc	r31, r21
    1664:	29 f4       	brne	.+10     	; 0x1670 <vTaskSwitchContext+0x78>
    1666:	42 81       	ldd	r20, Z+2	; 0x02
    1668:	53 81       	ldd	r21, Z+3	; 0x03
    166a:	fd 01       	movw	r30, r26
    166c:	52 83       	std	Z+2, r21	; 0x02
    166e:	41 83       	std	Z+1, r20	; 0x01
    1670:	fc 01       	movw	r30, r24
    1672:	ee 0f       	add	r30, r30
    1674:	ff 1f       	adc	r31, r31
    1676:	ee 0f       	add	r30, r30
    1678:	ff 1f       	adc	r31, r31
    167a:	ee 0f       	add	r30, r30
    167c:	ff 1f       	adc	r31, r31
    167e:	8e 0f       	add	r24, r30
    1680:	9f 1f       	adc	r25, r31
    1682:	fc 01       	movw	r30, r24
    1684:	ef 52       	subi	r30, 0x2F	; 47
    1686:	fb 4f       	sbci	r31, 0xFB	; 251
    1688:	01 80       	ldd	r0, Z+1	; 0x01
    168a:	f2 81       	ldd	r31, Z+2	; 0x02
    168c:	e0 2d       	mov	r30, r0
    168e:	86 81       	ldd	r24, Z+6	; 0x06
    1690:	97 81       	ldd	r25, Z+7	; 0x07
    1692:	90 93 23 05 	sts	0x0523, r25	; 0x800523 <pxCurrentTCB+0x1>
    1696:	80 93 22 05 	sts	0x0522, r24	; 0x800522 <pxCurrentTCB>
    169a:	20 93 a4 04 	sts	0x04A4, r18	; 0x8004a4 <uxTopReadyPriority>
    169e:	08 95       	ret

000016a0 <__udivmodsi4>:
    16a0:	a1 e2       	ldi	r26, 0x21	; 33
    16a2:	1a 2e       	mov	r1, r26
    16a4:	aa 1b       	sub	r26, r26
    16a6:	bb 1b       	sub	r27, r27
    16a8:	fd 01       	movw	r30, r26
    16aa:	0d c0       	rjmp	.+26     	; 0x16c6 <__udivmodsi4_ep>

000016ac <__udivmodsi4_loop>:
    16ac:	aa 1f       	adc	r26, r26
    16ae:	bb 1f       	adc	r27, r27
    16b0:	ee 1f       	adc	r30, r30
    16b2:	ff 1f       	adc	r31, r31
    16b4:	a2 17       	cp	r26, r18
    16b6:	b3 07       	cpc	r27, r19
    16b8:	e4 07       	cpc	r30, r20
    16ba:	f5 07       	cpc	r31, r21
    16bc:	20 f0       	brcs	.+8      	; 0x16c6 <__udivmodsi4_ep>
    16be:	a2 1b       	sub	r26, r18
    16c0:	b3 0b       	sbc	r27, r19
    16c2:	e4 0b       	sbc	r30, r20
    16c4:	f5 0b       	sbc	r31, r21

000016c6 <__udivmodsi4_ep>:
    16c6:	66 1f       	adc	r22, r22
    16c8:	77 1f       	adc	r23, r23
    16ca:	88 1f       	adc	r24, r24
    16cc:	99 1f       	adc	r25, r25
    16ce:	1a 94       	dec	r1
    16d0:	69 f7       	brne	.-38     	; 0x16ac <__udivmodsi4_loop>
    16d2:	60 95       	com	r22
    16d4:	70 95       	com	r23
    16d6:	80 95       	com	r24
    16d8:	90 95       	com	r25
    16da:	9b 01       	movw	r18, r22
    16dc:	ac 01       	movw	r20, r24
    16de:	bd 01       	movw	r22, r26
    16e0:	cf 01       	movw	r24, r30
    16e2:	08 95       	ret

000016e4 <__divmodsi4>:
    16e4:	05 2e       	mov	r0, r21
    16e6:	97 fb       	bst	r25, 7
    16e8:	1e f4       	brtc	.+6      	; 0x16f0 <__divmodsi4+0xc>
    16ea:	00 94       	com	r0
    16ec:	0e 94 89 0b 	call	0x1712	; 0x1712 <__negsi2>
    16f0:	57 fd       	sbrc	r21, 7
    16f2:	07 d0       	rcall	.+14     	; 0x1702 <__divmodsi4_neg2>
    16f4:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <__udivmodsi4>
    16f8:	07 fc       	sbrc	r0, 7
    16fa:	03 d0       	rcall	.+6      	; 0x1702 <__divmodsi4_neg2>
    16fc:	4e f4       	brtc	.+18     	; 0x1710 <__divmodsi4_exit>
    16fe:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__negsi2>

00001702 <__divmodsi4_neg2>:
    1702:	50 95       	com	r21
    1704:	40 95       	com	r20
    1706:	30 95       	com	r19
    1708:	21 95       	neg	r18
    170a:	3f 4f       	sbci	r19, 0xFF	; 255
    170c:	4f 4f       	sbci	r20, 0xFF	; 255
    170e:	5f 4f       	sbci	r21, 0xFF	; 255

00001710 <__divmodsi4_exit>:
    1710:	08 95       	ret

00001712 <__negsi2>:
    1712:	90 95       	com	r25
    1714:	80 95       	com	r24
    1716:	70 95       	com	r23
    1718:	61 95       	neg	r22
    171a:	7f 4f       	sbci	r23, 0xFF	; 255
    171c:	8f 4f       	sbci	r24, 0xFF	; 255
    171e:	9f 4f       	sbci	r25, 0xFF	; 255
    1720:	08 95       	ret

00001722 <__tablejump2__>:
    1722:	ee 0f       	add	r30, r30
    1724:	ff 1f       	adc	r31, r31
    1726:	05 90       	lpm	r0, Z+
    1728:	f4 91       	lpm	r31, Z
    172a:	e0 2d       	mov	r30, r0
    172c:	09 94       	ijmp

0000172e <_exit>:
    172e:	f8 94       	cli

00001730 <__stop_program>:
    1730:	ff cf       	rjmp	.-2      	; 0x1730 <__stop_program>
